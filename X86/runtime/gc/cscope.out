cscope 15 /mnt/work/MLton/runtime/gc               0000255605
	@align.c

9 
size_t
 
	$ÆignWôhExåa
 (
GC_°©e
 
s
, 
size_t
 
byãs
, size_à
exåa
) {

10  
	`Æign
 (
byãs
 + 
exåa
, 
s
->
Æignmít
) -Éxtra;

11 
	}
}

14 #i‡
ASSERT


15 
boﬁ
 
	$isFr⁄tõrAlig√d
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

16  
	`isAlig√d
 ((
size_t
)
p
 + 
GC_NORMAL_HEADER_SIZE
,

17 
s
->
Æignmít
);

18 
	}
}

21 
poöãr
 
	$ÆignFr⁄tõr
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

22 
size_t
 
ªs
;

24 
ªs
 = 
	`ÆignWôhExåa
 (
s
, (
size_t
)
p
, 
GC_NORMAL_HEADER_SIZE
);

25 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, (
poöãr
)
ªs
));

26  (
poöãr
)
ªs
;

27 
	}
}

	@align.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

12 
ölöe
 
size_t
 
ÆignWôhExåa
 (
GC_°©e
 
s
, size_à
byãs
, size_à
exåa
);

14 #i‡
ASSERT


15 
ölöe
 
boﬁ
 
isFr⁄tõrAlig√d
 (
GC_°©e
 
s
, 
poöãr
 
p
);

17 
ölöe
 
poöãr
 
ÆignFr⁄tõr
 (
GC_°©e
 
s
,Öoöã∏
p
);

	@array-allocate.c

9 
poöãr
 
	$GC_¨øyAŒoˇã
 (
GC_°©e
 
s
,

10 
size_t
 
ísuªByãsFªe
,

11 
GC_¨øyLígth
 
numEÀmíts
,

12 
GC_hódî
 
hódî
) {

13 
size_t
 
¨øySize
, 
¨øySizeAlig√d
;

14 
size_t
 
byãsPîEÀmít
;

15 
uöt16_t
 
byãsN⁄Obj±rs
;

16 
uöt16_t
 
numObj±rs
;

17 
poöãr
 
‰⁄tõr
;

18 
poöãr
 
œ°
;

19 
poöãr
 
ªsu…
;

21 
	`•lôHódî
(
s
, 
hódî
, 
NULL
, NULL, &
byãsN⁄Obj±rs
, &
numObj±rs
);

22 i‡(
DEBUG
)

23 
	`Ârötf
 (
°dîr
, "GC_¨øyAŒoˇã (%"
PRIuMAX
", "
FMTARRLEN
", "
FMTHDR
")\n",

24 (
uötmax_t
)
ísuªByãsFªe
, 
numEÀmíts
, 
hódî
);

25 
byãsPîEÀmít
 = 
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
);

29 i‡(
numEÀmíts
 > (
SIZE_MAX
 / 
byãsPîEÀmít
)) {

30 
doOvîÊow
;

32 
¨øySize
 = 
byãsPîEÀmít
 * 
numEÀmíts
;

33 i‡(
¨øySize
 > 
SIZE_MAX
 - 
GC_ARRAY_HEADER_SIZE
) {

34 
doOvîÊow
;

36 
¨øySize
 +
GC_ARRAY_HEADER_SIZE
;

37 
¨øySizeAlig√d
 = 
	`Æign
 (
¨øySize
, 
s
->
Æignmít
);

38 i‡(
¨øySizeAlig√d
 < 
¨øySize
) {

39 
doOvîÊow
;

41 i‡(
¨øySizeAlig√d
 < 
GC_ARRAY_HEADER_SIZE
 + 
OBJPTR_SIZE
) {

45 
¨øySize
 = 
GC_ARRAY_HEADER_SIZE
;

46 
¨øySizeAlig√d
 = 
	`Æign
(
GC_ARRAY_HEADER_SIZE
 + 
OBJPTR_SIZE
, 
s
->
Æignmít
);

48 i‡(
DEBUG_ARRAY
)

49 
	`Ârötf
 (
°dîr
,

50 "Aºay wôh "
FMTARRLEN
"É…†o‡sizê%"
PRIuMAX
"ándÅotal size %sándÅotaláligned size %s. "

52 
numEÀmíts
, (
uötmax_t
)
byãsPîEÀmít
,

53 
	`uötmaxToCommaSåög
(
¨øySize
),

54 
	`uötmaxToCommaSåög
(
¨øySizeAlig√d
),

55 
	`uötmaxToCommaSåög
(
ísuªByãsFªe
));

56 i‡(
¨øySizeAlig√d
 >
s
->
c⁄åﬁs
.
ﬁdGíAºaySize
) {

57 i‡(
nŸ
 
	`hasHópByãsFªe
 (
s
, 
¨øySizeAlig√d
, 
ísuªByãsFªe
)) {

58 
	`íãr
 (
s
);

59 
	`≥rf‹mGC
 (
s
, 
¨øySizeAlig√d
, 
ísuªByãsFªe
, 
FALSE
, 
TRUE
);

60 
	`Àave
 (
s
);

62 
‰⁄tõr
 = 
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
;

63 
s
->
hóp
.
ﬁdGíSize
 +
¨øySizeAlig√d
;

64 
s
->
cumuœtiveSèti°ics
.
byãsAŒoˇãd
 +
¨øySizeAlig√d
;

66 
size_t
 
byãsReque°ed
;

67 
poöãr
 
√wFr⁄tõr
;

69 
byãsReque°ed
 = 
¨øySizeAlig√d
 + 
ísuªByãsFªe
;

70 i‡(
nŸ
 
	`hasHópByãsFªe
 (
s
, 0, 
byãsReque°ed
)) {

71 
	`íãr
 (
s
);

72 
	`≥rf‹mGC
 (
s
, 0, 
byãsReque°ed
, 
FALSE
, 
TRUE
);

73 
	`Àave
 (
s
);

75 
‰⁄tõr
 = 
s
->frontier;

76 
√wFr⁄tõr
 = 
‰⁄tõr
 + 
¨øySizeAlig√d
;

77 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, 
√wFr⁄tõr
));

78 
s
->
‰⁄tõr
 = 
√wFr⁄tõr
;

80 
œ°
 = 
‰⁄tõr
 + 
¨øySize
;

81 *((
GC_¨øyCou¡î
*)(
‰⁄tõr
)) = 0;

82 
‰⁄tõr
 = fr⁄tõ∏+ 
GC_ARRAY_COUNTER_SIZE
;

83 *((
GC_¨øyLígth
*)(
‰⁄tõr
)Ë
numEÀmíts
;

84 
‰⁄tõr
 = fr⁄tõ∏+ 
GC_ARRAY_LENGTH_SIZE
;

85 *((
GC_hódî
*)(
‰⁄tõr
)Ë
hódî
;

86 
‰⁄tõr
 = fr⁄tõ∏+ 
GC_HEADER_SIZE
;

87 
ªsu…
 = 
‰⁄tõr
;

88 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
ªsu…
, 
s
->
Æignmít
));

90 i‡(1 <
numObj±rs
 
™d
 0 < 
numEÀmíts
) {

91 
poöãr
 
p
;

93 i‡(0 =
byãsN⁄Obj±rs
)

94 
p
 = 
‰⁄tõr
;Ö < 
œ°
;Ö +
OBJPTR_SIZE
)

95 *((
obj±r
*)
p
Ë
BOGUS_OBJPTR
;

98 
size_t
 
byãsObj±rs
;

100 
byãsObj±rs
 = 
numObj±rs
 * 
OBJPTR_SIZE
;

102 
p
 = 
‰⁄tõr
;Ö < 
œ°
; ) {

103 
poöãr
 
√xt
;

105 
p
 +
byãsN⁄Obj±rs
;

106 
√xt
 = 
p
 + 
byãsObj±rs
;

107 
	`as£π
 (
√xt
 <
œ°
);

108  ; 
p
 < 
√xt
;Ö +
OBJPTR_SIZE
)

109 *((
obj±r
*)
p
Ë
BOGUS_OBJPTR
;

113 
	`GC_¥ofûeAŒocInc
 (
s
, 
¨øySizeAlig√d
);

114 i‡(
DEBUG_ARRAY
) {

115 
	`Ârötf
 (
°dîr
, "GC_¨øyAŒoˇã d⁄e.Ñesu… = "
FMTPTR
" frontier = "FMTPTR"\n",

116 (
uöçå_t
)
ªsu…
, (uöçå_t)
s
->
‰⁄tõr
);

117 
	`di•œyGCSèã
 (
s
, 
°dîr
);

119 
	`as£π
 (
ísuªByãsFªe
 <(
size_t
)(
s
->
limôPlusSl›
 - s->
‰⁄tõr
));

124  
ªsu…
;

126 
doOvîÊow
:

127 
	`dõ
 ("Ouào‡mem‹y. U«bÀÅÿÆloˇãáºay wôh "
FMTARRLEN
"ÉÀmít†™dÉÀmít†o‡sizê%"
PRIuMAX
" bytes.",

128 
numEÀmíts
, (
uötmax_t
)
byãsPîEÀmít
);

129 
	}
}

	@array-allocate.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

11 
PRIVATE
 
poöãr
 
GC_¨øyAŒoˇã
 (
GC_°©e
 
s
,

12 
size_t
 
ísuªByãsFªe
,

13 
GC_¨øyLígth
 
numEÀmíts
,

14 
GC_hódî
 
hódî
);

	@array.c

14 
GC_¨øyLígth
* 
	$gëAºayLígthp
 (
poöãr
 
a
) {

15  (
GC_¨øyLígth
*)(
a


16 - 
GC_HEADER_SIZE


17 - 
GC_ARRAY_LENGTH_SIZE
);

18 
	}
}

24 
GC_¨øyLígth
 
	$gëAºayLígth
 (
poöãr
 
a
) {

25  *(
	`gëAºayLígthp
 (
a
));

26 
	}
}

28 
uötmax_t
 
	$GC_gëAºayLígth
 (
poöãr
 
a
) {

29  ((
uötmax_t
)(
	`gëAºayLígth
 (
a
)));

30 
	}
}

36 
GC_¨øyCou¡î
* 
	$gëAºayCou¡îp
 (
poöãr
 
a
) {

37  (
GC_¨øyCou¡î
*)(
a


38 - 
GC_HEADER_SIZE


39 - 
GC_ARRAY_LENGTH_SIZE


40 - 
GC_ARRAY_COUNTER_SIZE
);

41 
	}
}

47 
GC_¨øyCou¡î
 
	$gëAºayCou¡î
 (
poöãr
 
a
) {

48  *(
	`gëAºayCou¡îp
 (
a
));

49 
	}
}

53 #i‡
ASSERT


54 
poöãr
 
	$ödexAºayAtObj±rIndex
 (
GC_°©e
 
s
, 
poöãr
 
a
,

55 
GC_¨øyCou¡î
 
¨øyIndex
,

56 
uöt32_t
 
obj±rIndex
) {

57 
GC_hódî
 
hódî
;

58 
uöt16_t
 
byãsN⁄Obj±rs
;

59 
uöt16_t
 
numObj±rs
;

60 
GC_obje˘Ty≥Tag
 
èg
;

62 
hódî
 = 
	`gëHódî
 (
a
);

63 
	`•lôHódî
(
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

64 
	`as£π
 (
èg
 =
ARRAY_TAG
);

66  
a


67 + (
¨øyIndex
 * (
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
)))

68 + 
byãsN⁄Obj±rs


69 + (
obj±rIndex
 * 
OBJPTR_SIZE
);

70 
	}
}

	@array.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

25 
	#GC_ARRLEN_TYPE__
(
z
Ë
uöt
 ## z ## 
_t


	)

26 
	#GC_ARRLEN_TYPE_
(
z
Ë
	`GC_ARRLEN_TYPE__
(z)

	)

27 
	#GC_ARRLEN_TYPE
 
	`GC_ARRLEN_TYPE_
(
GC_MODEL_ARRLEN_SIZE
)

	)

28 
GC_ARRLEN_TYPE
 
	tGC_¨øyLígth
;

29 
	#GC_ARRAY_LENGTH_SIZE
 (
GC_¨øyLígth
)

	)

30 
	#PRIxARRLEN__
(
z
Ë
PRIx
 ## 
	)
z

31 
	#PRIxARRLEN_
(
z
Ë
	`PRIxARRLEN__
(z)

	)

32 
	#PRIxARRLEN
 
	`PRIxARRLEN_
(
GC_MODEL_ARRLEN_SIZE
)

	)

33 
	#FMTARRLEN
 "%"
PRIxARRLEN


	)

34 
GC_¨øyLígth
 
	tGC_¨øyCou¡î
;

35 
	#GC_ARRAY_COUNTER_SIZE
 (
GC_¨øyCou¡î
)

	)

36 
	#PRIxARRCTR
 
PRIxARRLEN


	)

37 
	#FMTARRCTR
 "%"
PRIxARRCTR


	)

38 
	#GC_ARRAY_HEADER_SIZE
 (
GC_ARRAY_COUNTER_SIZE
 + 
GC_ARRAY_LENGTH_SIZE
 + 
GC_HEADER_SIZE
)

	)

40 
COMPILE_TIME_ASSERT
(
sizeof_hódî__À__sizeof_¨æí
,

41 (
GC_hódî
Ë<(
GC_¨øyLígth
));

42 
COMPILE_TIME_ASSERT
(
sizeof_¨æí__eq__sizeof_¨r˘r
,

43 (
GC_¨øyLígth
Ë=(
GC_¨øyCou¡î
));

48 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

50 
ölöe
 
GC_¨øyLígth
* 
gëAºayLígthp
 (
poöãr
 
a
);

51 
ölöe
 
GC_¨øyLígth
 
gëAºayLígth
 (
poöãr
 
a
);

52 
ölöe
 
GC_¨øyCou¡î
* 
gëAºayCou¡îp
 (
poöãr
 
a
);

53 
ölöe
 
GC_¨øyCou¡î
 
gëAºayCou¡î
 (
poöãr
 
a
);

55 #i‡
ASSERT


56 
ölöe
 
poöãr
 
ödexAºayAtObj±rIndex
 (
GC_°©e
 
s
,Öoöã∏
a
,

57 
GC_¨øyCou¡î
 
¨øyIndex
,

58 
uöt32_t
 
obj±rIndex
);

63 
PRIVATE
 
uötmax_t
 
GC_gëAºayLígth
 (
poöãr
 
a
);

	@atomic.c

9 
	$begöAtomic
 (
GC_°©e
 
s
) {

10 
s
->
©omicSèã
++;

11 i‡(0 =
s
->
limô
)

12 
s
->
limô
 = s->
limôPlusSl›
 - 
GC_HEAP_LIMIT_SLOP
;

13 
	}
}

15 
	$ídAtomic
 (
GC_°©e
 
s
) {

16 
s
->
©omicSèã
--;

17 i‡(0 =
s
->
©omicSèã


18 
™d
 
s
->
sig«lsInfo
.
sig«lIsPídög
)

19 
s
->
limô
 = 0;

20 
	}
}

	@atomic.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
begöAtomic
 (
GC_°©e
 
s
);

12 
ölöe
 
ídAtomic
 (
GC_°©e
 
s
);

	@call-stack.c

9 
numSèckFømesAux
 (
GC_°©e
 
s
,

10 
__©åibuã__
 ((
unu£d
)Ë
GC_‰ameIndex
 
i
) {

11 
	gs
->
	gˇŒSèckSèã
.
	gnumSèckFømes
++;

14 
uöt32_t
 
	$GC_numSèckFømes
 (
GC_°©e
 
s
) {

15 
s
->
ˇŒSèckSèã
.
numSèckFømes
 = 0;

16 
	`f‹óchSèckFøme
 (
s
, 
numSèckFømesAux
);

17 i‡(
DEBUG_CALL_STACK
)

18 
	`Ârötf
 (
°dîr
, "%"
PRIu32
" = GC_numStackFrames\n",

19 
s
->
ˇŒSèckSèã
.
numSèckFømes
);

20  
s
->
ˇŒSèckSèã
.
numSèckFømes
;

21 
	}
}

23 
	$ˇŒSèckAux
 (
GC_°©e
 
s
, 
GC_‰ameIndex
 
i
) {

24 i‡(
DEBUG_CALL_STACK
)

25 
	`Ârötf
 (
°dîr
, "ˇŒSèckAux ("
FMTFI
")\n", 
i
);

26 
s
->
ˇŒSèckSèã
.
ˇŒSèck
[s->ˇŒSèckSèã.
numSèckFømes
] = 
i
;

27 
s
->
ˇŒSèckSèã
.
numSèckFømes
++;

28 
	}
}

30 
	$GC_ˇŒSèck
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

31 i‡(
DEBUG_CALL_STACK
)

32 
	`Ârötf
 (
°dîr
, "GC_callStack\n");

33 
s
->
ˇŒSèckSèã
.
numSèckFømes
 = 0;

34 
s
->
ˇŒSèckSèã
.
ˇŒSèck
 = (
uöt32_t
*)
p
;

35 
	`f‹óchSèckFøme
 (
s
, 
ˇŒSèckAux
);

36 
	}
}

38 
uöt32_t
* 
	$GC_‰ameIndexSour˚Seq
 (
GC_°©e
 
s
, 
GC_‰ameIndex
 
‰ameIndex
) {

39 
uöt32_t
 *
ªs
;

41 
ªs
 = 
s
->
sour˚M≠s
.
sour˚Seqs
[s->sour˚M≠s.
‰ameSour˚s
[
‰ameIndex
]];

42 i‡(
DEBUG_CALL_STACK
)

43 
	`Ârötf
 (
°dîr
, 
FMTPTR
" = GC_‰ameIndexSour˚Seq ("
FMTFI
")\n",

44 (
uöçå_t
)
ªs
, 
‰ameIndex
);

45  
ªs
;

46 
	}
}

	@call-stack.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

11 
	sGC_ˇŒSèckSèã
 {

12 
uöt32_t
 
	mnumSèckFømes
;

13 
uöt32_t
 *
	mˇŒSèck
;

18 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

20 
ölöe
 
numSèckFømesAux
 (
GC_°©e
 
s
, 
GC_‰ameIndex
 
i
);

21 
ölöe
 
ˇŒSèckAux
 (
GC_°©e
 
s
, 
GC_‰ameIndex
 
i
);

26 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

28 
PRIVATE
 
uöt32_t
 
GC_numSèckFømes
 (
GC_°©e
 
s
);

29 
PRIVATE
 
GC_ˇŒSèck
 (
GC_°©e
 
s
, 
poöãr
 
p
);

30 
PRIVATE
 
uöt32_t
* 
GC_‰ameIndexSour˚Seq
 (
GC_°©e
 
s
, 
GC_‰ameIndex
 
‰ameIndex
);

	@cheney-copy.c

14 
	$upd©eWóksF‹ChíeyC›y
 (
GC_°©e
 
s
) {

15 
poöãr
 
p
;

16 
GC_wók
 
w
;

18 
w
 = 
s
->
wóks
; w !
NULL
; w = w->
lök
) {

19 
	`as£π
 (
BOGUS_OBJPTR
 !
w
->
obj±r
);

21 i‡(
DEBUG_WEAK
)

22 
	`Ârötf
 (
°dîr
, "upd©eWóksF‹ChíeyC›y w = "
FMTPTR
" ", (
uöçå_t
)
w
);

23 
p
 = 
	`obj±rToPoöãr
 (
w
->
obj±r
, 
s
->
hóp
.
°¨t
);

24 i‡(
GC_FORWARDED
 =
	`gëHódî
 (
p
)) {

25 i‡(
DEBUG_WEAK
)

26 
	`Ârötf
 (
°dîr
, "f‹w¨ded from "
FMTOBJPTR
"Åo "FMTOBJPTR"\n",

27 
w
->
obj±r
,

28 *(
obj±r
*)
p
);

29 
w
->
obj±r
 = *(obj±r*)
p
;

31 i‡(
DEBUG_WEAK
)

32 
	`Ârötf
 (
°dîr
, "cleared\n");

33 *(
	`gëHódîp
((
poöãr
)
w
 - 
	`off£tofWók
 (
s
))Ë
GC_WEAK_GONE_HEADER
;

34 
w
->
obj±r
 = 
BOGUS_OBJPTR
;

37 
s
->
wóks
 = 
NULL
;

38 
	}
}

40 
	$sw≠HópsF‹ChíeyC›y
 (
GC_°©e
 
s
) {

41 
GC_hóp
 
ãmpHóp
;

43 
ãmpHóp
 = 
s
->
£c⁄d¨yHóp
;

44 
s
->
£c⁄d¨yHóp
 = s->
hóp
;

45 
s
->
hóp
 = 
ãmpHóp
;

46 
	`£tC¨dM≠AndCrossM≠
 (
s
);

47 
	}
}

49 
	$maj‹ChíeyC›yGC
 (
GC_°©e
 
s
) {

50 
size_t
 
byãsC›õd
;

51 
rußge
 
ru_°¨t
;

52 
poöãr
 
toSèπ
;

54 
	`as£π
 (
s
->
£c⁄d¨yHóp
.
size
 >s->
hóp
.
ﬁdGíSize
);

55 i‡(
	`dëaûedGCTime
 (
s
))

56 
	`°¨tTimög
 (&
ru_°¨t
);

57 
s
->
cumuœtiveSèti°ics
.
numC›yögGCs
++;

58 
s
->
f‹w¨dSèã
.
amInMö‹GC
 = 
FALSE
;

59 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

60 
	`Ârötf
 (
°dîr
,

62 
	`Ârötf
 (
°dîr
,

63 "[GC:\t‰om hó∞© "
FMTPTR
" of size %s bytes,]\n",

64 (
uöçå_t
)(
s
->
hóp
.
°¨t
),

65 
	`uötmaxToCommaSåög
(
s
->
hóp
.
size
));

66 
	`Ârötf
 (
°dîr
,

67 "[GC:\âÿhó∞© "
FMTPTR
" of size %s bytes.]\n",

68 (
uöçå_t
)(
s
->
£c⁄d¨yHóp
.
°¨t
),

69 
	`uötmaxToCommaSåög
(
s
->
£c⁄d¨yHóp
.
size
));

71 
s
->
f‹w¨dSèã
.
toSèπ
 = s->
£c⁄d¨yHóp
.
°¨t
;

72 
s
->
f‹w¨dSèã
.
toLimô
 = s->
£c⁄d¨yHóp
.
°¨t
 + s->£c⁄d¨yHóp.
size
;

73 
	`as£π
 (
s
->
£c⁄d¨yHóp
.
°¨t
 !(
poöãr
)
NULL
);

79 
	`as£π
 (
s
->
£c⁄d¨yHóp
.
size
 >s->
hóp
.
ﬁdGíSize
);

80 
toSèπ
 = 
	`ÆignFr⁄tõr
 (
s
, s->
£c⁄d¨yHóp
.
°¨t
);

81 
s
->
f‹w¨dSèã
.
back
 = 
toSèπ
;

82 
	`f‹óchGlobÆObj±r
 (
s
, 
f‹w¨dObj±r
);

83 
	`f‹óchObj±rInR™ge
 (
s
, 
toSèπ
, &s->
f‹w¨dSèã
.
back
, 
f‹w¨dObj±r
, 
TRUE
);

84 
	`upd©eWóksF‹ChíeyC›y
 (
s
);

85 
s
->
£c⁄d¨yHóp
.
ﬁdGíSize
 = (
size_t
)(s->
f‹w¨dSèã
.
back
 - s->£c⁄d¨yHóp.
°¨t
);

86 
byãsC›õd
 = 
s
->
£c⁄d¨yHóp
.
ﬁdGíSize
;

87 
s
->
cumuœtiveSèti°ics
.
byãsC›õd
 += bytesCopied;

88 
	`sw≠HópsF‹ChíeyC›y
 (
s
);

89 
s
->
œ°Maj‹Sèti°ics
.
köd
 = 
GC_COPYING
;

90 i‡(
	`dëaûedGCTime
 (
s
))

91 
	`°›Timög
 (&
ru_°¨t
, &
s
->
cumuœtiveSèti°ics
.
ru_gcC›yög
);

92 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

93 
	`Ârötf
 (
°dîr
,

95 
	`uötmaxToCommaSåög
(
byãsC›õd
));

96 
	}
}

102 
	$mö‹ChíeyC›yGC
 (
GC_°©e
 
s
) {

103 
size_t
 
byãsAŒoˇãd
;

104 
size_t
 
byãsC›õd
;

105 
rußge
 
ru_°¨t
;

107 i‡(
DEBUG_GENERATIONAL
)

108 
	`Ârötf
 (
°dîr
, "mö‹GCÇur£ry = "
FMTPTR
" frontier = "FMTPTR"\n",

109 (
uöçå_t
)
s
->
hóp
.
nur£ry
, (uöçå_t)s->
‰⁄tõr
);

110 
	`as£π
 (
	`öv¨ü¡F‹GC
 (
s
));

111 
byãsAŒoˇãd
 = (
size_t
)(
s
->
‰⁄tõr
 - s->
hóp
.
nur£ry
);

112 i‡(
byãsAŒoˇãd
 == 0)

114 
s
->
cumuœtiveSèti°ics
.
byãsAŒoˇãd
 += bytesAllocated;

115 i‡(
nŸ
 
s
->
ˇnMö‹
) {

116 
s
->
hóp
.
ﬁdGíSize
 +
byãsAŒoˇãd
;

118 i‡(
	`dëaûedGCTime
 (
s
))

119 
	`°¨tTimög
 (&
ru_°¨t
);

120 
s
->
cumuœtiveSèti°ics
.
numMö‹GCs
++;

121 
s
->
f‹w¨dSèã
.
amInMö‹GC
 = 
TRUE
;

122 i‡(
DEBUG_GENERATIONAL
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

123 
	`Ârötf
 (
°dîr
,

125 
	`Ârötf
 (
°dîr
,

126 "[GC:\t‰omÇur£ryáà"
FMTPTR
" of size %s bytes.]\n",

127 (
uöçå_t
)(
s
->
hóp
.
nur£ry
),

128 
	`uötmaxToCommaSåög
(
byãsAŒoˇãd
));

130 
s
->
f‹w¨dSèã
.
toSèπ
 = s->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
;

131 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, s->
f‹w¨dSèã
.
toSèπ
));

132 
s
->
f‹w¨dSèã
.
toLimô
 = s->f‹w¨dSèã.
toSèπ
 + 
byãsAŒoˇãd
;

133 
	`as£π
 (
	`öv¨ü¡F‹GC
 (
s
));

134 
s
->
f‹w¨dSèã
.
back
 = s->f‹w¨dSèã.
toSèπ
;

138 
	`f‹óchGlobÆObj±r
 (
s
, 
f‹w¨dObj±rIfInNur£ry
);

139 
	`f‹w¨dI¡îGíî©i⁄ÆObj±rs
 (
s
);

140 
	`f‹óchObj±rInR™ge
 (
s
, s->
f‹w¨dSèã
.
toSèπ
, &s->f‹w¨dSèã.
back
,

141 
f‹w¨dObj±rIfInNur£ry
, 
TRUE
);

142 
	`upd©eWóksF‹ChíeyC›y
 (
s
);

143 
byãsC›õd
 = (
size_t
)(
s
->
f‹w¨dSèã
.
back
 - s->f‹w¨dSèã.
toSèπ
);

144 
s
->
cumuœtiveSèti°ics
.
byãsC›õdMö‹
 +
byãsC›õd
;

145 
s
->
hóp
.
ﬁdGíSize
 +
byãsC›õd
;

146 
s
->
œ°Maj‹Sèti°ics
.
numMö‹GCs
++;

147 i‡(
	`dëaûedGCTime
 (
s
))

148 
	`°›Timög
 (&
ru_°¨t
, &
s
->
cumuœtiveSèti°ics
.
ru_gcMö‹
);

149 i‡(
DEBUG_GENERATIONAL
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

150 
	`Ârötf
 (
°dîr
,

152 
	`uötmaxToCommaSåög
(
byãsC›õd
));

154 
	}
}

	@cheney-copy.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
upd©eWóksF‹ChíeyC›y
 (
GC_°©e
 
s
);

12 
ölöe
 
sw≠HópsF‹ChíeyC›y
 (
GC_°©e
 
s
);

13 
maj‹ChíeyC›yGC
 (
GC_°©e
 
s
);

14 
mö‹ChíeyC›yGC
 (
GC_°©e
 
s
);

	@controls.c

9 
boﬁ
 
	$dëaûedGCTime
 (
GC_°©e
 
s
) {

10  
s
->
c⁄åﬁs
.
summ¨y
;

11 
	}
}

13 
boﬁ
 
	$√edGCTime
 (
GC_°©e
 
s
) {

15 
DEBUG


16 
‹
 
s
->
c⁄åﬁs
.
summ¨y


17 
‹
 
s
->
c⁄åﬁs
.
mesßges


18 
‹
 
s
->
c⁄åﬁs
.
rußgeMósuªGC
;

19 
	}
}

	@controls.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

11 
	sGC_øtios
 {

13 
	mc›y
;

17 
	mc›yGíî©i⁄Æ
;

18 
	mgrow
;

19 
	mhashC⁄s
;

21 
	mlive
;

23 
	mm¨kCom∑˘
;

28 
	mm¨kCom∑˘Gíî©i⁄Æ
;

32 
	mnur£ry
;

33 
	mømSl›
;

34 
	m°ackCuºítGrow
;

35 
	m°ackCuºítMaxRe£rved
;

36 
	m°ackCuºítPîmôRe£rved
;

37 
	m°ackCuºítShrök
;

38 
	m°ackMaxRe£rved
;

39 
	m°ackShrök
;

42 
	sGC_c⁄åﬁs
 {

43 
size_t
 
	mfixedHóp
;

44 
size_t
 
	mmaxHóp
;

45 
boﬁ
 
	mmayLﬂdW‹ld
;

46 
boﬁ
 
	mmayPageHóp
;

47 
boﬁ
 
	mmayPro˚ssAtMLt⁄
;

48 
boﬁ
 
	mmesßges
;

49 
size_t
 
	mﬁdGíAºaySize
;

50 
GC_øtios
 
	møtios
;

51 
boﬁ
 
	mrußgeMósuªGC
;

52 
boﬁ
 
	msumm¨y
;

57 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

59 
ölöe
 
boﬁ
 
dëaûedGCTime
 (
GC_°©e
 
s
);

60 
ölöe
 
boﬁ
 
√edGCTime
 (
GC_°©e
 
s
);

	@copy-thread.c

10 
GC_thªad
 
	$c›yThªad
 (
GC_°©e
 
s
, 
GC_thªad
 
‰om
, 
size_t
 
u£d
) {

11 
GC_thªad
 
to
;

13 i‡(
DEBUG_THREADS
)

14 
	`Ârötf
 (
°dîr
, "c›yThªad ("
FMTPTR
")\n", (
uöçå_t
)
‰om
);

18 
	`as£π
 (
s
->
ßvedThªad
 =
BOGUS_OBJPTR
);

19 
s
->
ßvedThªad
 = 
	`poöãrToObj±r
((
poöãr
)
‰om
 - 
	`off£tofThªad
 (s), s->
hóp
.
°¨t
);

20 
to
 = 
	`√wThªad
 (
s
, 
	`ÆignSèckRe£rved
(s, 
u£d
));

21 
‰om
 = (
GC_thªad
)(
	`obj±rToPoöãr
(
s
->
ßvedThªad
, s->
hóp
.
°¨t
Ë+ 
	`off£tofThªad
 (s));

22 
s
->
ßvedThªad
 = 
BOGUS_OBJPTR
;

23 i‡(
DEBUG_THREADS
) {

24 
	`Ârötf
 (
°dîr
, 
FMTPTR
" = copyThread ("FMTPTR")\n",

25 (
uöçå_t
)
to
, (uöçå_t)
‰om
);

27 
	`c›ySèck
 (
s
,

28 (
GC_°ack
)(
	`obj±rToPoöãr
(
‰om
->
°ack
, 
s
->
hóp
.
°¨t
)),

29 (
GC_°ack
)(
	`obj±rToPoöãr
(
to
->
°ack
, 
s
->
hóp
.
°¨t
)));

30 
to
->
byãsNìded
 = 
‰om
->bytesNeeded;

31 
to
->
exnSèck
 = 
‰om
->exnStack;

32  
to
;

33 
	}
}

35 
	$GC_c›yCuºítThªad
 (
GC_°©e
 
s
) {

36 
GC_thªad
 
‰omThªad
;

37 
GC_°ack
 
‰omSèck
;

38 
GC_thªad
 
toThªad
;

39 
LOCAL_USED_FOR_ASSERT
 
GC_°ack
 
toSèck
;

41 i‡(
DEBUG_THREADS
)

42 
	`Ârötf
 (
°dîr
, "GC_copyCurrentThread\n");

43 
	`íãr
 (
s
);

44 
‰omThªad
 = (
GC_thªad
)(
	`obj±rToPoöãr
(
s
->
cuºítThªad
, s->
hóp
.
°¨t
)

45 + 
	`off£tofThªad
 (
s
));

46 
‰omSèck
 = (
GC_°ack
)(
	`obj±rToPoöãr
(
‰omThªad
->
°ack
, 
s
->
hóp
.
°¨t
));

47 
toThªad
 = 
	`c›yThªad
 (
s
, 
‰omThªad
, 
‰omSèck
->
u£d
);

48 
toSèck
 = (
GC_°ack
)(
	`obj±rToPoöãr
(
toThªad
->
°ack
, 
s
->
hóp
.
°¨t
));

49 
	`as£π
 (
toSèck
->
ª£rved
 =
	`ÆignSèckRe£rved
 (
s
,ÅoSèck->
u£d
));

50 
	`Àave
 (
s
);

51 i‡(
DEBUG_THREADS
)

52 
	`Ârötf
 (
°dîr
, 
FMTPTR
" = GC_c›yCuºítThªad\n", (
uöçå_t
)
toThªad
);

53 
	`as£π
 (
s
->
ßvedThªad
 =
BOGUS_OBJPTR
);

54 
s
->
ßvedThªad
 = 
	`poöãrToObj±r
((
poöãr
)
toThªad
 - 
	`off£tofThªad
 (s), s->
hóp
.
°¨t
);

55 
	}
}

57 
poöãr
 
	$GC_c›yThªad
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

58 
GC_thªad
 
‰omThªad
;

59 
GC_°ack
 
‰omSèck
;

60 
GC_thªad
 
toThªad
;

61 
LOCAL_USED_FOR_ASSERT
 
GC_°ack
 
toSèck
;

63 i‡(
DEBUG_THREADS
)

64 
	`Ârötf
 (
°dîr
, "GC_c›yThªad ("
FMTPTR
")\n", (
uöçå_t
)
p
);

65 
	`íãr
 (
s
);

66 
‰omThªad
 = (
GC_thªad
)(
p
 + 
	`off£tofThªad
 (
s
));

67 
‰omSèck
 = (
GC_°ack
)(
	`obj±rToPoöãr
(
‰omThªad
->
°ack
, 
s
->
hóp
.
°¨t
));

68 
toThªad
 = 
	`c›yThªad
 (
s
, 
‰omThªad
, 
‰omSèck
->
u£d
);

69 
toSèck
 = (
GC_°ack
)(
	`obj±rToPoöãr
(
toThªad
->
°ack
, 
s
->
hóp
.
°¨t
));

70 
	`as£π
 (
toSèck
->
ª£rved
 =
	`ÆignSèckRe£rved
 (
s
,ÅoSèck->
u£d
));

71 
	`Àave
 (
s
);

72 i‡(
DEBUG_THREADS
)

73 
	`Ârötf
 (
°dîr
, 
FMTPTR
" = GC_copyThread ("FMTPTR")\n",

74 (
uöçå_t
)
toThªad
, (uöçå_t)
‰omThªad
);

75  ((
poöãr
)
toThªad
 - 
	`off£tofThªad
 (
s
));

76 
	}
}

	@copy-thread.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
GC_thªad
 
c›yThªad
 (
GC_°©e
 
s
, GC_thªad 
‰om
, 
size_t
 
size
);

15 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

17 
PRIVATE
 
GC_c›yCuºítThªad
 (
GC_°©e
 
s
);

18 
PRIVATE
 
poöãr
 
GC_c›yThªad
 (
GC_°©e
 
s
,Öoöã∏
p
);

	@current.c

9 
obj±r
 
	$gëThªadCuºítObj±r
 (
GC_°©e
 
s
) {

10  
s
->
cuºítThªad
;

11 
	}
}

13 
GC_thªad
 
	$gëThªadCuºít
 (
GC_°©e
 
s
) {

14 
poöãr
 
p
 = 
	`obj±rToPoöãr
(
	`gëThªadCuºítObj±r
(
s
), s->
hóp
.
°¨t
);

15  (
GC_thªad
)(
p
 + 
	`off£tofThªad
 (
s
));

16 
	}
}

18 
obj±r
 
	$gëSèckCuºítObj±r
 (
GC_°©e
 
s
) {

19 
GC_thªad
 
thªad
 = 
	`gëThªadCuºít
(
s
);

20  
thªad
->
°ack
;

21 
	}
}

23 
GC_°ack
 
	$gëSèckCuºít
 (
GC_°©e
 
s
) {

24 
poöãr
 
p
 = 
	`obj±rToPoöãr
(
	`gëSèckCuºítObj±r
(
s
), s->
hóp
.
°¨t
);

25  (
GC_°ack
)
p
;

26 
	}
}

	@current.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
obj±r
 
gëThªadCuºítObj±r
 (
GC_°©e
 
s
);

12 
ölöe
 
GC_thªad
 
gëThªadCuºít
 (
GC_°©e
 
s
);

13 
ölöe
 
obj±r
 
gëSèckCuºítObj±r
 (
GC_°©e
 
s
);

14 
ölöe
 
GC_°ack
 
gëSèckCuºít
 (
GC_°©e
 
s
);

	@debug.h

9 #i‚de‡
DEBUG


10 
	#DEBUG
 
FALSE


	)

16 
	mDEBUG_ARRAY
 = 
FALSE
,

17 
	mDEBUG_CALL_STACK
 = 
FALSE
,

18 
	mDEBUG_CARD_MARKING
 = 
FALSE
,

19 
	mDEBUG_DETAILED
 = 
FALSE
,

20 
	mDEBUG_DFS_MARK
 = 
FALSE
,

21 
	mDEBUG_ENTER_LEAVE
 = 
FALSE
,

22 
	mDEBUG_GENERATIONAL
 = 
FALSE
,

23 
	mDEBUG_INT_INF
 = 
FALSE
,

24 
	mDEBUG_INT_INF_DETAILED
 = 
FALSE
,

25 
	mDEBUG_MARK_COMPACT
 = 
FALSE
,

26 
	mDEBUG_MEM
 = 
FALSE
,

27 
	mDEBUG_OBJPTR
 = 
FALSE
,

28 
	mDEBUG_PROFILE
 = 
FALSE
,

29 
	mDEBUG_RESIZING
 = 
FALSE
,

30 
	mDEBUG_SHARE
 = 
FALSE
,

31 
	mDEBUG_SIGNALS
 = 
FALSE
,

32 
	mDEBUG_SIZE
 = 
FALSE
,

33 
	mDEBUG_SOURCES
 = 
FALSE
,

34 
	mDEBUG_STACKS
 = 
FALSE
,

35 
	mDEBUG_THREADS
 = 
FALSE
,

36 
	mDEBUG_WEAK
 = 
FALSE
,

37 
	mDEBUG_WORLD
 = 
FALSE
,

38 
	mFORCE_GENERATIONAL
 = 
FALSE
,

39 
	mFORCE_MARK_COMPACT
 = 
TRUE
,

	@dfs-mark.c

14 
boﬁ
 
	$isPoöãrM¨ked
 (
poöãr
 
p
) {

15  
MARK_MASK
 & 
	`gëHódî
 (
p
);

16 
	}
}

18 
boﬁ
 
	$isPoöãrM¨kedByMode
 (
poöãr
 
p
, 
GC_m¨kMode
 
m
) {

19 
m
) {

20 
MARK_MODE
:

21  
	`isPoöãrM¨ked
 (
p
);

22 
UNMARK_MODE
:

23  
nŸ
 
	`isPoöãrM¨ked
 (
p
);

25 
	`dõ
 ("bad m¨k modê%u", 
m
);

27 
	}
}

42 
size_t
 
	$dfsM¨kByMode
 (
GC_°©e
 
s
, 
poöãr
 
roŸ
,

43 
GC_m¨kMode
 
mode
,

44 
boﬁ
 
shouldHashC⁄s
,

45 
boﬁ
 
shouldLökWóks
) {

46 
GC_hódî
 
m¨k
;

47 
size_t
 
size
;

48 
poöãr
 
cur
;

49 
poöãr
 
¥ev
;

50 
poöãr
 
√xt
;

51 
poöãr
 
todo
;

52 
GC_hódî
 
hódî
;

53 
GC_hódî
* 
hódîp
;

54 
uöt16_t
 
byãsN⁄Obj±rs
;

55 
uöt16_t
 
numObj±rs
;

56 
GC_obje˘Ty≥Tag
 
èg
;

57 
uöt32_t
 
obj±rIndex
;

58 
GC_hódî
 
√xtHódî
;

59 
GC_hódî
* 
√xtHódîp
;

60 
GC_¨øyCou¡î
 
¨øyIndex
;

61 
poöãr
 
t›
;

62 
GC_ªtu∫Addªss
 
ªtu∫Addªss
;

63 
GC_‰ameLayout
 
‰ameLayout
;

64 
GC_‰ameOff£ts
 
‰ameOff£ts
;

66 i‡(
	`isPoöãrM¨kedByMode
 (
roŸ
, 
mode
))

69 
m¨k
 = (
MARK_MODE
 =
mode
Ë? 
MARK_MASK
 : 0;

70 
size
 = 0;

71 
cur
 = 
roŸ
;

72 
¥ev
 = 
NULL
;

73 
hódîp
 = 
	`gëHódîp
 (
cur
);

74 
hódî
 = *
hódîp
;

75 
m¨k
;

76 
m¨kNext
:

84 i‡(
DEBUG_DFS_MARK
)

85 
	`Ârötf
 (
°dîr
,

87 " cu∏"
FMTPTR
"Çext = "FMTPTR

88 "Öªv = "
FMTPTR
"Åodo = "FMTPTR"\n",

89 (
uöçå_t
)
cur
, (uöçå_t)
√xt
,

90 (
uöçå_t
)
¥ev
, (uöçå_t)
todo
);

91 
	`as£π
 (
nŸ
 
	`isPoöãrM¨kedByMode
 (
√xt
, 
mode
));

92 
	`as£π
 (
√xtHódîp
 =
	`gëHódîp
 (
√xt
));

93 
	`as£π
 (
√xtHódî
 =
	`gëHódî
 (
√xt
));

95 
	`as£π
 (
	`„tchObj±rToPoöãr
 (
todo
, 
s
->
hóp
.
°¨t
Ë=
√xt
);

96 
hódîp
 = 
√xtHódîp
;

97 
hódî
 = 
√xtHódî
;

99 
	`°‹eObj±rFromPoöãr
 (
todo
, 
¥ev
, 
s
->
hóp
.
°¨t
);

100 
¥ev
 = 
cur
;

101 
cur
 = 
√xt
;

102 
m¨k
:

103 i‡(
DEBUG_DFS_MARK
)

104 
	`Ârötf
 (
°dîr
, "m¨k cu∏"
FMTPTR
"Örev = "FMTPTR" mode = %s\n",

105 (
uöçå_t
)
cur
, (uöçå_t)
¥ev
,

106 (
mode
 =
MARK_MODE
) ? "mark" : "unmark");

112 
	`as£π
 (
nŸ
 
	`isPoöãrM¨kedByMode
 (
cur
, 
mode
));

113 
	`as£π
 (
hódî
 =
	`gëHódî
 (
cur
));

114 
	`as£π
 (
hódîp
 =
	`gëHódîp
 (
cur
));

115 
hódî
 ^
MARK_MASK
;

121 *
hódîp
 = 
hódî
;

122 
	`•lôHódî
 (
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

123 i‡(
NORMAL_TAG
 =
èg
) {

124 
size
 +=

125 
GC_NORMAL_HEADER_SIZE


126 + 
byãsN⁄Obj±rs


127 + (
numObj±rs
 * 
OBJPTR_SIZE
);

129 i‡(
cur
 >(
s
->
umhóp
.
°¨t
) &&

130 
cur
 < (
s
->
umhóp
.
°¨t
 + s->umhóp.
size
)) {

131 
GC_UM_Chunk
 
pchunk
 = (GC_UM_Chunk)(
cur
 - 
GC_NORMAL_HEADER_SIZE
);

132 
pchunk
->
chunk_hódî
 |
UM_CHUNK_HEADER_MASK
;

133 i‡(
DEBUG_MEM
) {

134 
	`Ârötf
(
°dîr
, "dfs-m¨k: chunk: "
FMTPTR
", sentinel: %d\n",

135 (
uöçå_t
)
pchunk
,

136 
pchunk
->
£¡öñ
);

139 i‡(
NULL
 !
pchunk
->
√xt_chunk
) {

140 
pchunk
->
√xt_chunk
->
chunk_hódî
 |
UM_CHUNK_HEADER_MASK
;

144 i‡(0 =
numObj±rs
) {

146 
n‹mÆD⁄e
:

147 i‡(
shouldHashC⁄s
)

148 
cur
 = 
	`hashC⁄sPoöãr
 (
s
, cur, 
TRUE
);

149 
ªt
;

154 
obj±rIndex
 = 0;

156 
todo
 = 
	`UM_CPoöãr_off£t
(
s
, 
cur
,

157 
byãsN⁄Obj±rs
 + 
obj±rIndex
 * 
OBJPTR_SIZE
,

158 
OBJPTR_SIZE
);

159 
m¨kInN‹mÆ
:

160 i‡(
DEBUG_DFS_MARK
)

161 
	`Ârötf
 (
°dîr
, "m¨kInN‹mÆ obj±rIndex = %"
PRIu32
"\n", 
obj±rIndex
);

162 
	`as£π
 (
obj±rIndex
 < 
numObj±rs
);

164 
√xt
 = 
	`„tchObj±rToPoöãr
 (
todo
, 
s
->
hóp
.
°¨t
);

165 i‡(
nŸ
 
	`isPoöãr
 (
√xt
)) {

166 
m¨kNextInN‹mÆ
:

167 
	`as£π
 (
obj±rIndex
 < 
numObj±rs
);

168 
obj±rIndex
++;

169 i‡(
obj±rIndex
 =
numObj±rs
) {

171 *
hódîp
 = 
hódî
 & ~
COUNTER_MASK
;

172 
n‹mÆD⁄e
;

176 
todo
 = 
	`UM_CPoöãr_off£t
(
s
, 
cur
,

177 
byãsN⁄Obj±rs
 + 
obj±rIndex
 * 
OBJPTR_SIZE
,

178 
OBJPTR_SIZE
);

180 
m¨kInN‹mÆ
;

182 
√xtHódîp
 = 
	`gëHódîp
 (
√xt
);

183 
√xtHódî
 = *
√xtHódîp
;

184 i‡(
m¨k
 =(
√xtHódî
 & 
MARK_MASK
)) {

185 i‡(
shouldHashC⁄s
)

186 
	`sh¨eObj±r
 (
s
, (
obj±r
*)
todo
);

187 
m¨kNextInN‹mÆ
;

189 *
hódîp
 = (
hódî
 & ~
COUNTER_MASK
Ë| (
obj±rIndex
 << 
COUNTER_SHIFT
);

190 
m¨kNext
;

191 } i‡(
WEAK_TAG
 =
èg
) {

193 i‡(
shouldLökWóks
) {

194 
GC_wók
 
w
;

196 
w
 = (
GC_wók
)(
cur
 + 
	`off£tofWók
 (
s
));

197 i‡(
DEBUG_WEAK
)

198 
	`Ârötf
 (
°dîr
, "m¨kög wók "
FMTPTR
" ",

199 (
uöçå_t
)
w
);

200 i‡(
	`isObj±r
 (
w
->
obj±r
)) {

201 i‡(
DEBUG_WEAK
)

202 
	`Ârötf
 (
°dîr
, "linking\n");

203 
w
->
lök
 = 
s
->
wóks
;

204 
s
->
wóks
 = 
w
;

206 i‡(
DEBUG_WEAK
)

207 
	`Ârötf
 (
°dîr
, "notÜinking\n");

210 
ªt
;

211 } i‡(
ARRAY_TAG
 =
èg
) {

219 
size
 +=

220 
GC_ARRAY_HEADER_SIZE


221 + 
	`sizeofAºayNoHódî
 (
s
, 
	`gëAºayLígth
 (
cur
), 
byãsN⁄Obj±rs
, 
numObj±rs
);

222 i‡(0 =
numObj±rs
 
‹
 0 =
	`gëAºayLígth
 (
cur
)) {

224 
¨øyD⁄e
:

225 i‡(
shouldHashC⁄s
)

226 
cur
 = 
	`hashC⁄sPoöãr
 (
s
, cur, 
TRUE
);

227 
ªt
;

230 
¨øyIndex
 = 0;

231 
todo
 = 
cur
;

232 
m¨kAºayE…
:

233 
	`as£π
 (
¨øyIndex
 < 
	`gëAºayLígth
 (
cur
));

234 
obj±rIndex
 = 0;

236 
todo
 +
byãsN⁄Obj±rs
;

237 
m¨kInAºay
:

238 i‡(
DEBUG_DFS_MARK
)

239 
	`Ârötf
 (
°dîr
, "m¨kInAºayáºayIndex = %"
PRIxARRCTR
" obj±rIndex = %"
PRIu32
"\n",

240 
¨øyIndex
, 
obj±rIndex
);

241 
	`as£π
 (
¨øyIndex
 < 
	`gëAºayLígth
 (
cur
));

242 
	`as£π
 (
obj±rIndex
 < 
numObj±rs
);

243 
	`as£π
 (
todo
 =
	`ödexAºayAtObj±rIndex
 (
s
, 
cur
, 
¨øyIndex
, 
obj±rIndex
));

245 
√xt
 = 
	`„tchObj±rToPoöãr
 (
todo
, 
s
->
hóp
.
°¨t
);

246 i‡(
	`nŸ
 (
	`isPoöãr
(
√xt
))) {

247 
m¨kNextInAºay
:

248 
	`as£π
 (
¨øyIndex
 < 
	`gëAºayLígth
 (
cur
));

249 
	`as£π
 (
obj±rIndex
 < 
numObj±rs
);

250 
	`as£π
 (
todo
 =
	`ödexAºayAtObj±rIndex
 (
s
, 
cur
, 
¨øyIndex
, 
obj±rIndex
));

251 
todo
 +
OBJPTR_SIZE
;

252 
obj±rIndex
++;

253 i‡(
obj±rIndex
 < 
numObj±rs
)

254 
m¨kInAºay
;

255 
¨øyIndex
++;

256 i‡(
¨øyIndex
 < 
	`gëAºayLígth
 (
cur
))

257 
m¨kAºayE…
;

259 *
	`gëAºayCou¡îp
 (
cur
) = 0;

260 *
hódîp
 = 
hódî
 & ~
COUNTER_MASK
;

261 
¨øyD⁄e
;

263 
√xtHódîp
 = 
	`gëHódîp
 (
√xt
);

264 
√xtHódî
 = *
√xtHódîp
;

265 i‡(
m¨k
 =(
√xtHódî
 & 
MARK_MASK
)) {

266 i‡(
shouldHashC⁄s
)

267 
	`sh¨eObj±r
 (
s
, (
obj±r
*)
todo
);

268 
m¨kNextInAºay
;

271 *
	`gëAºayCou¡îp
 (
cur
Ë
¨øyIndex
;

272 *
hódîp
 = (
hódî
 & ~
COUNTER_MASK
Ë| (
obj±rIndex
 << 
COUNTER_SHIFT
);

273 
m¨kNext
;

275 
	`as£π
 (
STACK_TAG
 =
èg
);

276 
size
 +=

277 
GC_STACK_HEADER_SIZE


278 +  (
GC_°ack
Ë+ ((GC_°ack)
cur
)->
ª£rved
;

279 
t›
 = 
	`gëSèckT›
 (
s
, (
GC_°ack
)
cur
);

280 
	`as£π
 (((
GC_°ack
)
cur
)->
u£d
 <((GC_°ack)cur)->
ª£rved
);

281 
m¨kInSèck
:

285 
	`as£π
 (
	`gëSèckBŸtom
 (
s
, (
GC_°ack
)
cur
Ë<
t›
);

286 i‡(
DEBUG_DFS_MARK
)

287 
	`Ârötf
 (
°dîr
, "m¨kInSèckÅ› = %"
PRIuMAX
"\n",

288 (
uötmax_t
)(
t›
 - 
	`gëSèckBŸtom
 (
s
, (
GC_°ack
)
cur
)));

289 i‡(
t›
 =
	`gëSèckBŸtom
 (
s
, (
GC_°ack
)(
cur
)))

290 
ªt
;

291 
obj±rIndex
 = 0;

292 
ªtu∫Addªss
 = *(
GC_ªtu∫Addªss
*Ë(
t›
 - 
GC_RETURNADDRESS_SIZE
);

293 
‰ameLayout
 = 
	`gëFømeLayoutFromRëu∫Addªss
 (
s
, 
ªtu∫Addªss
);

294 
‰ameOff£ts
 = 
‰ameLayout
->
off£ts
;

295 ((
GC_°ack
)
cur
)->
m¨kT›
 = 
t›
;

296 
m¨kInFøme
:

297 i‡(
obj±rIndex
 =
‰ameOff£ts
 [0]) {

298 
t›
 -
‰ameLayout
->
size
;

299 
m¨kInSèck
;

301 
todo
 = 
t›
 - 
‰ameLayout
->
size
 + 
‰ameOff£ts
 [
obj±rIndex
 + 1];

303 
√xt
 = 
	`„tchObj±rToPoöãr
 (
todo
, 
s
->
hóp
.
°¨t
);

304 i‡(
DEBUG_DFS_MARK
)

305 
	`Ârötf
 (
°dîr
,

306 " off£à%uÅodÿ"
FMTPTR
"Çext = "FMTPTR"\n",

307 
‰ameOff£ts
 [
obj±rIndex
 + 1],

308 (
uöçå_t
)
todo
, (uöçå_t)
√xt
);

309 i‡(
nŸ
 
	`isPoöãr
 (
√xt
)) {

310 
obj±rIndex
++;

311 
m¨kInFøme
;

313 
√xtHódîp
 = 
	`gëHódîp
 (
√xt
);

314 
√xtHódî
 = *
√xtHódîp
;

315 i‡(
m¨k
 =(
√xtHódî
 & 
MARK_MASK
)) {

316 
obj±rIndex
++;

317 i‡(
shouldHashC⁄s
)

318 
	`sh¨eObj±r
 (
s
, (
obj±r
*)
todo
);

319 
m¨kInFøme
;

321 ((
GC_°ack
)
cur
)->
m¨kIndex
 = 
obj±rIndex
;

322 
m¨kNext
;

324 
	`as£π
 (
FALSE
);

325 
ªt
:

330 i‡(
DEBUG_DFS_MARK
)

331 
	`Ârötf
 (
°dîr
, "ªtu∫ cu∏"
FMTPTR
"Örev = "FMTPTR"\n",

332 (
uöçå_t
)
cur
, (uöçå_t)
¥ev
);

333 
	`as£π
 (
	`isPoöãrM¨kedByMode
 (
cur
, 
mode
));

334 i‡(
NULL
 =
¥ev
)

335  
size
;

336 
√xt
 = 
cur
;

337 
cur
 = 
¥ev
;

338 
hódîp
 = 
	`gëHódîp
 (
cur
);

339 
hódî
 = *
hódîp
;

340 
	`•lôHódî
 (
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

344 
	`as£π
 (
WEAK_TAG
 !
èg
);

345 i‡(
NORMAL_TAG
 =
èg
) {

346 
todo
 = 
cur
 + 
byãsN⁄Obj±rs
;

347 
obj±rIndex
 = (
hódî
 & 
COUNTER_MASK
Ë>> 
COUNTER_SHIFT
;

348 
todo
 +
obj±rIndex
 * 
OBJPTR_SIZE
;

350 
¥ev
 = 
	`„tchObj±rToPoöãr
 (
todo
, 
s
->
hóp
.
°¨t
);

352 
	`°‹eObj±rFromPoöãr
 (
todo
, 
√xt
, 
s
->
hóp
.
°¨t
);

353 i‡(
shouldHashC⁄s
)

354 
	`m¨kI¡îgíî©i⁄ÆPoöãr
 (
s
, (
poöãr
*)
todo
);

355 
m¨kNextInN‹mÆ
;

356 } i‡(
ARRAY_TAG
 =
èg
) {

357 
¨øyIndex
 = 
	`gëAºayCou¡î
 (
cur
);

358 
todo
 = 
cur
 + 
¨øyIndex
 * (
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
));

359 
obj±rIndex
 = (
hódî
 & 
COUNTER_MASK
Ë>> 
COUNTER_SHIFT
;

360 
todo
 +
byãsN⁄Obj±rs
 + 
obj±rIndex
 * 
OBJPTR_SIZE
;

362 
¥ev
 = 
	`„tchObj±rToPoöãr
 (
todo
, 
s
->
hóp
.
°¨t
);

364 
	`°‹eObj±rFromPoöãr
 (
todo
, 
√xt
, 
s
->
hóp
.
°¨t
);

365 i‡(
shouldHashC⁄s
)

366 
	`m¨kI¡îgíî©i⁄ÆPoöãr
 (
s
, (
poöãr
*)
todo
);

367 
m¨kNextInAºay
;

369 
	`as£π
 (
STACK_TAG
 =
èg
);

370 
obj±rIndex
 = ((
GC_°ack
)
cur
)->
m¨kIndex
;

371 
t›
 = ((
GC_°ack
)
cur
)->
m¨kT›
;

373 
ªtu∫Addªss
 = *(
GC_ªtu∫Addªss
*Ë(
t›
 - 
GC_RETURNADDRESS_SIZE
);

374 
‰ameLayout
 = 
	`gëFømeLayoutFromRëu∫Addªss
 (
s
, 
ªtu∫Addªss
);

375 
‰ameOff£ts
 = 
‰ameLayout
->
off£ts
;

376 
todo
 = 
t›
 - 
‰ameLayout
->
size
 + 
‰ameOff£ts
 [
obj±rIndex
 + 1];

378 
¥ev
 = 
	`„tchObj±rToPoöãr
 (
todo
, 
s
->
hóp
.
°¨t
);

380 
	`°‹eObj±rFromPoöãr
 (
todo
, 
√xt
, 
s
->
hóp
.
°¨t
);

381 i‡(
shouldHashC⁄s
)

382 
	`m¨kI¡îgíî©i⁄ÆPoöãr
 (
s
, (
poöãr
*)
todo
);

383 
obj±rIndex
++;

384 
m¨kInFøme
;

386 
	`as£π
 (
FALSE
);

387 
	}
}

389 
	$dfsM¨kWôhHashC⁄sWôhLökWóks
 (
GC_°©e
 
s
, 
obj±r
 *
›p
) {

390 
poöãr
 
p
;

392 
p
 = 
	`obj±rToPoöãr
 (*
›p
, 
s
->
hóp
.
°¨t
);

393 
	`dfsM¨kByMode
 (
s
, 
p
, 
MARK_MODE
, 
TRUE
, TRUE);

394 
	}
}

396 
	$dfsM¨kWôhoutHashC⁄sWôhLökWóks
 (
GC_°©e
 
s
, 
obj±r
 *
›p
) {

397 
poöãr
 
p
;

398 
p
 = 
	`obj±rToPoöãr
 (*
›p
, 
s
->
hóp
.
°¨t
);

399 
	`dfsM¨kByMode
 (
s
, 
p
, 
MARK_MODE
, 
FALSE
, 
TRUE
);

400 
	}
}

	@dfs-mark.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

13 
	mMARK_MODE
,

14 
	mUNMARK_MODE
,

15 } 
	tGC_m¨kMode
;

19 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

21 
ölöe
 
boﬁ
 
isPoöãrM¨ked
 (
poöãr
 
p
);

22 
ölöe
 
boﬁ
 
isPoöãrM¨kedByMode
 (
poöãr
 
p
, 
GC_m¨kMode
 
m
);

23 
size_t
 
dfsM¨kByMode
 (
GC_°©e
 
s
, 
poöãr
 
roŸ
,

24 
GC_m¨kMode
 
mode
,

25 
boﬁ
 
shouldHashC⁄s
,

26 
boﬁ
 
shouldLökWóks
);

27 
ölöe
 
dfsM¨kWôhHashC⁄sWôhLökWóks
 (
GC_°©e
 
s
, 
obj±r
 *
›p
);

28 
ölöe
 
dfsM¨kWôhoutHashC⁄sWôhLökWóks
 (
GC_°©e
 
s
, 
obj±r
 *
›p
);

	@done.c

10 
	$di•œyCﬁ
 (
FILE
 *
out
, 
size_t
 
width
, c⁄° *
s
) {

11 
size_t
 
exåa
;

12 
size_t
 
i
;

13 
size_t
 
Àn
;

15 
Àn
 = 
	`°æí
 (
s
);

16 i‡(
Àn
 < 
width
) {

17 
exåa
 = 
width
 - 
Àn
;

18 
i
 = 0; i < 
exåa
; i++)

19 
	`Ârötf
 (
out
, " ");

21 
	`Ârötf
 (
out
, "%s\t", 
s
);

22 
	}
}

24 
	$di•œyCﬁÀ˘i⁄Sèts
 (
FILE
 *
out
, c⁄° *
«me
, 
rußge
 *
ru
,

25 
uötmax_t
 
num
, uötmax_à
byãs
) {

26 
uötmax_t
 
ms
;

28 
ms
 = 
	`rußgeTime
 (
ru
);

29 
	`Ârötf
 (
out
, "%s", 
«me
);

30 
	`di•œyCﬁ
 (
out
, 7, 
	`uötmaxToCommaSåög
 (
ms
));

31 
	`di•œyCﬁ
 (
out
, 7, 
	`uötmaxToCommaSåög
 (
num
));

32 
	`di•œyCﬁ
 (
out
, 15, 
	`uötmaxToCommaSåög
 (
byãs
));

33 
	`di•œyCﬁ
 (
out
, 15,

34 (
ms
 > 0)

35 ? 
	`uötmaxToCommaSåög
 ((
uötmax_t
)(1000.0 * ()
byãs
/()
ms
))

37 
	`Ârötf
 (
out
, "\n");

38 
	}
}

40 
	$GC_d⁄e
 (
GC_°©e
 
s
) {

41 i‡(
s
->
gc_moduÀ
 =
GC_NONE
 ||

42 
s
->
gc_moduÀ
 =
GC_UM
) {

45 
FILE
 *
out
;

47 
	`íãr
 (
s
);

48 
	`mö‹GC
 (
s
);

49 
out
 = 
°dîr
;

50 i‡(
s
->
c⁄åﬁs
.
summ¨y
) {

51 
rußge
 
ru_tŸÆ
;

52 
uötmax_t
 
gcTime
;

53 
uötmax_t
 
tŸÆTime
;

55 
	`gërußge
 (
RUSAGE_SELF
, &
ru_tŸÆ
);

56 
tŸÆTime
 = 
	`rußgeTime
 (&
ru_tŸÆ
);

57 
gcTime
 = 
	`rußgeTime
 (&
s
->
cumuœtiveSèti°ics
.
ru_gc
);

58 
	`Ârötf
 (
out
, "GCÅype\t\ttime ms\tÇumber\t\t bytes\t bytes/sec\n");

59 
	`Ârötf
 (
out
, "-------------\t-------\t-------\t---------------\t---------------\n");

60 
di•œyCﬁÀ˘i⁄Sèts


61 (
out
, "copying\t\t",

62 &
s
->
cumuœtiveSèti°ics
.
ru_gcC›yög
,

63 
s
->
cumuœtiveSèti°ics
.
numC›yögGCs
,

64 
s
->
cumuœtiveSèti°ics
.
byãsC›õd
);

65 
di•œyCﬁÀ˘i⁄Sèts


66 (
out
, "mark-compact\t",

67 &
s
->
cumuœtiveSèti°ics
.
ru_gcM¨kCom∑˘
,

68 
s
->
cumuœtiveSèti°ics
.
numM¨kCom∑˘GCs
,

69 
s
->
cumuœtiveSèti°ics
.
byãsM¨kCom∑˘ed
);

70 
di•œyCﬁÀ˘i⁄Sèts


71 (
out
, "minor\t\t",

72 &
s
->
cumuœtiveSèti°ics
.
ru_gcMö‹
,

73 
s
->
cumuœtiveSèti°ics
.
numMö‹GCs
,

74 
s
->
cumuœtiveSèti°ics
.
byãsC›õdMö‹
);

75 
	`Ârötf
 (
out
, "totalÅime: %s ms\n",

76 
	`uötmaxToCommaSåög
 (
tŸÆTime
));

77 
	`Ârötf
 (
out
, "total GCÅime: %s ms (%.1f%%)\n",

78 
	`uötmaxToCommaSåög
 (
gcTime
),

79 (0 =
tŸÆTime
)

81 : 100.0 * ((Ë
gcTime
Ë/ ()
tŸÆTime
);

82 
	`Ârötf
 (
out
, "maxÖauseÅime: %s ms\n",

83 
	`uötmaxToCommaSåög
 (
s
->
cumuœtiveSèti°ics
.
maxPau£Time
));

84 
	`Ârötf
 (
out
, "total bytesállocated: %s bytes\n",

85 
	`uötmaxToCommaSåög
 (
s
->
cumuœtiveSèti°ics
.
byãsAŒoˇãd
));

86 
	`Ârötf
 (
out
, "max bytesÜive: %s bytes\n",

87 
	`uötmaxToCommaSåög
 (
s
->
cumuœtiveSèti°ics
.
maxByãsLive
));

88 
	`Ârötf
 (
out
, "max heap size: %s bytes\n",

89 
	`uötmaxToCommaSåög
 (
s
->
cumuœtiveSèti°ics
.
maxHópSize
));

90 
	`Ârötf
 (
out
, "max stack size: %s bytes\n",

91 
	`uötmaxToCommaSåög
 (
s
->
cumuœtiveSèti°ics
.
maxSèckSize
));

92 
	`Ârötf
 (
out
, "num cards marked: %s\n",

93 
	`uötmaxToCommaSåög
 (
s
->
cumuœtiveSèti°ics
.
numC¨dsM¨ked
));

94 
	`Ârötf
 (
out
, "bytes scanned: %s bytes\n",

95 
	`uötmaxToCommaSåög
 (
s
->
cumuœtiveSèti°ics
.
byãsSˇ¬edMö‹
));

96 
	`Ârötf
 (
out
, "bytes hash consed: %s bytes\n",

97 
	`uötmaxToCommaSåög
 (
s
->
cumuœtiveSèti°ics
.
byãsHashC⁄£d
));

99 
	`ªÀa£Hóp
 (
s
, &s->
hóp
);

100 
	`ªÀa£Hóp
 (
s
, &s->
£c⁄d¨yHóp
);

101 
	}
}

	@done.h

9 
PRIVATE
 
GC_d⁄e
 (
GC_°©e
 
s
);

	@enter_leave.c

14 
	$íãr
 (
GC_°©e
 
s
) {

15 i‡(
DEBUG
)

16 
	`Ârötf
 (
°dîr
, "enter\n");

18 
	`gëSèckCuºít
(
s
)->
u£d
 = 
	`sizeofGCSèãCuºítSèckU£d
 (s);

19 
	`gëThªadCuºít
(
s
)->
exnSèck
 = s->exnStack;

20 i‡(
DEBUG
)

21 
	`di•œyGCSèã
 (
s
, 
°dîr
);

22 
	`begöAtomic
 (
s
);

23 
	`as£π
 (
	`öv¨ü¡F‹GC
 (
s
));

24 i‡(
DEBUG
)

25 
	`Ârötf
 (
°dîr
, "enter ok\n");

26 
	}
}

28 
	$Àave
 (
GC_°©e
 
s
) {

29 i‡(
DEBUG
)

30 
	`Ârötf
 (
°dîr
, "leave\n");

34 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹
 (
s
, 
FALSE
, 
TRUE
));

35 
	`ídAtomic
 (
s
);

36 i‡(
DEBUG
)

37 
	`Ârötf
 (
°dîr
, "leave ok\n");

38 
	}
}

	@enter_leave.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
íãr
 (
GC_°©e
 
s
);

12 
ölöe
 
Àave
 (
GC_°©e
 
s
);

	@foreach.c

9 
	$ˇŒIfIsObj±r
 (
GC_°©e
 
s
, 
GC_f‹óchObj±rFun
 
f
, 
obj±r
 *
›p
) {

10 i‡(
	`isObj±r
 (*
›p
)) {

11 
	`f
 (
s
, 
›p
);

15 i‡(
DEBUG_MEM
)

16 
	`Ârötf
(
°dîr
, " cÆlIfIsObj±r: NŸ obj±∏0x%x\n", *
›p
);

17 
	}
}

23 
	$f‹óchGlobÆObj±r
 (
GC_°©e
 
s
, 
GC_f‹óchObj±rFun
 
f
) {

24 
i
 = 0; i < 
s
->
globÆsLígth
; ++i) {

25 i‡(
DEBUG_DETAILED
)

26 
	`Ârötf
 (
°dîr
, "f‹óchGlobÆ %u\n", 
i
);

27 
	`ˇŒIfIsObj±r
 (
s
, 
f
, &s->
globÆs
 [
i
]);

29 i‡(
DEBUG_DETAILED
)

30 
	`Ârötf
 (
°dîr
, "foreachGlobalÅhreads\n");

31 
	`ˇŒIfIsObj±r
 (
s
, 
f
, &s->
ˇŒFromCH™dÀrThªad
);

32 
	`ˇŒIfIsObj±r
 (
s
, 
f
, &s->
cuºítThªad
);

33 
	`ˇŒIfIsObj±r
 (
s
, 
f
, &s->
ßvedThªad
);

34 
	`ˇŒIfIsObj±r
 (
s
, 
f
, &s->
sig«lH™dÀrThªad
);

35 
	}
}

45 
poöãr
 
	$f‹óchObj±rInObje˘
 (
GC_°©e
 
s
, 
poöãr
 
p
,

46 
GC_f‹óchObj±rFun
 
f
, 
boﬁ
 
skùWóks
) {

47 i‡(
DEBUG_MEM
) {

48 
	`Ârötf
(
°dîr
, "f‹óch obje˘ i¿0x%x\n", (
uöçå_t
)
p
);

50 
GC_hódî
 
hódî
;

51 
uöt16_t
 
byãsN⁄Obj±rs
;

52 
uöt16_t
 
numObj±rs
;

53 
GC_obje˘Ty≥Tag
 
èg
;

55 
hódî
 = 
	`gëHódî
 (
p
);

56 
	`•lôHódî
(
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

57 i‡(
DEBUG_DETAILED
)

58 
	`Ârötf
 (
°dîr
,

59 "f‹óchObj±rInObje˘ ("
FMTPTR
")"

60 " hódî = "
FMTHDR


64 (
uöçå_t
)
p
, 
hódî
, 
	`obje˘Ty≥TagToSåög
 (
èg
),

65 
byãsN⁄Obj±rs
, 
numObj±rs
);

66 i‡(
NORMAL_TAG
 =
èg
) {

80 i‡(
DEBUG_MEM
)

81 
	`Ârötf
(
°dîr
, " foreachObjptrInObject,Çormal, bytesNonObjptrs: %d, "

82 "numÖås: %d\n", 
byãsN⁄Obj±rs
, 
numObj±rs
);

90 
i
=0; i<
numObj±rs
; i++) {

91 
poöãr
 
todo
 = 
	`UM_CPoöãr_off£t
(
s
, 
p
, 
byãsN⁄Obj±rs
 + 
i
 * 
OBJPTR_SIZE
,

92 
OBJPTR_SIZE
);

107 
	`ˇŒIfIsObj±r
 (
s
, 
f
, (
obj±r
*)
todo
);

112 } i‡(
WEAK_TAG
 =
èg
) {

113 
p
 +
byãsN⁄Obj±rs
;

114 i‡(1 =
numObj±rs
) {

115 i‡(
nŸ
 
skùWóks
)

116 
	`ˇŒIfIsObj±r
 (
s
, 
f
, (
obj±r
*)
p
);

117 
p
 +
OBJPTR_SIZE
;

119 } i‡(
ARRAY_TAG
 =
èg
 &&

120 ((
p
 >
s
->
um¨hóp
.
°¨t
 + s->um¨hóp.
size
) ||

121 (
p
 < 
s
->
um¨hóp
.
°¨t
))) {

122 
size_t
 
byãsPîEÀmít
;

123 
size_t
 
d©aByãs
;

124 
poöãr
 
œ°
;

125 
GC_¨øyLígth
 
numEÀmíts
;

127 
numEÀmíts
 = 
	`gëAºayLígth
 (
p
);

128 
byãsPîEÀmít
 = 
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
);

129 
d©aByãs
 = 
numEÀmíts
 * 
byãsPîEÀmít
;

130 i‡(
d©aByãs
 < 
OBJPTR_SIZE
) {

134 
d©aByãs
 = 
OBJPTR_SIZE
;

135 } i‡(0 =
numObj±rs
) {

139 
œ°
 = 
p
 + 
d©aByãs
;

140 i‡(0 =
byãsN⁄Obj±rs
)

142  ; 
p
 < 
œ°
;Ö +
OBJPTR_SIZE
)

143 
	`ˇŒIfIsObj±r
 (
s
, 
f
, (
obj±r
*)
p
);

146 
size_t
 
byãsObj±rs
;

148 
byãsObj±rs
 = 
numObj±rs
 * 
OBJPTR_SIZE
;

151  ; 
p
 < 
œ°
; ) {

152 
poöãr
 
√xt
;

155 
p
 +
byãsN⁄Obj±rs
;

156 
√xt
 = 
p
 + 
byãsObj±rs
;

158  ; 
p
 < 
√xt
;Ö +
OBJPTR_SIZE
)

159 
	`ˇŒIfIsObj±r
 (
s
, 
f
, (
obj±r
*)
p
);

162 
	`as£π
 (
p
 =
œ°
);

163 
p
 -
d©aByãs
;

165 
p
 +
	`ÆignWôhExåa
 (
s
, 
d©aByãs
, 
GC_ARRAY_HEADER_SIZE
);

166 } i‡(
ARRAY_TAG
 =
èg
) {

167 
GC_UM_Aºay_Chunk
 
f°_Àaf
 = (GC_UM_Aºay_Chunk)(
p
 - 
GC_HEADER_SIZE
 - GC_HEADER_SIZE);

168 i‡(
f°_Àaf
->
¨øy_chunk_Àngth
 > 0) {

169 
size_t
 
Àngth
 = 
f°_Àaf
->
¨øy_chunk_Àngth
;

170 
GC_UM_Aºay_Chunk
 
cur_chunk
 = 
f°_Àaf
;

171 
size_t
 
i
, 
j
;

172 
size_t
 
ñem_size
 = 
byãsN⁄Obj±rs
 + 
numObj±rs
 * 
OBJPTR_SIZE
;

173 
i
=0; i<
Àngth
; i++) {

174 
poöãr
 
°¨t
 = (poöãr)&(
cur_chunk
->
ml_¨øy_∑ylﬂd
.
ml_obje˘
[0]);

175 
size_t
 
off£t
 = (
i
 % 
f°_Àaf
->
¨øy_chunk_numObjs
Ë* 
ñem_size
 + 
byãsN⁄Obj±rs
;

176 
poöãr
 
pobj
 = 
°¨t
 + 
off£t
;

177 
j
=0; j<
numObj±rs
; j++) {

178 
	`ˇŒIfIsObj±r
 (
s
, 
f
, (
obj±r
*)
pobj
);

179 
pobj
 +
OBJPTR_SIZE
;

182 i‡(
i
 > 0 && i % 
f°_Àaf
->
¨øy_chunk_numObjs
 == 0)

183 
cur_chunk
 = cur_chunk->
√xt_chunk
;

187 
GC_°ack
 
°ack
;

188 
poöãr
 
t›
, 
bŸtom
;

189 
i
;

190 
GC_ªtu∫Addªss
 
ªtu∫Addªss
;

191 
GC_‰ameLayout
 
‰ameLayout
;

192 
GC_‰ameOff£ts
 
‰ameOff£ts
;

194 
	`as£π
 (
STACK_TAG
 =
èg
);

195 
°ack
 = (
GC_°ack
)
p
;

196 
bŸtom
 = 
	`gëSèckBŸtom
 (
s
, 
°ack
);

197 
t›
 = 
	`gëSèckT›
 (
s
, 
°ack
);

198 i‡(
DEBUG
) {

199 
	`Ârötf
 (
°dîr
, " bŸtom = "
FMTPTR
"Åop = "FMTPTR"\n",

200 (
uöçå_t
)
bŸtom
, (uöçå_t)
t›
);

202 
	`as£π
 (
°ack
->
u£d
 <°ack->
ª£rved
);

203 
t›
 > 
bŸtom
) {

205 
ªtu∫Addªss
 = *((
GC_ªtu∫Addªss
*)(
t›
 - 
GC_RETURNADDRESS_SIZE
));

206 i‡(
DEBUG_MEM
) {

207 
	`Ârötf
 (
°dîr
, "Å› = "
FMTPTR
"Ñëu∫áddªs†"
FMTRA
"\n",

208 (
uöçå_t
)
t›
, 
ªtu∫Addªss
);

210 
‰ameLayout
 = 
	`gëFømeLayoutFromRëu∫Addªss
 (
s
, 
ªtu∫Addªss
);

211 
‰ameOff£ts
 = 
‰ameLayout
->
off£ts
;

212 
t›
 -
‰ameLayout
->
size
;

214 
i
 = 0 ; i < 
‰ameOff£ts
[0] ; ++i) {

215 i‡(
DEBUG_MEM
)

216 
	`Ârötf
(
°dîr
, " off£à%"
PRIx16
"áddªs†"
FMTOBJPTR
"\n",

217 
‰ameOff£ts
[
i
 + 1], *(
obj±r
*)(
t›
 + frameOffsets[i + 1]));

218 
	`ˇŒIfIsObj±r
 (
s
, 
f
, (
obj±r
*)(
t›
 + 
‰ameOff£ts
[
i
 + 1]));

221 
	`as£π
(
t›
 =
bŸtom
);

222 
p
 + (
GC_°ack
Ë+ 
°ack
->
ª£rved
;

224  
p
;

225 
	}
}

239 
poöãr
 
	$f‹óchObj±rInR™ge
 (
GC_°©e
 
s
, 
poöãr
 
‰⁄t
,Öoöã∏*
back
,

240 
GC_f‹óchObj±rFun
 
f
, 
boﬁ
 
skùWóks
) {

241 
poöãr
 
b
;

243 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, 
‰⁄t
));

244 i‡(
DEBUG_DETAILED
)

245 
	`Ârötf
 (
°dîr
,

246 "f‹óchObj±rInR™gê fr⁄à"
FMTPTR
" *back = "FMTPTR"\n",

247 (
uöçå_t
)
‰⁄t
, (uöçå_t)(*
back
));

248 
b
 = *
back
;

249 
	`as£π
 (
‰⁄t
 <
b
);

250 
‰⁄t
 < 
b
) {

251 
‰⁄t
 < 
b
) {

252 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
‰⁄t
, 
GC_MODEL_MINALIGN
));

253 i‡(
DEBUG_DETAILED
)

254 
	`Ârötf
 (
°dîr
,

255 " fr⁄à"
FMTPTR
" *back = "FMTPTR"\n",

256 (
uöçå_t
)
‰⁄t
, (uöçå_t)(*
back
));

257 
poöãr
 
p
 = 
	`adv™˚ToObje˘D©a
 (
s
, 
‰⁄t
);

258 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
p
, 
s
->
Æignmít
));

259 
‰⁄t
 = 
	`f‹óchObj±rInObje˘
 (
s
, 
p
, 
f
, 
skùWóks
);

261 
b
 = *
back
;

263  
‰⁄t
;

264 
	}
}

268 
	$f‹óchSèckFøme
 (
GC_°©e
 
s
, 
GC_f‹óchSèckFømeFun
 
f
) {

269 
poöãr
 
bŸtom
;

270 
GC_‰ameIndex
 
födex
;

271 
GC_‰ameLayout
 
œyout
;

272 
GC_ªtu∫Addªss
 
ªtu∫Addªss
;

273 
poöãr
 
t›
;

275 i‡(
DEBUG_PROFILE
)

276 
	`Ârötf
 (
°dîr
, "foreachStackFrame\n");

277 
bŸtom
 = 
	`gëSèckBŸtom
 (
s
, 
	`gëSèckCuºít
(s));

278 i‡(
DEBUG_PROFILE
)

279 
	`Ârötf
 (
°dîr
, " bŸtom = "
FMTPTR
"Åop = "FMTPTR".\n",

280 (
uöçå_t
)
bŸtom
, (uöçå_t)
s
->
°ackT›
);

281 
t›
 = 
s
->
°ackT›
;Å› > 
bŸtom
;Å› -
œyout
->
size
) {

282 
ªtu∫Addªss
 = *((
GC_ªtu∫Addªss
*)(
t›
 - 
GC_RETURNADDRESS_SIZE
));

283 
födex
 = 
	`gëFømeIndexFromRëu∫Addªss
 (
s
, 
ªtu∫Addªss
);

284 i‡(
DEBUG_PROFILE
)

285 
	`Ârötf
 (
°dîr
, "t› = "
FMTPTR
" födex = "
FMTFI
"\n",

286 (
uöçå_t
)
t›
, 
födex
);

287 
	`u∆ess
 (
födex
 < 
s
->
‰ameLayoutsLígth
)

288 
	`dõ
 ("t› = "
FMTPTR
"Ñëu∫Addªs†"
FMTRA
" födex = "
FMTFI
"\n",

289 (
uöçå_t
)
t›
, (uöçå_t)
ªtu∫Addªss
, 
födex
);

290 
	`f
 (
s
, 
födex
);

291 
œyout
 = &(
s
->
‰ameLayouts
[
födex
]);

292 
	`as£π
 (
œyout
->
size
 > 0);

294 i‡(
DEBUG_PROFILE
)

295 
	`Ârötf
 (
°dîr
, "done foreachStackFrame\n");

296 
	}
}

	@foreach.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 (*
	tGC_f‹óchObj±rFun
Ë(
	tGC_°©e
 
	ts
, 
	tobj±r
 *
	t›p
);

13 
ölöe
 
	`ˇŒIfIsObj±r
 (
GC_°©e
 
s
, 
GC_f‹óchObj±rFun
 
f
, 
obj±r
 *
›p
);

18 
ölöe
 
	`f‹óchGlobÆObj±r
 (
GC_°©e
 
s
, 
GC_f‹óchObj±rFun
 
f
);

26 
ölöe
 
poöãr
 
	`f‹óchObj±rInObje˘
 (
GC_°©e
 
s
,Öoöã∏
p
,

27 
GC_f‹óchObj±rFun
 
f
, 
boﬁ
 
skùWóks
);

39 
ölöe
 
poöãr
 
	`f‹óchObj±rInR™ge
 (
GC_°©e
 
s
,Öoöã∏
‰⁄t
,Öoöã∏*
back
,

40 
GC_f‹óchObj±rFun
 
f
, 
boﬁ
 
skùWóks
);

43 (*
	tGC_f‹óchSèckFømeFun
Ë(
	tGC_°©e
 
	ts
, 
	tGC_‰ameIndex
 
	ti
);

49 
ölöe
 
	`f‹óchSèckFøme
 (
GC_°©e
 
s
, 
GC_f‹óchSèckFømeFun
 
f
);

	@forward.c

10 #i‡
ASSERT


11 
boﬁ
 
	$isPoöãrInToS∑˚
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

12  (
	`nŸ
 (
	`isPoöãr
 (
p
))

13 
	`‹
 (
s
->
f‹w¨dSèã
.
toSèπ
 <
p
 
™d
Ö < s->f‹w¨dSèã.
toLimô
));

14 
	}
}

16 
boﬁ
 
	$isObj±rInToS∑˚
 (
GC_°©e
 
s
, 
obj±r
 
›
) {

17 
poöãr
 
p
;

19 i‡(
	`nŸ
 (
	`isObj±r
 (
›
)))

20  
TRUE
;

21 
p
 = 
	`obj±rToPoöãr
 (
›
, 
s
->
f‹w¨dSèã
.
toSèπ
);

22  
	`isPoöãrInToS∑˚
 (
s
, 
p
);

23 
	}
}

30 
	$f‹w¨dObj±r
 (
GC_°©e
 
s
, 
obj±r
 *
›p
) {

31 
obj±r
 
›
;

32 
poöãr
 
p
;

33 
GC_hódî
 
hódî
;

35 
›
 = *
›p
;

36 
p
 = 
	`obj±rToPoöãr
 (
›
, 
s
->
hóp
.
°¨t
);

37 i‡(
DEBUG_DETAILED
)

38 
	`Ârötf
 (
°dîr
,

39 "f‹w¨dObj±∏ oµ = "
FMTPTR
" o∞"
FMTOBJPTR
"Ö = "FMTPTR"\n",

40 (
uöçå_t
)
›p
, 
›
, (uöçå_t)
p
);

41 
	`as£π
 (
	`isObj±rInFromS∑˚
 (
s
, *
›p
));

42 
hódî
 = 
	`gëHódî
 (
p
);

43 i‡(
DEBUG_DETAILED
 
™d
 
hódî
 =
GC_FORWARDED
)

44 
	`Ârötf
 (
°dîr
, "álready FORWARDED\n");

45 i‡(
hódî
 !
GC_FORWARDED
) {

46 
size_t
 
size
, 
skù
;

48 
size_t
 
hódîByãs
, 
obje˘Byãs
;

49 
GC_obje˘Ty≥Tag
 
èg
;

50 
uöt16_t
 
byãsN⁄Obj±rs
, 
numObj±rs
;

52 
	`•lôHódî
(
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

55 i‡((
NORMAL_TAG
 =
èg
Ë
	`‹
 (
WEAK_TAG
 ==Åag)) {

56 
hódîByãs
 = 
GC_NORMAL_HEADER_SIZE
;

57 
obje˘Byãs
 = 
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
);

58 
skù
 = 0;

59 } i‡(
ARRAY_TAG
 =
èg
) {

60 
hódîByãs
 = 
GC_ARRAY_HEADER_SIZE
;

61 
obje˘Byãs
 = 
	`sizeofAºayNoHódî
 (
s
, 
	`gëAºayLígth
 (
p
),

62 
byãsN⁄Obj±rs
, 
numObj±rs
);

63 
skù
 = 0;

65 
boﬁ
 
cuºít
;

66 
size_t
 
ª£rvedNew
;

67 
GC_°ack
 
°ack
;

69 
	`as£π
 (
STACK_TAG
 =
èg
);

70 
hódîByãs
 = 
GC_STACK_HEADER_SIZE
;

71 
°ack
 = (
GC_°ack
)
p
;

72 
cuºít
 = 
	`gëSèckCuºít
(
s
Ë=
°ack
;

74 
ª£rvedNew
 = 
	`sizeofSèckShrökRe£rved
 (
s
, 
°ack
, 
cuºít
);

75 i‡(
ª£rvedNew
 < 
°ack
->
ª£rved
) {

76 i‡(
DEBUG_STACKS
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

77 
	`Ârötf
 (
°dîr
,

79 
	`uötmaxToCommaSåög
(
°ack
->
ª£rved
),

80 
	`uötmaxToCommaSåög
(
ª£rvedNew
),

81 
	`uötmaxToCommaSåög
(
°ack
->
u£d
));

82 
°ack
->
ª£rved
 = 
ª£rvedNew
;

84 
obje˘Byãs
 =  (
GC_°ack
Ë+ 
°ack
->
u£d
;

85 
skù
 = 
°ack
->
ª£rved
 - sèck->
u£d
;

87 
size
 = 
hódîByãs
 + 
obje˘Byãs
;

88 
	`as£π
 (
s
->
f‹w¨dSèã
.
back
 + 
size
 + 
skù
 <s->f‹w¨dSèã.
toLimô
);

90 
	`GC_mem˝y
 (
p
 - 
hódîByãs
, 
s
->
f‹w¨dSèã
.
back
, 
size
);

94 i‡((
WEAK_TAG
 =
èg
Ë
	`™d
 (
numObj±rs
 == 1)) {

95 
GC_wók
 
w
;

97 
w
 = (
GC_wók
)(
s
->
f‹w¨dSèã
.
back
 + 
GC_NORMAL_HEADER_SIZE
 + 
	`off£tofWók
 (s));

98 i‡(
DEBUG_WEAK
)

99 
	`Ârötf
 (
°dîr
, "f‹w¨dög wók "
FMTPTR
" ",

100 (
uöçå_t
)
w
);

101 i‡(
	`isObj±r
 (
w
->
obj±r
)

102 
	`™d
 (
nŸ
 
s
->
f‹w¨dSèã
.
amInMö‹GC


103 
‹
 
	`isObj±rInNur£ry
 (
s
, 
w
->
obj±r
))) {

104 i‡(
DEBUG_WEAK
)

105 
	`Ârötf
 (
°dîr
, "linking\n");

106 
w
->
lök
 = 
s
->
wóks
;

107 
s
->
wóks
 = 
w
;

109 i‡(
DEBUG_WEAK
)

110 
	`Ârötf
 (
°dîr
, "notÜinking\n");

114 *((
GC_hódî
*)(
p
 - 
GC_HEADER_SIZE
)Ë
GC_FORWARDED
;

115 *((
obj±r
*)
p
Ë
	`poöãrToObj±r
 (
s
->
f‹w¨dSèã
.
back
 + 
hódîByãs
,

116 
s
->
f‹w¨dSèã
.
toSèπ
);

118 
s
->
f‹w¨dSèã
.
back
 +
size
 + 
skù
;

119 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
s
->
f‹w¨dSèã
.
back
 + 
GC_NORMAL_HEADER_SIZE
,

120 
s
->
Æignmít
));

122 *
›p
 = *((
obj±r
*)
p
);

123 i‡(
DEBUG_DETAILED
)

124 
	`Ârötf
 (
°dîr
,

125 "f‹w¨dObj±∏--> *›∞"
FMTPTR
"\n",

126 (
uöçå_t
)*
›p
);

127 
	`as£π
 (
	`isObj±rInToS∑˚
 (
s
, *
›p
));

128 
	}
}

130 
	$f‹w¨dObj±rIfInNur£ry
 (
GC_°©e
 
s
, 
obj±r
 *
›p
) {

131 
obj±r
 
›
;

132 
poöãr
 
p
;

134 
›
 = *
›p
;

135 
p
 = 
	`obj±rToPoöãr
 (
›
, 
s
->
hóp
.
°¨t
);

136 i‡(
p
 < 
s
->
hóp
.
nur£ry
)

138 i‡(
DEBUG_GENERATIONAL
)

139 
	`Ârötf
 (
°dîr
,

140 "f‹w¨dObj±rIfInNur£ry oµ = "
FMTPTR
" o∞"
FMTOBJPTR
"Ö = "FMTPTR"\n",

141 (
uöçå_t
)
›p
, 
›
, (uöçå_t)
p
);

142 
	`as£π
 (
s
->
hóp
.
nur£ry
 <
p
 
™d
Ö < s->
limôPlusSl›
);

143 
	`f‹w¨dObj±r
 (
s
, 
›p
);

144 
	}
}

147 
	$f‹w¨dI¡îGíî©i⁄ÆObj±rs
 (
GC_°©e
 
s
) {

148 
GC_ˇrdM≠EÀm
 *
ˇrdM≠
;

149 
GC_¸ossM≠EÀm
 *
¸ossM≠
;

150 
poöãr
 
ﬁdGíSèπ
, 
ﬁdGíEnd
;

152 
size_t
 
ˇrdIndex
, 
maxC¨dIndex
;

153 
poöãr
 
ˇrdSèπ
, 
ˇrdEnd
;

154 
poöãr
 
obje˘Sèπ
;

156 i‡(
DEBUG_GENERATIONAL
)

157 
	`Ârötf
 (
°dîr
, "Forwarding inter-generationalÖointers.\n");

158 
	`upd©eCrossM≠
 (
s
);

160 
ˇrdM≠
 = 
s
->
gíî©i⁄ÆM≠s
.cardMap;

161 
¸ossM≠
 = 
s
->
gíî©i⁄ÆM≠s
.crossMap;

162 
maxC¨dIndex
 = 
	`sizeToC¨dM≠Index
 (
	`Æign
 (
s
->
hóp
.
ﬁdGíSize
, 
CARD_SIZE
));

163 
ﬁdGíSèπ
 = 
s
->
hóp
.
°¨t
;

164 
ﬁdGíEnd
 = 
ﬁdGíSèπ
 + 
s
->
hóp
.
ﬁdGíSize
;

166 
obje˘Sèπ
 = 
	`ÆignFr⁄tõr
 (
s
, s->
hóp
.
°¨t
);

167 
ˇrdIndex
 = 0;

168 
ˇrdSèπ
 = 
ﬁdGíSèπ
;

169 
checkAŒ
:

170 
	`as£π
 (
ˇrdIndex
 <
maxC¨dIndex
);

171 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, 
obje˘Sèπ
));

172 i‡(
ˇrdIndex
 =
maxC¨dIndex
)

173 
d⁄e
;

174 
checkC¨d
:

175 i‡(
DEBUG_GENERATIONAL
)

176 
	`Ârötf
 (
°dîr
, "checkög c¨d %"
PRIuMAX
" obje˘Sèπ = "
FMTPTR
"\n",

177 (
uötmax_t
)
ˇrdIndex
, (
uöçå_t
)
obje˘Sèπ
);

178 
	`as£π
 (
obje˘Sèπ
 < 
ﬁdGíSèπ
 + 
	`ˇrdM≠IndexToSize
 (
ˇrdIndex
 + 1));

179 i‡(
ˇrdM≠
[
ˇrdIndex
]) {

180 
poöãr
 
œ°Obje˘
;

182 
s
->
cumuœtiveSèti°ics
.
numC¨dsM¨ked
++;

183 i‡(
DEBUG_GENERATIONAL
)

184 
	`Ârötf
 (
°dîr
, "ˇrd %"
PRIuMAX
" i†m¨ked obje˘Sèπ = "
FMTPTR
"\n",

185 (
uötmax_t
)
ˇrdIndex
, (
uöçå_t
)
obje˘Sèπ
);

186 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, 
obje˘Sèπ
));

187 
ˇrdEnd
 = 
ˇrdSèπ
 + 
CARD_SIZE
;

188 i‡(
ﬁdGíEnd
 < 
ˇrdEnd
)

189 
ˇrdEnd
 = 
ﬁdGíEnd
;

190 
	`as£π
 (
obje˘Sèπ
 < 
ˇrdEnd
);

191 
œ°Obje˘
 = 
obje˘Sèπ
;

198 
obje˘Sèπ
 = 
	`f‹óchObj±rInR™ge
 (
s
, obje˘Sèπ, &
ˇrdEnd
,

199 
f‹w¨dObj±rIfInNur£ry
, 
FALSE
);

200 
s
->
cumuœtiveSèti°ics
.
byãsSˇ¬edMö‹
 +(
uötmax_t
)(
obje˘Sèπ
 - 
œ°Obje˘
);

201 i‡(
obje˘Sèπ
 =
ﬁdGíEnd
)

202 
d⁄e
;

203 
ˇrdIndex
 = 
	`sizeToC¨dM≠Index
 ((
size_t
)(
obje˘Sèπ
 - 
ﬁdGíSèπ
));

204 
ˇrdSèπ
 = 
ﬁdGíSèπ
 + 
	`ˇrdM≠IndexToSize
 (
ˇrdIndex
);

205 
checkC¨d
;

207 
	`u∆ess
 (
CROSS_MAP_EMPTY
 =
¸ossM≠
[
ˇrdIndex
])

208 
obje˘Sèπ
 = 
ˇrdSèπ
 + (
size_t
)(
¸ossM≠
[
ˇrdIndex
] * 
CROSS_MAP_OFFSET_SCALE
);

209 i‡(
DEBUG_GENERATIONAL
)

210 
	`Ârötf
 (
°dîr
,

211 "ˇrd %"
PRIuMAX
" isÇot marked"

212 " crossM≠[%"
PRIuMAX
"] == %"PRIuMAX""

213 " obje˘Sèπ = "
FMTPTR
"\n",

214 (
uötmax_t
)
ˇrdIndex
, (uintmax_t)cardIndex,

215 (
uötmax_t
)(
¸ossM≠
[
ˇrdIndex
] * 
CROSS_MAP_OFFSET_SCALE
),

216 (
uöçå_t
)
obje˘Sèπ
);

217 
ˇrdIndex
++;

218 
ˇrdSèπ
 +
CARD_SIZE
;

219 
checkAŒ
;

221 
	`as£π
 (
FALSE
);

222 
d⁄e
:

223 i‡(
DEBUG_GENERATIONAL
)

224 
	`Ârötf
 (
°dîr
, "Forwarding inter-generationalÖointers done.\n");

225 
	}
}

	@forward.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

12 
	sGC_f‹w¨dSèã
 {

13 
boﬁ
 
	mamInMö‹GC
;

14 
poöãr
 
	mback
;

15 
poöãr
 
	mtoSèπ
;

16 
poöãr
 
	mtoLimô
;

19 
	#GC_FORWARDED
 ~((
GC_hódî
)0)

	)

23 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

25 #i‡
ASSERT


26 
ölöe
 
boﬁ
 
isPoöãrInToS∑˚
 (
GC_°©e
 
s
, 
poöãr
 
p
);

27 
ölöe
 
boﬁ
 
isObj±rInToS∑˚
 (
GC_°©e
 
s
, 
obj±r
 
›
);

30 
ölöe
 
f‹w¨dObj±r
 (
GC_°©e
 
s
, 
obj±r
 *
›p
);

31 
ölöe
 
f‹w¨dObj±rIfInNur£ry
 (
GC_°©e
 
s
, 
obj±r
 *
›p
);

32 
ölöe
 
f‹w¨dI¡îGíî©i⁄ÆObj±rs
 (
GC_°©e
 
s
);

	@frame.c

9 
GC_‰ameIndex
 
	$gëFømeIndexFromRëu∫Addªss
 (
GC_°©e
 
s
, 
GC_ªtu∫Addªss
 
ø
) {

10 
GC_‰ameIndex
 
ªs
;

12 
ªs
 = 
s
->
	`ªtu∫AddªssToFømeIndex
 (
ø
);

13 i‡(
DEBUG_DETAILED
)

14 
	`Ârötf
 (
°dîr
, 
FMTFI
" = gëFømeIndexFromRëu∫Addªs†("
FMTRA
")\n",

15 
ªs
, 
ø
);

16  
ªs
;

17 
	}
}

19 
GC_‰ameLayout
 
	$gëFømeLayoutFromFømeIndex
 (
GC_°©e
 
s
, 
GC_‰ameIndex
 
födex
) {

20 
GC_‰ameLayout
 
œyout
;

22 i‡(
DEBUG_DETAILED
)

23 
	`Ârötf
 (
°dîr
, "födex = "
FMTFI
" fømeLayoutsLígth = %"
PRIu32
"\n",

24 
födex
, 
s
->
‰ameLayoutsLígth
);

25 
	`as£π
 (
födex
 < 
s
->
‰ameLayoutsLígth
);

26 
œyout
 = &(
s
->
‰ameLayouts
[
födex
]);

27 
	`as£π
 (
œyout
->
size
 > 0);

30  
œyout
;

31 
	}
}

33 
GC_‰ameLayout
 
	$gëFømeLayoutFromRëu∫Addªss
 (
GC_°©e
 
s
, 
GC_ªtu∫Addªss
 
ø
) {

34 
GC_‰ameLayout
 
œyout
;

35 
GC_‰ameIndex
 
födex
;

37 
födex
 = 
	`gëFømeIndexFromRëu∫Addªss
 (
s
, 
ø
);

38 
œyout
 = 
	`gëFømeLayoutFromFømeIndex
(
s
, 
födex
);

39  
œyout
;

40 
	}
}

	@frame.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

30 
uöt16_t
 *
	tGC_‰ameOff£ts
;

33 
	mC_FRAME
,

34 
	mML_FRAME


35 } 
	tGC_‰ameKöd
;

37 
	sGC_‰ameLayout
 {

38 
GC_‰ameKöd
 
	mköd
;

39 
GC_‰ameOff£ts
 
	moff£ts
;

40 
uöt16_t
 
	msize
;

41 } *
	tGC_‰ameLayout
;

42 
uöt32_t
 
	tGC_‰ameIndex
;

43 
	#PRIFI
 
PRIu32


	)

44 
	#FMTFI
 "%"
PRIFI


	)

46 
uöçå_t
 
	tGC_ªtu∫Addªss
;

47 
	#GC_RETURNADDRESS_SIZE
 (
GC_ªtu∫Addªss
)

	)

48 
	#FMTRA
 "0x%016"
PRIxPTR


	)

52 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

54 
ölöe
 
GC_‰ameIndex
 
gëFømeIndexFromRëu∫Addªss
 (
GC_°©e
 
s
, 
GC_ªtu∫Addªss
 
ø
);

55 
ölöe
 
GC_‰ameLayout
 
gëFømeLayoutFromFømeIndex
 (
GC_°©e
 
s
, 
GC_‰ameIndex
 
födex
);

56 
ölöe
 
GC_‰ameLayout
 
gëFømeLayoutFromRëu∫Addªss
 (
GC_°©e
 
s
, 
GC_ªtu∫Addªss
 
ø
);

	@garbage-collection.c

10 
	$mö‹GC
 (
GC_°©e
 
s
) {

11 
	`mö‹ChíeyC›yGC
 (
s
);

12 
	}
}

14 
__©åibuã__
 ((
unu£d
)Ë
	$maj‹GC
 (
GC_°©e
 
s
, 
size_t
 
byãsReque°ed
, 
boﬁ
 
mayResize
) {

15 
uötmax_t
 
numGCs
;

16 
size_t
 
desúedSize
;

18 
s
->
œ°Maj‹Sèti°ics
.
numMö‹GCs
 = 0;

19 
numGCs
 =

20 
s
->
cumuœtiveSèti°ics
.
numC›yögGCs


21 + 
s
->
cumuœtiveSèti°ics
.
numM¨kCom∑˘GCs
;

22 i‡(0 < 
numGCs


23 
	`™d
 (()(
s
->
cumuœtiveSèti°ics
.
numHashC⁄sGCs
Ë/ ()(
numGCs
)

24 < 
s
->
c⁄åﬁs
.
øtios
.
hashC⁄s
))

25 
s
->
hashC⁄sDurögGC
 = 
TRUE
;

26 
desúedSize
 =

27 
	`sizeofHópDesúed
 (
s
, s->
œ°Maj‹Sèti°ics
.
byãsLive
 + 
byãsReque°ed
, 0);

28 i‡(
nŸ
 
FORCE_MARK_COMPACT


29 
™d
 
nŸ
 
s
->
hashC⁄sDurögGC


30 
™d
 
s
->
hóp
.
wôhM≠sSize
 < s->
sysvÆs
.
øm


31 
	`™d
 (
nŸ
 
	`isHópInô
 (&
s
->
£c⁄d¨yHóp
)

32 
‹
 
	`¸óãHópSec⁄d¨y
 (
s
, 
desúedSize
)))

33 
	`maj‹ChíeyC›yGC
 (
s
);

35 
	`maj‹M¨kCom∑˘GC
 (
s
);

36 
s
->
hashC⁄sDurögGC
 = 
FALSE
;

37 
s
->
œ°Maj‹Sèti°ics
.
byãsLive
 = s->
hóp
.
ﬁdGíSize
;

38 i‡(
s
->
œ°Maj‹Sèti°ics
.
byãsLive
 > s->
cumuœtiveSèti°ics
.
maxByãsLive
)

39 
s
->
cumuœtiveSèti°ics
.
maxByãsLive
 = s->
œ°Maj‹Sèti°ics
.
byãsLive
;

45 i‡(
mayResize
) {

46 
	`ªsizeHóp
 (
s
, s->
œ°Maj‹Sèti°ics
.
byãsLive
 + 
byãsReque°ed
);

50 
	`Ârötf
(
°dîr
, "Collection done\n");

52 
	`£tC¨dM≠AndCrossM≠
 (
s
);

53 
	`ªsizeHópSec⁄d¨y
 (
s
);

54 
	`as£π
 (
s
->
hóp
.
ﬁdGíSize
 + 
byãsReque°ed
 <s->hóp.
size
);

55 
	}
}

57 
	$growSèckCuºít
 (
GC_°©e
 
s
) {

58 
size_t
 
ª£rved
;

59 
GC_°ack
 
°ack
;

61 
ª£rved
 = 
	`sizeofSèckGrowRe£rved
 (
s
, 
	`gëSèckCuºít
(s));

62 i‡(
DEBUG_STACKS
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

63 
	`Ârötf
 (
°dîr
,

65 
	`uötmaxToCommaSåög
(
	`gëSèckCuºít
(
s
)->
ª£rved
),

66 
	`uötmaxToCommaSåög
(
ª£rved
),

67 
	`uötmaxToCommaSåög
(
	`gëSèckCuºít
(
s
)->
u£d
));

68 
	`as£π
 (
	`hasHópByãsFªe
 (
s
, 
	`sizeofSèckWôhHódî
 (s, 
ª£rved
), 0));

69 
°ack
 = 
	`√wSèck
 (
s
, 
ª£rved
, 
TRUE
);

70 
	`c›ySèck
 (
s
, 
	`gëSèckCuºít
(s), 
°ack
);

71 
	`gëThªadCuºít
(
s
)->
°ack
 = 
	`poöãrToObj±r
 ((
poöãr
)°ack, s->
hóp
.
°¨t
);

72 
	`m¨kC¨d
 (
s
, 
	`obj±rToPoöãr
 (
	`gëThªadCuºítObj±r
(s), s->
hóp
.
°¨t
));

73 
	}
}

75 
	$íãrGC
 (
GC_°©e
 
s
) {

76 i‡(
s
->
¥ofûög
.
isOn
) {

81 i‡(
s
->
¥ofûög
.
°ack


82 
™d
 
	`nŸ
 (
PROFILE_COUNT
 =
s
->
¥ofûög
.
köd
))

83 
	`GC_¥ofûeE¡î
 (
s
);

85 
s
->
amInGC
 = 
TRUE
;

86 
	}
}

88 
	$ÀaveGC
 (
GC_°©e
 
s
) {

89 i‡(
s
->
¥ofûög
.
isOn
) {

90 i‡(
s
->
¥ofûög
.
°ack


91 
™d
 
	`nŸ
 (
PROFILE_COUNT
 =
s
->
¥ofûög
.
köd
))

92 
	`GC_¥ofûeLóve
 (
s
);

94 
s
->
amInGC
 = 
FALSE
;

95 
	}
}

99 
	$≥rf‹mUMGC
(
GC_°©e
 
s
) {

101 i‡(
DEBUG_MEM
) {

102 
	`Ârötf
(
°dîr
, "PerformUMGC\n");

103 
	`dumpUMHóp
(
s
);

105 
GC_°ack
 
cuºítSèck
 = 
	`gëSèckCuºít
(
s
);

106 
	`f‹óchGlobÆObj±r
 (
s
, 
umDfsM¨kObje˘sM¨k
);

107 
	`f‹óchObj±rInObje˘
(
s
, (
poöãr
Ë
cuºítSèck
, 
umDfsM¨kObje˘sM¨k
, 
FALSE
);

114 
poöãr
 
pchunk
;

115 
size_t
 
°ï
 = (
GC_UM_Chunk
);

116 
poöãr
 
íd
 = 
s
->
umhóp
.
°¨t
 + s->umhóp.
size
 - 
°ï
;

119 
pchunk
=
s
->
umhóp
.
°¨t
;

120 
pchunk
 < 
íd
;

121 
pchunk
+=
°ï
) {

122 
GC_UM_Chunk
 
pc
 = (GC_UM_Chunk)
pchunk
;

123 i‡((
pc
->
chunk_hódî
 & 
UM_CHUNK_IN_USE
) &&

124 (!(
pc
->
chunk_hódî
 & 
UM_CHUNK_HEADER_MASK
))) {

125 i‡(
DEBUG_MEM
) {

126 
	`Ârötf
(
°dîr
, "CﬁÀ˘ög: "
FMTPTR
", %d, %d\n",

127 (
uöçå_t
)
pc
,Öc->
£¡öñ
,Öc->
chunk_hódî
);

129 
	`ö£πFªeChunk
(
s
, &(s->
umhóp
), 
pchunk
);

134 
°ï
 = (
GC_UM_Aºay_Chunk
);

135 
íd
 = 
s
->
um¨hóp
.
°¨t
 + s->um¨hóp.
size
 - 
°ï
;

137 
pchunk
=
s
->
um¨hóp
.
°¨t
;

138 
pchunk
 < 
íd
;

139 
pchunk
 +
°ï
) {

140 
GC_UM_Aºay_Chunk
 
pc
 = (GC_UM_Aºay_Chunk)
pchunk
;

141 i‡((
pc
->
¨øy_chunk_hódî
 & 
UM_CHUNK_IN_USE
) &&

142 (!(
pc
->
¨øy_chunk_hódî
 & 
UM_CHUNK_HEADER_MASK
))) {

143 i‡(
DEBUG_MEM
) {

144 
	`Ârötf
(
°dîr
, "CﬁÀ˘ögáºay: "
FMTPTR
", %d, %d\n",

145 (
uöçå_t
)
pc
,Öc->
¨øy_chunk_magic
,

146 
pc
->
¨øy_chunk_hódî
);

148 
	`ö£πAºayFªeChunk
(
s
, &(s->
um¨hóp
), 
pchunk
);

152 
	`f‹óchObj±rInObje˘
(
s
, (
poöãr
Ë
cuºítSèck
, 
umDfsM¨kObje˘sUnM¨k
, 
FALSE
);

153 
	`f‹óchGlobÆObj±r
 (
s
, 
umDfsM¨kObje˘sUnM¨k
);

154 
	}
}

156 
≥rf‹mGC
 (
GC_°©e
 
s
,

157 
size_t
 
ﬁdGíByãsReque°ed
,

158 
size_t
 
nur£ryByãsReque°ed
,

159 
boﬁ
 
f‹˚Maj‹
,

160 
__©åibuã__
 ((
unu£d
)Ë
boﬁ
 
mayResize
) {

161 
uötmax_t
 
	ggcTime
;

162 
boﬁ
 
	g°ackT›Ok
;

163 
size_t
 
	g°ackByãsReque°ed
;

164 
rußge
 
	gru_°¨t
;

165 
size_t
 
	gtŸÆByãsReque°ed
;

172 i‡(
	gs
->
	ggc_moduÀ
 =
GC_NONE
) {

176 
íãrGC
 (
s
);

177 
	gs
->
	gcumuœtiveSèti°ics
.
	gnumGCs
++;

178 i‡(
DEBUG
 
‹
 
	gs
->
	gc⁄åﬁs
.
	gmesßges
) {

179 
size_t
 
	gnur£rySize
 = 
s
->
hóp
.
size
 - ((size_t)(s->hóp.
nur£ry
 - s->hóp.
°¨t
));

180 
size_t
 
	gnur£ryU£d
 = (size_t)(
s
->
‰⁄tõr
 - s->
hóp
.
nur£ry
);

181 
Ârötf
 (
°dîr
,

183 
uötmaxToCommaSåög
(
s
->
cumuœtiveSèti°ics
.
numGCs
),

184 
uötmaxToCommaSåög
(
nur£ryByãsReque°ed
),

185 
uötmaxToCommaSåög
(
ﬁdGíByãsReque°ed
));

186 
Ârötf
 (
°dîr
,

187 "[GC:\thó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map),]\n",

188 (
uöçå_t
)(
s
->
hóp
.
°¨t
),

189 
uötmaxToCommaSåög
(
s
->
hóp
.
size
),

190 
uötmaxToCommaSåög
(
s
->
hóp
.
wôhM≠sSize
 - s->hóp.
size
));

191 
Ârötf
 (
°dîr
,

193 
uötmaxToCommaSåög
(
s
->
hóp
.
ﬁdGíSize
),

194 100.0 * (()(
s
->
hóp
.
ﬁdGíSize
Ë/ ()(s->hóp.
size
)));

195 
Ârötf
 (
°dîr
,

197 
uötmaxToCommaSåög
(
nur£rySize
),

198 100.0 * (()(
nur£rySize
Ë/ ()(
s
->
hóp
.
size
)));

199 
Ârötf
 (
°dîr
,

201 
uötmaxToCommaSåög
(
nur£ryU£d
),

202 100.0 * (()(
nur£ryU£d
Ë/ ()(
s
->
hóp
.
size
)),

203 100.0 * (()(
nur£ryU£d
Ë/ ()(
nur£rySize
)));

205 
as£π
 (
öv¨ü¡F‹GC
 (
s
));

206 i‡(
√edGCTime
 (
s
))

207 
°¨tTimög
 (&
ru_°¨t
);

209 
	g°ackT›Ok
 = 
öv¨ü¡F‹Muèt‹Sèck
 (
s
);

210 
	g°ackByãsReque°ed
 =

211 
°ackT›Ok


213 : 
sizeofSèckWôhHódî
 (
s
, 
sizeofSèckGrowRe£rved
 (s, 
gëSèckCuºít
 (s)));

214 
	gtŸÆByãsReque°ed
 =

215 
ﬁdGíByãsReque°ed


216 + 
nur£ryByãsReque°ed


217 + 
°ackByãsReque°ed
;

218 i‡(
f‹˚Maj‹


219 
‹
 
	gtŸÆByãsReque°ed
 > 
	gs
->
	ghóp
.
	gsize
 - s->hóp.
	gﬁdGíSize
) {

221 
≥rf‹mUMGC
(
s
);

224 
£tGCSèãCuºítHóp
 (
s
, 
ﬁdGíByãsReque°ed
 + 
°ackByãsReque°ed
,

225 
nur£ryByãsReque°ed
);

226 
as£π
 (
hasHópByãsFªe
 (
s
, 
ﬁdGíByãsReque°ed
 + 
°ackByãsReque°ed
,

227 
nur£ryByãsReque°ed
));

228 
u∆ess
 (
°ackT›Ok
)

229 
growSèckCuºít
 (
s
);

230 
£tGCSèãCuºítThªadAndSèck
 (
s
);

231 i‡(
√edGCTime
 (
s
)) {

232 
	ggcTime
 = 
°›Timög
 (&
ru_°¨t
, &
s
->
cumuœtiveSèti°ics
.
ru_gc
);

233 
	gs
->
	gcumuœtiveSèti°ics
.
	gmaxPau£Time
 =

234 
max
 (
s
->
cumuœtiveSèti°ics
.
maxPau£Time
, 
gcTime
);

236 
	ggcTime
 = 0;

237 i‡(
DEBUG
 
‹
 
	gs
->
	gc⁄åﬁs
.
	gmesßges
) {

238 
size_t
 
	gnur£rySize
 = 
s
->
hóp
.
size
 - (size_t)(s->hóp.
nur£ry
 - s->hóp.
°¨t
);

239 
Ârötf
 (
°dîr
,

241 
uötmaxToCommaSåög
(
s
->
cumuœtiveSèti°ics
.
numGCs
),

242 
uötmaxToCommaSåög
(
gcTime
));

243 
Ârötf
 (
°dîr
,

244 "[GC:\thó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map),]\n",

245 (
uöçå_t
)(
s
->
hóp
.
°¨t
),

246 
uötmaxToCommaSåög
(
s
->
hóp
.
size
),

247 
uötmaxToCommaSåög
(
s
->
hóp
.
wôhM≠sSize
 - s->hóp.
size
));

248 
Ârötf
 (
°dîr
,

250 
uötmaxToCommaSåög
(
s
->
hóp
.
ﬁdGíSize
),

251 100.0 * (()(
s
->
hóp
.
ﬁdGíSize
Ë/ ()(s->hóp.
size
)));

252 
Ârötf
 (
°dîr
,

254 
uötmaxToCommaSåög
(
nur£rySize
),

255 100.0 * (()(
nur£rySize
Ë/ ()(
s
->
hóp
.
size
)));

258 i‡(
	gs
->
	gsig«lsInfo
.
gcSig«lH™dÀd


259 
™d
 
	gs
->
	gsig«lH™dÀrThªad
 !
BOGUS_OBJPTR
) {

260 i‡(
DEBUG_SIGNALS
)

261 
Ârötf
 (
°dîr
, "GC SignalÖending.\n");

262 
	gs
->
	gsig«lsInfo
.
	ggcSig«lPídög
 = 
TRUE
;

263 
u∆ess
 (
s
->
sig«lsInfo
.
amInSig«lH™dÀr
)

264 
	gs
->
	gsig«lsInfo
.
	gsig«lIsPídög
 = 
TRUE
;

266 i‡(
	gDEBUG
)

267 
di•œyGCSèã
 (
s
, 
°dîr
);

268 
as£π
 (
hasHópByãsFªe
 (
s
, 
ﬁdGíByãsReque°ed
, 
nur£ryByãsReque°ed
));

269 
as£π
 (
öv¨ü¡F‹GC
 (
s
));

270 
ÀaveGC
 (
s
);

274 
	$ísuªInv¨ü¡F‹Muèt‹
 (
GC_°©e
 
s
, 
boﬁ
 
f‹˚
) {

275 i‡(
f‹˚


276 
‹
 
	`nŸ
 (
	`öv¨ü¡F‹Muèt‹Fr⁄tõr
(
s
))

277 
‹
 
	`nŸ
 (
	`öv¨ü¡F‹Muèt‹Sèck
(
s
))

278 
	`‹
 (
s
->
umhóp
.
Ê_chunks
 <= 2000)

279 
	`‹
 (
s
->
um¨hóp
.
Ê_¨øy_chunks
 <= 2000))

285 i‡((
s
->
umhóp
.
Ê_chunks
 <2000Ë
‹


286 (
s
->
um¨hóp
.
Ê_¨øy_chunks
 <= 2000)) {

287 
f‹˚
 = 
åue
;

289 #ifde‡
PROFILE_UMGC


290 
°¨t
 = 
	`gëCuºítTime
();

291 
	`Ârötf
(
°dîr
, "[GC] Free chunk: %d, Freeárray chunk: %d\n",

292 
s
->
umhóp
.
Ê_chunks
,

293 
s
->
um¨hóp
.
Ê_¨øy_chunks
);

295 
	`≥rf‹mGC
 (
s
, 0, 
	`gëThªadCuºít
(s)->
byãsNìded
, 
f‹˚
, 
TRUE
);

297 #ifde‡
PROFILE_UMGC


298 
íd
 = 
	`gëCuºítTime
();

299 
	`Ârötf
(
°dîr
, "[GC] Time: %ld, Free chunk: %d, Freeárray chunk: %d\n",

300 
íd
 - 
°¨t
,

301 
s
->
umhóp
.
Ê_chunks
,

302 
s
->
um¨hóp
.
Ê_¨øy_chunks
);

309 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Fr⁄tõr
(
s
));

310 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Sèck
(
s
));

311 
	}
}

315 
	$ísuªHasHópByãsFªe
 (
GC_°©e
 
s
,

316 
size_t
 
ﬁdGíByãsReque°ed
,

317 
size_t
 
nur£ryByãsReque°ed
) {

318 
	`as£π
 (
s
->
hóp
.
nur£ry
 <s->
limôPlusSl›
);

319 
	`as£π
 (
s
->
‰⁄tõr
 <s->
limôPlusSl›
);

320 i‡(
nŸ
 
	`hasHópByãsFªe
 (
s
, 
ﬁdGíByãsReque°ed
, 
nur£ryByãsReque°ed
))

321 
	`≥rf‹mGC
 (
s
, 
ﬁdGíByãsReque°ed
, 
nur£ryByãsReque°ed
, 
FALSE
, 
TRUE
);

322 
	`as£π
 (
	`hasHópByãsFªe
 (
s
, 
ﬁdGíByãsReque°ed
, 
nur£ryByãsReque°ed
));

323 
	}
}

325 
	$GC_cﬁÀ˘_ªÆ
(
GC_°©e
 
s
, 
size_t
 
byãsReque°ed
, 
boﬁ
 
f‹˚
) {

326 
	`íãr
 (
s
);

330 i‡(0 =
byãsReque°ed
)

331 
byãsReque°ed
 = 
GC_HEAP_LIMIT_SLOP
;

332 
	`gëThªadCuºít
(
s
)->
byãsNìded
 = 
byãsReque°ed
;

333 
	`swôchToSig«lH™dÀrThªadIfN⁄AtomicAndSig«lPídög
 (
s
);

334 
	`ísuªInv¨ü¡F‹Muèt‹
 (
s
, 
f‹˚
);

335 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Fr⁄tõr
(
s
));

336 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Sèck
(
s
));

337 
	`Àave
 (
s
);

339 i‡(
DEBUG_MEM
) {

340 
	`Ârötf
(
°dîr
, "GC_collect done\n");

342 
	}
}

344 
ölöe
 
	$GC_cﬁÀ˘
 (
GC_°©e
 
s
, 
size_t
 
byãsReque°ed
, 
boﬁ
 
f‹˚
) {

345 i‡((
s
->
umhóp
.
Ê_chunks
 > 2000) &&

346 (
s
->
um¨hóp
.
Ê_¨øy_chunks
 > 2000))

349 i‡(
s
->
gc_moduÀ
 =
GC_NONE
) {

353 
	`GC_cﬁÀ˘_ªÆ
(
s
, 
byãsReque°ed
, 
f‹˚
);

354 
	}
}

	@garbage-collection.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

12 
mö‹GC
 (
GC_°©e
 
s
);

13 
maj‹GC
 (
GC_°©e
 
s
, 
size_t
 
byãsReque°ed
, 
boﬁ
 
mayResize
);

14 
ölöe
 
growSèckCuºít
 (
GC_°©e
 
s
);

15 
ölöe
 
íãrGC
 (
GC_°©e
 
s
);

16 
ölöe
 
ÀaveGC
 (
GC_°©e
 
s
);

17 
≥rf‹mGC
 (
GC_°©e
 
s
,

18 
size_t
 
ﬁdGíByãsReque°ed
,

19 
size_t
 
nur£ryByãsReque°ed
,

20 
boﬁ
 
f‹˚Maj‹
,

21 
boﬁ
 
mayResize
);

22 
≥rf‹mUMGC
(
GC_°©e
 
s
);

23 
ölöe
 
ísuªInv¨ü¡F‹Muèt‹
 (
GC_°©e
 
s
, 
boﬁ
 
f‹˚
);

24 
ölöe
 
ísuªHasHópByãsFªe
 (
GC_°©e
 
s
,

25 
size_t
 
ﬁdGíByãsReque°ed
,

26 
size_t
 
nur£ryByãsReque°ed
);

30 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

32 
PRIVATE
 
GC_cﬁÀ˘
 (
GC_°©e
 
s
, 
size_t
 
byãsReque°ed
, 
boﬁ
 
f‹˚
);

	@gc_state.c

10 
	$di•œyGCSèã
 (
GC_°©e
 
s
, 
FILE
 *
°ªam
) {

11 
	`Ârötf
 (
°ªam
,

13 
	`Ârötf
 (
°ªam
, "\tcuºítThªad = "
FMTOBJPTR
"\n", 
s
->
cuºítThªad
);

14 
	`di•œyThªad
 (
s
, (
GC_thªad
)(
	`obj±rToPoöãr
 (s->
cuºítThªad
, s->
hóp
.
°¨t
)

15 + 
	`off£tofThªad
 (
s
)),

16 
°ªam
);

17 
	`Ârötf
 (
°ªam
, "\tgenerational\n");

18 
	`di•œyGíî©i⁄ÆM≠s
 (
s
, &s->
gíî©i⁄ÆM≠s
,

19 
°ªam
);

20 
	`Ârötf
 (
°ªam
, "\theap\n");

21 
	`di•œyHóp
 (
s
, &s->
hóp
,

22 
°ªam
);

23 
	`Ârötf
 (
°ªam
,

24 "\éimô = "
FMTPTR
"\n"

25 "\t°ackBŸtom = "
FMTPTR
"\n"

26 "\t°ackT› = "
FMTPTR
"\n",

27 (
uöçå_t
)
s
->
limô
,

28 (
uöçå_t
)
s
->
°ackBŸtom
,

29 (
uöçå_t
)
s
->
°ackT›
);

30 
	}
}

32 
size_t
 
	$sizeofGCSèãCuºítSèckU£d
 (
GC_°©e
 
s
) {

33  (
size_t
)(
s
->
°ackT›
 - s->
°ackBŸtom
);

34 
	}
}

36 
	$£tGCSèãCuºítThªadAndSèck
 (
GC_°©e
 
s
) {

37 
GC_thªad
 
thªad
;

38 
GC_°ack
 
°ack
;

40 
thªad
 = 
	`gëThªadCuºít
 (
s
);

41 
s
->
exnSèck
 = 
thªad
->exnStack;

42 
°ack
 = 
	`gëSèckCuºít
 (
s
);

43 
s
->
°ackBŸtom
 = 
	`gëSèckBŸtom
 (s, 
°ack
);

44 
s
->
°ackT›
 = 
	`gëSèckT›
 (s, 
°ack
);

45 
s
->
°ackLimô
 = 
	`gëSèckLimô
 (s, 
°ack
);

46 
	`m¨kC¨d
 (
s
, (
poöãr
)
°ack
);

47 
	}
}

49 
	$£tGCSèãCuºítHóp
 (
GC_°©e
 
s
,

50 
size_t
 
ﬁdGíByãsReque°ed
,

51 
size_t
 
nur£ryByãsReque°ed
) {

52 
GC_hóp
 
h
;

53 
poöãr
 
nur£ry
;

54 
size_t
 
nur£rySize
;

55 
poöãr
 
gíNur£ry
;

56 
size_t
 
gíNur£rySize
;

58 i‡(
DEBUG_DETAILED
)

59 
	`Ârötf
 (
°dîr
, "setGCStateCurrentHeap(%s, %s)\n",

60 
	`uötmaxToCommaSåög
(
ﬁdGíByãsReque°ed
),

61 
	`uötmaxToCommaSåög
(
nur£ryByãsReque°ed
));

62 
h
 = &
s
->
hóp
;

63 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, 
h
->
°¨t
 + h->
ﬁdGíSize
 + 
ﬁdGíByãsReque°ed
));

64 
s
->
limôPlusSl›
 = 
h
->
°¨t
 + h->
size
;

65 
s
->
limô
 = s->
limôPlusSl›
 - 
GC_HEAP_LIMIT_SLOP
;

66 
nur£rySize
 = 
h
->
size
 - (h->
ﬁdGíSize
 + 
ﬁdGíByãsReque°ed
);

67 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, s->
limôPlusSl›
 - 
nur£rySize
));

68 
nur£ry
 = 
s
->
limôPlusSl›
 - 
nur£rySize
;

69 
gíNur£ry
 = 
	`ÆignFr⁄tõr
 (
s
, s->
limôPlusSl›
 - (
nur£rySize
 / 2));

70 
gíNur£rySize
 = (
size_t
)(
s
->
limôPlusSl›
 - 
gíNur£ry
);

72 
s
->
muèt‹M¨ksC¨ds


74 
	`™d
 (
nur£ryByãsReque°ed
 <
gíNur£rySize
)

76 
	`™d
 ((()(
h
->
size
 - 
s
->
œ°Maj‹Sèti°ics
.
byãsLive
)

77 / ()
nur£rySize
)

78 <
s
->
c⁄åﬁs
.
øtios
.
nur£ry
)

79 
™d


82 
FORCE_GENERATIONAL


84 
	`‹
 (
s
->
œ°Maj‹Sèti°ics
.
köd
 =
GC_MARK_COMPACT
)

86 
	`‹
 (()
h
->
size
 / ()
s
->
œ°Maj‹Sèti°ics
.
byãsLive


87 <(
h
->
wôhM≠sSize
 < 
s
->
sysvÆs
.
øm


88 ? 
s
->
c⁄åﬁs
.
øtios
.
c›yGíî©i⁄Æ


89 : 
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘Gíî©i⁄Æ
))

91 
s
->
ˇnMö‹
 = 
TRUE
;

92 
nur£ry
 = 
gíNur£ry
;

93 
nur£rySize
 = 
gíNur£rySize
;

94 
	`˛órC¨dM≠
 (
s
);

96 
	`u∆ess
 (
nur£ryByãsReque°ed
 <
nur£rySize
)

97 
	`dõ
 ("Out of memory. Insufficient space inÇursery.");

98 
s
->
ˇnMö‹
 = 
FALSE
;

100 
	`as£π
 (
nur£ryByãsReque°ed
 <
nur£rySize
);

101 
s
->
hóp
.
nur£ry
 =Çursery;

102 
s
->
‰⁄tõr
 = 
nur£ry
;

103 
	`as£π
 (
nur£ryByãsReque°ed
 <(
size_t
)(
s
->
limôPlusSl›
 - s->
‰⁄tõr
));

104 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, s->
hóp
.
nur£ry
));

105 
	`as£π
 (
	`hasHópByãsFªe
 (
s
, 
ﬁdGíByãsReque°ed
, 
nur£ryByãsReque°ed
));

106 
	}
}

108 
boﬁ
 
	$GC_gëAmOrigöÆ
 (
GC_°©e
 
s
) {

109  
s
->
amOrigöÆ
;

110 
	}
}

111 
	$GC_£tAmOrigöÆ
 (
GC_°©e
 
s
, 
boﬁ
 
b
) {

112 
s
->
amOrigöÆ
 = 
b
;

113 
	}
}

115 
	$GC_£tC⁄åﬁsMesßges
 (
GC_°©e
 
s
, 
boﬁ
 
b
) {

116 
s
->
c⁄åﬁs
.
mesßges
 = 
b
;

117 
	}
}

119 
	$GC_£tC⁄åﬁsSumm¨y
 (
GC_°©e
 
s
, 
boﬁ
 
b
) {

120 
s
->
c⁄åﬁs
.
summ¨y
 = 
b
;

121 
	}
}

123 
	$GC_£tC⁄åﬁsRußgeMósuªGC
 (
GC_°©e
 
s
, 
boﬁ
 
b
) {

124 
s
->
c⁄åﬁs
.
rußgeMósuªGC
 = 
b
;

125 
	}
}

127 
uötmax_t
 
	$GC_gëCumuœtiveSèti°icsByãsAŒoˇãd
 (
GC_°©e
 
s
) {

128  
s
->
cumuœtiveSèti°ics
.
byãsAŒoˇãd
;

129 
	}
}

131 
uötmax_t
 
	$GC_gëCumuœtiveSèti°icsNumC›yögGCs
 (
GC_°©e
 
s
) {

132  
s
->
cumuœtiveSèti°ics
.
numC›yögGCs
;

133 
	}
}

135 
uötmax_t
 
	$GC_gëCumuœtiveSèti°icsNumM¨kCom∑˘GCs
 (
GC_°©e
 
s
) {

136  
s
->
cumuœtiveSèti°ics
.
numM¨kCom∑˘GCs
;

137 
	}
}

139 
uötmax_t
 
	$GC_gëCumuœtiveSèti°icsNumMö‹GCs
 (
GC_°©e
 
s
) {

140  
s
->
cumuœtiveSèti°ics
.
numMö‹GCs
;

141 
	}
}

143 
size_t
 
	$GC_gëCumuœtiveSèti°icsMaxByãsLive
 (
GC_°©e
 
s
) {

144  
s
->
cumuœtiveSèti°ics
.
maxByãsLive
;

145 
	}
}

147 
	$GC_£tHashC⁄sDurögGC
 (
GC_°©e
 
s
, 
boﬁ
 
b
) {

148 
s
->
hashC⁄sDurögGC
 = 
b
;

149 
	}
}

151 
size_t
 
	$GC_gëLa°Maj‹Sèti°icsByãsLive
 (
GC_°©e
 
s
) {

152  
s
->
œ°Maj‹Sèti°ics
.
byãsLive
;

153 
	}
}

156 
poöãr
 
	$GC_gëCÆlFromCH™dÀrThªad
 (
GC_°©e
 
s
) {

157 
poöãr
 
p
 = 
	`obj±rToPoöãr
 (
s
->
ˇŒFromCH™dÀrThªad
, s->
hóp
.
°¨t
);

158  
p
;

159 
	}
}

161 
	$GC_£tCÆlFromCH™dÀrThªad
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

162 
obj±r
 
›
 = 
	`poöãrToObj±r
 (
p
, 
s
->
hóp
.
°¨t
);

163 
s
->
ˇŒFromCH™dÀrThªad
 = 
›
;

164 
	}
}

166 
poöãr
 
	$GC_gëCuºítThªad
 (
GC_°©e
 
s
) {

167 
poöãr
 
p
 = 
	`obj±rToPoöãr
 (
s
->
cuºítThªad
, s->
hóp
.
°¨t
);

168  
p
;

169 
	}
}

171 
poöãr
 
	$GC_gëSavedThªad
 (
GC_°©e
 
s
) {

172 
poöãr
 
p
;

174 
	`as£π
(
s
->
ßvedThªad
 !
BOGUS_OBJPTR
);

175 
p
 = 
	`obj±rToPoöãr
 (
s
->
ßvedThªad
, s->
hóp
.
°¨t
);

176 
s
->
ßvedThªad
 = 
BOGUS_OBJPTR
;

177  
p
;

178 
	}
}

180 
	$GC_£tSavedThªad
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

181 
obj±r
 
›
;

183 
	`as£π
(
s
->
ßvedThªad
 =
BOGUS_OBJPTR
);

184 
›
 = 
	`poöãrToObj±r
 (
p
, 
s
->
hóp
.
°¨t
);

185 
s
->
ßvedThªad
 = 
›
;

186 
	}
}

188 
	$GC_£tSig«lH™dÀrThªad
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

189 
obj±r
 
›
 = 
	`poöãrToObj±r
 (
p
, 
s
->
hóp
.
°¨t
);

190 
s
->
sig«lH™dÀrThªad
 = 
›
;

191 
	}
}

193 
rußge
* 
	$GC_gëRußgeGCAddr
 (
GC_°©e
 
s
) {

194  &(
s
->
cumuœtiveSèti°ics
.
ru_gc
);

195 
	}
}

197 
sig£t_t
* 
	$GC_gëSig«lsH™dÀdAddr
 (
GC_°©e
 
s
) {

198  &(
s
->
sig«lsInfo
.
sig«lsH™dÀd
);

199 
	}
}

201 
sig£t_t
* 
	$GC_gëSig«lsPídögAddr
 (
GC_°©e
 
s
) {

202  &(
s
->
sig«lsInfo
.
sig«lsPídög
);

203 
	}
}

205 
	$GC_£tGCSig«lH™dÀd
 (
GC_°©e
 
s
, 
boﬁ
 
b
) {

206 
s
->
sig«lsInfo
.
gcSig«lH™dÀd
 = 
b
;

207 
	}
}

209 
boﬁ
 
	$GC_gëGCSig«lPídög
 (
GC_°©e
 
s
) {

210  (
s
->
sig«lsInfo
.
gcSig«lPídög
);

211 
	}
}

213 
	$GC_£tGCSig«lPídög
 (
GC_°©e
 
s
, 
boﬁ
 
b
) {

214 
s
->
sig«lsInfo
.
gcSig«lPídög
 = 
b
;

215 
	}
}

	@gc_state.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

14 
	mGC_NONE
,

15 
	mGC_DEFAULT
,

16 
	mGC_UM


17 } 
	tGC_moduÀKöd
;

19 
	sGC_°©e
 {

24 
poöãr
 
	m‰⁄tõr
;

25 
poöãr
 
	mum‰⁄tõr
;

26 
poöãr
 
	mum¨‰⁄tõr
;

27 
poöãr
 
	mlimô
;

28 
poöãr
 
	m°ackT›
;

29 
poöãr
 
	m°ackLimô
;

30 
size_t
 
	mexnSèck
;

32 
size_t
 
	mÆignmít
;

33 
boﬁ
 
	mamInGC
;

34 
boﬁ
 
	mamOrigöÆ
;

35 **
	m©MLt⁄s
;

36 
	m©MLt⁄sLígth
;

37 
uöt32_t
 
	m©omicSèã
;

38 
obj±r
 
	mˇŒFromCH™dÀrThªad
;

39 
GC_ˇŒSèckSèã
 
	mˇŒSèckSèã
;

40 
boﬁ
 
	mˇnMö‹
;

41 
GC_c⁄åﬁs
 
	mc⁄åﬁs
;

42 
GC_cumuœtiveSèti°ics
 
	mcumuœtiveSèti°ics
;

43 
obj±r
 
	mcuºítThªad
;

44 
GC_f‹w¨dSèã
 
	mf‹w¨dSèã
;

45 
GC_‰ameLayout
 
	m‰ameLayouts
;

46 
uöt32_t
 
	m‰ameLayoutsLígth
;

47 
GC_gíî©i⁄ÆM≠s
 
	mgíî©i⁄ÆM≠s
;

48 
obj±r
 *
	mglobÆs
;

49 
uöt32_t
 
	mglobÆsLígth
;

50 
boﬁ
 
	mhashC⁄sDurögGC
;

51 
GC_hóp
 
	mhóp
;

52 
GC_UM_hóp
 
	mumhóp
;

53 
GC_UM_Aºay_hóp
 
	mum¨hóp
;

54 
GC_œ°Maj‹Sèti°ics
 
	mœ°Maj‹Sèti°ics
;

55 
poöãr
 
	mlimôPlusSl›
;

56 (*
	mlﬂdGlobÆs
)(
FILE
 *
	mf
);

57 
uöt32_t
 
	mmagic
;

58 
uöt32_t
 
	mmaxFømeSize
;

59 
boﬁ
 
	mmuèt‹M¨ksC¨ds
;

60 
GC_obje˘HashTabÀ
 
	mobje˘HashTabÀ
;

61 
GC_obje˘Ty≥
 
	mobje˘Ty≥s
;

62 
uöt32_t
 
	mobje˘Ty≥sLígth
;

63 
GC_¥ofûög
 
	m¥ofûög
;

64 
GC_‰ameIndex
 (*
ªtu∫AddªssToFømeIndex
Ë(
GC_ªtu∫Addªss
 
	mø
);

65 
obj±r
 
	mßvedThªad
;

68 (*
	mßveGlobÆs
)(
FILE
 *
	mf
);

69 
boﬁ
 
	mßveW‹ldSètus
;

70 
GC_hóp
 
	m£c⁄d¨yHóp
;

71 
obj±r
 
	msig«lH™dÀrThªad
;

72 
GC_sig«lsInfo
 
	msig«lsInfo
;

73 
GC_sour˚M≠s
 
	msour˚M≠s
;

74 
poöãr
 
	m°ackBŸtom
;

75 
GC_sysvÆs
 
	msysvÆs
;

76 
GC_å™¶©eSèã
 
	må™¶©eSèã
;

77 
GC_ve˘‹Inô
 *
	mve˘‹Inôs
;

78 
uöt32_t
 
	mve˘‹InôsLígth
;

79 
GC_wók
 
	mwóks
;

80 
GC_moduÀKöd
 
	mgc_moduÀ
;

85 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

87 
di•œyGCSèã
 (
GC_°©e
 
s
, 
FILE
 *
°ªam
);

89 
ölöe
 
size_t
 
sizeofGCSèãCuºítSèckU£d
 (
GC_°©e
 
s
);

90 
ölöe
 
£tGCSèãCuºítThªadAndSèck
 (
GC_°©e
 
s
);

91 
£tGCSèãCuºítHóp
 (
GC_°©e
 
s
,

92 
size_t
 
ﬁdGíByãsReque°ed
,

93 
size_t
 
nur£ryByãsReque°ed
);

97 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

99 
PRIVATE
 
boﬁ
 
GC_gëAmOrigöÆ
 (
GC_°©e
 
s
);

100 
PRIVATE
 
GC_£tAmOrigöÆ
 (
GC_°©e
 
s
, 
boﬁ
 
b
);

101 
PRIVATE
 
GC_£tC⁄åﬁsMesßges
 (
GC_°©e
 
s
, 
boﬁ
 
b
);

102 
PRIVATE
 
GC_£tC⁄åﬁsSumm¨y
 (
GC_°©e
 
s
, 
boﬁ
 
b
);

103 
PRIVATE
 
GC_£tC⁄åﬁsRußgeMósuªGC
 (
GC_°©e
 
s
, 
boﬁ
 
b
);

104 
PRIVATE
 
uötmax_t
 
GC_gëCumuœtiveSèti°icsByãsAŒoˇãd
 (
GC_°©e
 
s
);

105 
PRIVATE
 
uötmax_t
 
GC_gëCumuœtiveSèti°icsNumC›yögGCs
 (
GC_°©e
 
s
);

106 
PRIVATE
 
uötmax_t
 
GC_gëCumuœtiveSèti°icsNumM¨kCom∑˘GCs
 (
GC_°©e
 
s
);

107 
PRIVATE
 
uötmax_t
 
GC_gëCumuœtiveSèti°icsNumMö‹GCs
 (
GC_°©e
 
s
);

108 
PRIVATE
 
size_t
 
GC_gëCumuœtiveSèti°icsMaxByãsLive
 (
GC_°©e
 
s
);

109 
PRIVATE
 
GC_£tHashC⁄sDurögGC
 (
GC_°©e
 
s
, 
boﬁ
 
b
);

110 
PRIVATE
 
size_t
 
GC_gëLa°Maj‹Sèti°icsByãsLive
 (
GC_°©e
 
s
);

112 
PRIVATE
 
poöãr
 
GC_gëCÆlFromCH™dÀrThªad
 (
GC_°©e
 
s
);

113 
PRIVATE
 
GC_£tCÆlFromCH™dÀrThªad
 (
GC_°©e
 
s
, 
poöãr
 
p
);

114 
PRIVATE
 
poöãr
 
GC_gëCuºítThªad
 (
GC_°©e
 
s
);

115 
PRIVATE
 
poöãr
 
GC_gëSavedThªad
 (
GC_°©e
 
s
);

116 
PRIVATE
 
GC_£tSavedThªad
 (
GC_°©e
 
s
, 
poöãr
 
p
);

117 
PRIVATE
 
GC_£tSig«lH™dÀrThªad
 (
GC_°©e
 
s
, 
poöãr
 
p
);

121 
PRIVATE
 
rußge
* 
GC_gëRußgeGCAddr
 (
GC_°©e
 
s
);

123 
PRIVATE
 
sig£t_t
* 
GC_gëSig«lsH™dÀdAddr
 (
GC_°©e
 
s
);

124 
PRIVATE
 
sig£t_t
* 
GC_gëSig«lsPídögAddr
 (
GC_°©e
 
s
);

125 
PRIVATE
 
GC_£tGCSig«lH™dÀd
 (
GC_°©e
 
s
, 
boﬁ
 
b
);

126 
PRIVATE
 
boﬁ
 
GC_gëGCSig«lPídög
 (
GC_°©e
 
s
);

127 
PRIVATE
 
GC_£tGCSig«lPídög
 (
GC_°©e
 
s
, 
boﬁ
 
b
);

	@generational.c

10 
di•œyGíî©i⁄ÆM≠s
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

11 
GC_gíî©i⁄ÆM≠s
 *
gíî©i⁄Æ
,

12 
FILE
 *
°ªam
) {

13 
Ârötf
(
°ªam
,

14 "\t\tˇrdM≠ = "
FMTPTR
"\n"

15 "\t\tˇrdM≠Absﬁuã = "
FMTPTR
"\n"

16 "\t\tˇrdM≠Lígth = %"
PRIuMAX
"\n"

17 "\t\t¸ossM≠ = "
FMTPTR
"\n"

18 "\t\t¸ossM≠Lígth = %"
PRIuMAX
"\n"

19 "\t\t¸ossM≠VÆidSizê%"
PRIuMAX
"\n",

20 (
uöçå_t
)
gíî©i⁄Æ
->
ˇrdM≠
,

21 (
uöçå_t
)
gíî©i⁄Æ
->
ˇrdM≠Absﬁuã
,

22 (
uötmax_t
)
gíî©i⁄Æ
->
ˇrdM≠Lígth
,

23 (
uöçå_t
)
gíî©i⁄Æ
->
¸ossM≠
,

24 (
uötmax_t
)
gíî©i⁄Æ
->
¸ossM≠Lígth
,

25 (
uötmax_t
)
gíî©i⁄Æ
->
¸ossM≠VÆidSize
);

26 i‡(
DEBUG_GENERATIONAL
 
™d
 
	gDEBUG_DETAILED
) {

27 
GC_¸ossM≠Index
 
	gi
;

29 
Ârötf
 (
°dîr
, "crossMapÅrues\n");

30 
	gi
 = 0; i < 
	ggíî©i⁄Æ
->
	g¸ossM≠Lígth
; i++)

31 
u∆ess
 (
CROSS_MAP_EMPTY
 =
gíî©i⁄Æ
->
¸ossM≠
[
i
])

32 
Ârötf
 (
°dîr
, "\t%"
PRIuMAX
" "
FMTCME
" %"PRIuMAX"\n",

33 (
uötmax_t
)
i
, 
gíî©i⁄Æ
->
¸ossM≠
[i],

34 (
uötmax_t
)(
CROSS_MAP_OFFSET_SCALE
 * 
gíî©i⁄Æ
->
¸ossM≠
[
i
]));

35 
Ârötf
 (
°dîr
, "\n");

39 
GC_ˇrdM≠Index
 
	$sizeToC¨dM≠Index
 (
size_t
 
z
) {

40  (
GC_ˇrdM≠Index
)
z
 >> 
CARD_SIZE_LOG2
;

41 
	}
}

42 
size_t
 
	$ˇrdM≠IndexToSize
 (
GC_ˇrdM≠Index
 
i
) {

43  (
size_t
)
i
 << 
CARD_SIZE_LOG2
;

44 
	}
}

45 
GC_ˇrdM≠Index
 
	$poöãrToC¨dM≠IndexAbsﬁuã
 (
poöãr
 
p
) {

46  (
GC_ˇrdM≠Index
)
p
 >> 
CARD_SIZE_LOG2
;

47 
	}
}

48 
GC_ˇrdM≠EÀm
 *
	$poöãrToC¨dM≠Addr
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

49 
GC_ˇrdM≠EÀm
 *
ªs
;

51 
ªs
 = &
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Absﬁuã
[
	`poöãrToC¨dM≠IndexAbsﬁuã
 (
p
)];

52 i‡(
DEBUG_CARD_MARKING
)

53 
	`Ârötf
 (
°dîr
, "poöãrToC¨dM≠Add∏("
FMTPTR
") = "FMTPTR"\n",

54 (
uöçå_t
)
p
, (uöçå_t)
ªs
);

55  
ªs
;

56 
	}
}

58 
GC_¸ossM≠Index
 
	$sizeToCrossM≠Index
 (
size_t
 
z
) {

59  (
GC_¸ossM≠Index
)
z
 >> 
CARD_SIZE_LOG2
;

60 
	}
}

62 #i‡
ASSERT


63 
boﬁ
 
	$isC¨dM¨ked
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

64  (*
	`poöãrToC¨dM≠Addr
 (
s
, 
p
) != 0x0);

65 
	}
}

68 
	$m¨kC¨d
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

69 i‡(
DEBUG_CARD_MARKING
)

70 
	`Ârötf
 (
°dîr
, "m¨kC¨d ("
FMTPTR
")\n", (
uöçå_t
)
p
);

71 i‡(
s
->
muèt‹M¨ksC¨ds
)

72 *(
	`poöãrToC¨dM≠Addr
 (
s
, 
p
)) = 0x1;

73 
	}
}

75 
	$m¨kI¡îgíî©i⁄ÆPoöãr
 (
GC_°©e
 
s
, 
poöãr
 *
µ
) {

76 i‡(
s
->
muèt‹M¨ksC¨ds


77 
™d
 
	`isPoöãrInOldGí
 (
s
, (
poöãr
)
µ
)

78 
™d
 
	`isPoöãrInNur£ry
 (
s
, *
µ
))

79 
	`m¨kC¨d
 (
s
, (
poöãr
)
µ
);

80 
	}
}

82 
	$m¨kI¡îgíî©i⁄ÆObj±r
 (
GC_°©e
 
s
, 
obj±r
 *
›p
) {

83 i‡(
s
->
muèt‹M¨ksC¨ds


84 
™d
 
	`isPoöãrInOldGí
 (
s
, (
poöãr
)
›p
)

85 
™d
 
	`isObj±rInNur£ry
 (
s
, *
›p
))

86 
	`m¨kC¨d
 (
s
, (
poöãr
)
›p
);

87 
	}
}

89 
	$£tC¨dM≠Absﬁuã
 (
GC_°©e
 
s
) {

90 
	`u∆ess
 (
s
->
muèt‹M¨ksC¨ds
)

96 
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Absﬁuã
 =

97 
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠


98 - 
	`poöãrToC¨dM≠IndexAbsﬁuã
 (
s
->
hóp
.
°¨t
);

99 i‡(
DEBUG_CARD_MARKING
)

100 
	`Ârötf
 (
°dîr
, "£tC¨dM≠Absﬁuã = "
FMTPTR
"\n",

101 (
uöçå_t
)
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Absﬁuã
);

102 
	}
}

104 #i‡
ASSERT


105 
poöãr
 
	$gëCrossM≠C¨dSèπ
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

110 (
p
 =
s
->
hóp
.
°¨t
)

111 ? 
s
->
hóp
.
°¨t


112 : (
p
 - 1Ë- ((
uöçå_t
)’ - 1Ë% 
CARD_SIZE
);

113 
	}
}

116 
size_t
 
	$sizeofC¨dM≠
 (
GC_°©e
 
s
, 
size_t
 
hópSize
) {

117 
	`u∆ess
 (
s
->
muèt‹M¨ksC¨ds
) {

120 
	`as£π
 (
	`isAlig√d
 (
hópSize
, 
CARD_SIZE
));

122 
GC_ˇrdM≠Index
 
ˇrdM≠Lígth
;

123 
size_t
 
ˇrdM≠Size
;

125 
ˇrdM≠Lígth
 = 
	`sizeToC¨dM≠Index
 (
hópSize
);

126 
ˇrdM≠Size
 = 
	`Æign
 (
ˇrdM≠Lígth
 * 
CARD_MAP_ELEM_SIZE
, 
s
->
sysvÆs
.
∑geSize
);

128  
ˇrdM≠Size
;

129 
	}
}

131 
GC_ˇrdM≠Index
 
	$ÀnofC¨dM≠
 (
ARG_USED_FOR_ASSERT
 
GC_°©e
 
s
, 
size_t
 
ˇrdM≠Size
) {

132 
GC_ˇrdM≠Index
 
ˇrdM≠Lígth
;

134 
	`as£π
 (
	`isAlig√d
 (
ˇrdM≠Size
, 
s
->
sysvÆs
.
∑geSize
));

135 
	`as£π
 (
	`isAlig√d
 (
ˇrdM≠Size
, 
CARD_MAP_ELEM_SIZE
));

137 
ˇrdM≠Lígth
 = (
GC_ˇrdM≠Index
)(
ˇrdM≠Size
 / 
CARD_MAP_ELEM_SIZE
);

139  
ˇrdM≠Lígth
;

140 
	}
}

142 
size_t
 
	$sizeofCrossM≠
 (
GC_°©e
 
s
, 
size_t
 
hópSize
) {

143 
	`u∆ess
 (
s
->
muèt‹M¨ksC¨ds
) {

146 
	`as£π
 (
	`isAlig√d
 (
hópSize
, 
CARD_SIZE
));

148 
GC_¸ossM≠Index
 
¸ossM≠Lígth
;

149 
size_t
 
¸ossM≠Size
;

151 
¸ossM≠Lígth
 = 
	`sizeToCrossM≠Index
 (
hópSize
);

152 
¸ossM≠Size
 = 
	`Æign
 (
¸ossM≠Lígth
 * 
CROSS_MAP_ELEM_SIZE
, 
s
->
sysvÆs
.
∑geSize
);

154  
¸ossM≠Size
;

155 
	}
}

157 
GC_¸ossM≠Index
 
	$ÀnofCrossM≠
 (
ARG_USED_FOR_ASSERT
 
GC_°©e
 
s
, 
size_t
 
¸ossM≠Size
) {

158 
GC_¸ossM≠Index
 
¸ossM≠Lígth
;

160 
	`as£π
 (
	`isAlig√d
 (
¸ossM≠Size
, 
s
->
sysvÆs
.
∑geSize
));

161 
	`as£π
 (
	`isAlig√d
 (
¸ossM≠Size
, 
CROSS_MAP_ELEM_SIZE
));

163 
¸ossM≠Lígth
 = (
GC_¸ossM≠Index
)(
¸ossM≠Size
 / 
CROSS_MAP_ELEM_SIZE
);

165  
¸ossM≠Lígth
;

166 
	}
}

168 
	$˛órC¨dM≠
 (
GC_°©e
 
s
) {

169 i‡(
DEBUG_GENERATIONAL
 
™d
 
DEBUG_DETAILED
)

170 
	`Ârötf
 (
°dîr
, "clearCardMap ()\n");

171 
	`mem£t
 (
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠
, 0,

172 
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Lígth
 * 
CARD_MAP_ELEM_SIZE
);

173 
	}
}

175 
	$˛órCrossM≠
 (
GC_°©e
 
s
) {

176 i‡(
DEBUG_GENERATIONAL
 
™d
 
DEBUG_DETAILED
)

177 
	`Ârötf
 (
°dîr
, "clearCrossMap ()\n");

178 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠VÆidSize
 = 0;

179 
	`mem£t
 (
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠
, 
CROSS_MAP_EMPTY
,

180 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠Lígth
 * 
CROSS_MAP_ELEM_SIZE
);

181 
	}
}

183 
	$˛órC¨dM≠AndCrossM≠
 (
GC_°©e
 
s
) {

184 
	`˛órC¨dM≠
 (
s
);

185 
	`˛órCrossM≠
 (
s
);

186 
	}
}

188 
size_t
 
	$sizeofC¨dM≠AndCrossM≠
 (
GC_°©e
 
s
, 
size_t
 
hópSize
) {

189 
size_t
 
tŸÆM≠Size
;

191 
tŸÆM≠Size
 = 
	`sizeofC¨dM≠
 (
s
, 
hópSize
Ë+ 
	`sizeofCrossM≠
 (s, heapSize);

193 
	`as£π
 (
	`isAlig√d
 (
tŸÆM≠Size
, 
s
->
sysvÆs
.
∑geSize
));

195  
tŸÆM≠Size
;

196 
	}
}

206 
size_t
 
	$övîtSizeofC¨dM≠AndCrossM≠
 (
GC_°©e
 
s
, 
size_t
 
hópWôhM≠sSize
) {

207 
	`u∆ess
 (
s
->
muèt‹M¨ksC¨ds
) {

208  
hópWôhM≠sSize
;

210 
	`as£π
 (
	`isAlig√d
 (
hópWôhM≠sSize
, 
s
->
sysvÆs
.
∑geSize
));

212 
size_t
 
möHópSize
;

213 i‡(
hópWôhM≠sSize
 <3 * 
s
->
sysvÆs
.
∑geSize
) {

214 
möHópSize
 = 0;

216 
möHópSizeD
;

217 
möHópSizeD
 =

218 ((()(
CARD_SIZE
)

219 / ()(
CARD_SIZE
 + 
CARD_MAP_ELEM_SIZE
 + 
CROSS_MAP_ELEM_SIZE
))

220 * ()(
hópWôhM≠sSize
 - 3 * 
s
->
sysvÆs
.
∑geSize
)) -

221 ((()(
CARD_MAP_ELEM_SIZE
 + 
CROSS_MAP_ELEM_SIZE
)

222 / ()(
CARD_SIZE
 + 
CARD_MAP_ELEM_SIZE
 + 
CROSS_MAP_ELEM_SIZE
)) *

223 ()(
s
->
sysvÆs
.
∑geSize
));

224 
möHópSize
 = 
	`ÆignDown
 ((
size_t
)
möHópSizeD
, 
s
->
sysvÆs
.
∑geSize
);

227 
size_t
 
hópSize
 = 
möHópSize
;

228 
size_t
 
√xtHópSize
 = 
hópSize
 + 
s
->
sysvÆs
.
∑geSize
;

233 
hópWôhM≠sSize
 >
	`sizeofC¨dM≠AndCrossM≠
 (
s
, 
√xtHópSize
Ë
™d


234 
hópWôhM≠sSize
 - 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, 
√xtHópSize
) >=ÇextHeapSize) {

235 
hópSize
 = 
√xtHópSize
;

236 
√xtHópSize
 +
s
->
sysvÆs
.
∑geSize
;

239 
	`as£π
 (
	`isAlig√d
 (
hópSize
, 
s
->
sysvÆs
.
∑geSize
));

240 
	`as£π
 (
hópSize
 + 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, hópSizeË<
hópWôhM≠sSize
);

241 
	`as£π
 (
√xtHópSize
 =
hópSize
 + 
s
->
sysvÆs
.
∑geSize
);

242 
	`as£π
 (
hópWôhM≠sSize
 < 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, 
√xtHópSize
Ë
‹


243 
hópWôhM≠sSize
 - 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, 
√xtHópSize
) <ÇextHeapSize);

245 i‡(
DEBUG_DETAILED
)

246 
	`Ârötf
 (
°dîr
, "invertSizeofCardMapAndCrossMap(%s) = %s\n",

247 
	`uötmaxToCommaSåög
(
hópWôhM≠sSize
),

248 
	`uötmaxToCommaSåög
(
hópSize
));

250  
hópSize
;

251 
	}
}

253 
	$£tC¨dM≠AndCrossM≠
 (
GC_°©e
 
s
) {

254 
	`u∆ess
 (
s
->
muèt‹M¨ksC¨ds
) {

255 
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Lígth
 = 0;

256 
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠
 = 
NULL
;

257 
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Absﬁuã
 = 
NULL
;

258 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠Lígth
 = 0;

259 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠
 = 
NULL
;

263 
GC_ˇrdM≠Index
 
ˇrdM≠Lígth
;

264 
size_t
 
ˇrdM≠Size
;

265 
GC_¸ossM≠Index
 
¸ossM≠Lígth
;

266 
size_t
 
¸ossM≠Size
;

268 
ˇrdM≠Size
 = 
	`sizeofC¨dM≠
 (
s
, s->
hóp
.
size
);

269 
ˇrdM≠Lígth
 = 
	`ÀnofC¨dM≠
 (
s
, 
ˇrdM≠Size
);

270 
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Lígth
 = cardMapLength;

272 
¸ossM≠Size
 = 
	`sizeofCrossM≠
 (
s
, s->
hóp
.
size
);

273 
¸ossM≠Lígth
 = 
	`ÀnofCrossM≠
 (
s
, 
¸ossM≠Size
);

274 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠Lígth
 = crossMapLength;

277 
	`as£π
 (
s
->
hóp
.
wôhM≠sSize
 =s->hóp.
size
 + 
ˇrdM≠Size
 + 
¸ossM≠Size
);

278 
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠
 =

279 (
GC_ˇrdM≠
Ë(
s
->
hóp
.
°¨t
 + s->hóp.
size
);

280 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠
 =

281 (
GC_¸ossM≠
Ë(
s
->
hóp
.
°¨t
 + s->hóp.
size
 + 
ˇrdM≠Size
);

282 
	`£tC¨dM≠Absﬁuã
 (
s
);

283 
	`˛órC¨dM≠AndCrossM≠
 (
s
);

284 
	}
}

286 #i‡
ASSERT


294 
boﬁ
 
	$isCrossM≠Ok
 (
GC_°©e
 
s
) {

295 
GC_¸ossM≠EÀm
 *
m≠
;

296 
size_t
 
m≠Size
;

298 
poöãr
 
‰⁄t
, 
back
;

299 
GC_ˇrdM≠Index
 
ˇrdIndex
;

300 
poöãr
 
ˇrdSèπ
;

302 i‡(
DEBUG
)

303 
	`Ârötf
 (
°dîr
, "isCrossMapOk ()\n");

304 
m≠Size
 = 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠Lígth
 * 
CROSS_MAP_ELEM_SIZE
;

305 
m≠
 = 
	`GC_mm≠An⁄_ß„
 (
NULL
, 
m≠Size
);

306 
	`mem£t
 (
m≠
, 
CROSS_MAP_EMPTY
, 
m≠Size
);

307 
back
 = 
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
;

308 
‰⁄t
 = 
	`ÆignFr⁄tõr
 (
s
, s->
hóp
.
°¨t
);

309 
lo›Obje˘s
:

310 
	`as£π
 (
‰⁄t
 <
back
);

311 
ˇrdSèπ
 = 
	`gëCrossM≠C¨dSèπ
 (
s
, 
‰⁄t
);

312 
ˇrdIndex
 = 
	`sizeToC¨dM≠Index
 ((
size_t
)(
ˇrdSèπ
 - 
s
->
hóp
.
°¨t
));

313 
m≠
[
ˇrdIndex
] = (
GC_¸ossM≠EÀm
)((
‰⁄t
 - 
ˇrdSèπ
Ë/ 
CROSS_MAP_OFFSET_SCALE
);

314 i‡(
‰⁄t
 < 
back
) {

315 
‰⁄t
 +
	`sizeofObje˘
 (
s
, 
	`adv™˚ToObje˘D©a
 (s, front));

316 
lo›Obje˘s
;

318 
size_t
 
i
 = 0; i < 
ˇrdIndex
; ++i)

319 
	`as£π
 (
m≠
[
i
] =
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠
[i]);

320 
	`GC_ªÀa£
 (
m≠
, 
m≠Size
);

321  
TRUE
;

322 
	}
}

325 
	$upd©eCrossM≠
 (
GC_°©e
 
s
) {

326 
GC_ˇrdM≠Index
 
ˇrdIndex
;

327 
poöãr
 
ˇrdSèπ
, 
ˇrdEnd
;

329 
poöãr
 
√xtObje˘
, 
obje˘Sèπ
;

330 
poöãr
 
ﬁdGíEnd
;

332 i‡(
DEBUG_GENERATIONAL
) {

333 
	`Ârötf
 (
°dîr
, "updateCrossMap starting\n");

334 
	`di•œyGíî©i⁄ÆM≠s
 (
s
, &s->
gíî©i⁄ÆM≠s
, 
°dîr
);

336 
	`as£π
 (
	`isAlig√d
 (
s
->
Æignmít
, 
CROSS_MAP_OFFSET_SCALE
));

337 i‡(
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠VÆidSize
 =s->
hóp
.
ﬁdGíSize
)

338 
d⁄e
;

339 
ﬁdGíEnd
 = 
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
;

340 
obje˘Sèπ
 = 
s
->
hóp
.
°¨t
 + s->
gíî©i⁄ÆM≠s
.
¸ossM≠VÆidSize
;

341 i‡(
obje˘Sèπ
 =
s
->
hóp
.
°¨t
) {

342 
ˇrdIndex
 = 0;

343 
obje˘Sèπ
 = 
	`ÆignFr⁄tõr
 (
s
, objectStart);

345 
ˇrdIndex
 = 
	`sizeToC¨dM≠Index
 ((
size_t
)(
obje˘Sèπ
 - 
s
->
hóp
.
°¨t
) - 1);

346 
ˇrdSèπ
 = 
s
->
hóp
.
°¨t
 + 
	`ˇrdM≠IndexToSize
 (
ˇrdIndex
);

347 
ˇrdEnd
 = 
ˇrdSèπ
 + 
CARD_SIZE
;

348 
lo›Obje˘s
:

349 
	`as£π
 (
obje˘Sèπ
 < 
ﬁdGíEnd
);

350 
	`as£π
 ((
obje˘Sèπ
 =
s
->
hóp
.
°¨t
 
‹
 
ˇrdSèπ
 < objectStart)

351 
™d
 
obje˘Sèπ
 <
ˇrdEnd
);

352 
√xtObje˘
 = 
obje˘Sèπ
 + 
	`sizeofObje˘
 (
s
, 
	`adv™˚ToObje˘D©a
 (s, objectStart));

353 i‡(
DEBUG_GENERATIONAL
) {

354 
	`Ârötf
 (
°dîr
,

356 "\à c¨dIndex = %"
PRIuMAX
"\n"

357 "\à c¨dSèπ = "
FMTPTR
"\n"

358 "\à c¨dEnd = "
FMTPTR
"\n"

359 "\tobje˘Sèπ = "
FMTPTR
"\n"

360 "\à√xtObje˘ = "
FMTPTR
"\n",

361 (
uötmax_t
)
ˇrdIndex
, (
uöçå_t
)
ˇrdSèπ
, (uöçå_t)
ˇrdEnd
,

362 (
uöçå_t
)
obje˘Sèπ
, (uöçå_t)
√xtObje˘
);

364 i‡(
√xtObje˘
 > 
ˇrdEnd
) {

369 
size_t
 
off£t
;

371 
off£t
 = (
size_t
)(
obje˘Sèπ
 - 
ˇrdSèπ
Ë/ 
CROSS_MAP_OFFSET_SCALE
;

372 
	`as£π
 (
off£t
 < 
CROSS_MAP_EMPTY
);

373 i‡(
DEBUG_GENERATIONAL
)

374 
	`Ârötf
 (
°dîr
, "¸ossM≠[%"
PRIuMAX
"] = %"PRIuMAX"\n",

375 (
uötmax_t
)
ˇrdIndex
, (uötmax_t)
off£t
);

376 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠
[
ˇrdIndex
] = (
GC_¸ossM≠EÀm
)
off£t
;

377 
ˇrdIndex
 = 
	`sizeToC¨dM≠Index
 ((
size_t
)(
√xtObje˘
 - 
s
->
hóp
.
°¨t
) - 1);

378 
ˇrdSèπ
 = 
s
->
hóp
.
°¨t
 + 
	`ˇrdM≠IndexToSize
 (
ˇrdIndex
);

379 
ˇrdEnd
 = 
ˇrdSèπ
 + 
CARD_SIZE
;

381 
obje˘Sèπ
 = 
√xtObje˘
;

382 i‡(
obje˘Sèπ
 < 
ﬁdGíEnd
)

383 
lo›Obje˘s
;

384 
	`as£π
 (
obje˘Sèπ
 =
ﬁdGíEnd
);

385 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠
[
ˇrdIndex
] =

386 (
GC_¸ossM≠EÀm
)(
ﬁdGíEnd
 - 
ˇrdSèπ
Ë/ 
CROSS_MAP_OFFSET_SCALE
;

387 
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠VÆidSize
 = s->
hóp
.
ﬁdGíSize
;

388 
d⁄e
:

389 
	`as£π
 (
s
->
gíî©i⁄ÆM≠s
.
¸ossM≠VÆidSize
 =s->
hóp
.
ﬁdGíSize
);

390 
	`as£π
 (
	`isCrossM≠Ok
 (
s
));

391 i‡(
DEBUG_GENERATIONAL
) {

392 
	`Ârötf
 (
°dîr
, "updateCrossMap finished\n");

393 
	`di•œyGíî©i⁄ÆM≠s
 (
s
, &s->
gíî©i⁄ÆM≠s
, 
°dîr
);

395 
	}
}

	@generational.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

13 
	#CARD_SIZE_LOG2
 8

	)

14 
	#CARD_SIZE
 
	`TWOPOWER
(
CARD_SIZE_LOG2
)

	)

16 
uöt8_t
 
	tGC_ˇrdM≠EÀm
;

17 
uöt8_t
 
	tGC_¸ossM≠EÀm
;

19 
GC_ˇrdM≠EÀm
 *
	tGC_ˇrdM≠
;

20 
GC_¸ossM≠EÀm
 *
	tGC_¸ossM≠
;

22 
size_t
 
	tGC_ˇrdM≠Index
;

23 
size_t
 
	tGC_¸ossM≠Index
;

24 
	#CARD_MAP_ELEM_SIZE
 (
GC_ˇrdM≠EÀm
)

	)

25 
	#CROSS_MAP_ELEM_SIZE
 (
GC_¸ossM≠EÀm
)

	)

26 
	#CROSS_MAP_EMPTY
 ((
GC_¸ossM≠EÀm
)255)

	)

27 
	#CROSS_MAP_OFFSET_SCALE
 4

	)

28 
	#FMTCME
 "%"
PRIu8


	)

30 
	sGC_gíî©i⁄ÆM≠s
 {

38 
GC_ˇrdM≠
 
	mˇrdM≠
;

39 
GC_ˇrdM≠
 
	mˇrdM≠Absﬁuã
;

40 
GC_ˇrdM≠Index
 
	mˇrdM≠Lígth
;

47 
GC_¸ossM≠
 
	m¸ossM≠
;

48 
GC_¸ossM≠Index
 
	m¸ossM≠Lígth
;

52 
size_t
 
	m¸ossM≠VÆidSize
;

57 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

59 
di•œyGíî©i⁄ÆM≠s
 (
GC_°©e
 
s
,

60 
GC_gíî©i⁄ÆM≠s
 *
gíî©i⁄Æ
,

61 
FILE
 *
°ªam
);

63 
ölöe
 
GC_ˇrdM≠Index
 
sizeToC¨dM≠Index
 (
size_t
 
z
);

64 
ölöe
 
size_t
 
ˇrdM≠IndexToSize
 (
GC_ˇrdM≠Index
 
i
);

65 
ölöe
 
GC_ˇrdM≠Index
 
poöãrToC¨dM≠IndexAbsﬁuã
 (
poöãr
 
p
);

66 
ölöe
 
GC_ˇrdM≠EÀm
 *
poöãrToC¨dM≠Addr
 (
GC_°©e
 
s
, 
poöãr
 
p
);

68 
ölöe
 
GC_¸ossM≠Index
 
sizeToCrossM≠Index
 (
size_t
 
z
);

70 #i‡
ASSERT


71 
ölöe
 
boﬁ
 
isC¨dM¨ked
 (
GC_°©e
 
s
, 
poöãr
 
p
);

73 
ölöe
 
m¨kC¨d
 (
GC_°©e
 
s
, 
poöãr
 
p
);

74 
ölöe
 
m¨kI¡îgíî©i⁄ÆPoöãr
 (
GC_°©e
 
s
, 
poöãr
 *
µ
);

75 
ölöe
 
m¨kI¡îgíî©i⁄ÆObj±r
 (
GC_°©e
 
s
, 
obj±r
 *
›p
);

77 
ölöe
 
£tC¨dM≠Absﬁuã
 (
GC_°©e
 
s
);

78 #i‡
ASSERT


79 
ölöe
 
poöãr
 
gëCrossM≠C¨dSèπ
 (
GC_°©e
 
s
,Öoöã∏
p
);

82 
ölöe
 
size_t
 
sizeofC¨dM≠
 (
GC_°©e
 
s
, size_à
hópSize
);

83 
ölöe
 
GC_ˇrdM≠Index
 
ÀnofC¨dM≠
 (
GC_°©e
 
s
, 
size_t
 
ˇrdM≠Size
);

84 
ölöe
 
size_t
 
sizeofCrossM≠
 (
GC_°©e
 
s
, size_à
hópSize
);

85 
ölöe
 
GC_¸ossM≠Index
 
ÀnofCrossM≠
 (
GC_°©e
 
s
, 
size_t
 
¸ossM≠Size
);

86 
size_t
 
sizeofC¨dM≠AndCrossM≠
 (
GC_°©e
 
s
, size_à
hópSize
);

87 
size_t
 
övîtSizeofC¨dM≠AndCrossM≠
 (
GC_°©e
 
s
, size_à
hópWôhM≠sSize
);

89 
ölöe
 
˛órC¨dM≠
 (
GC_°©e
 
s
);

90 
ölöe
 
˛órCrossM≠
 (
GC_°©e
 
s
);

91 
ölöe
 
˛órC¨dM≠AndCrossM≠
 (
GC_°©e
 
s
);

92 
£tC¨dM≠AndCrossM≠
 (
GC_°©e
 
s
);

94 #i‡
ASSERT


95 
boﬁ
 
isCrossM≠Ok
 (
GC_°©e
 
s
);

97 
upd©eCrossM≠
 (
GC_°©e
 
s
);

	@handler.c

18 
	$GC_°¨tSig«lH™dÀr
 (
GC_°©e
 
s
) {

20 i‡(
DEBUG_SIGNALS
) {

21 
	`Ârötf
 (
°dîr
, "GC_startSignalHandler\n");

23 
	`as£π
 (
s
->
©omicSèã
 == 1);

24 
	`as£π
 (
s
->
sig«lsInfo
.
sig«lIsPídög
);

25 
s
->
sig«lsInfo
.
sig«lIsPídög
 = 
FALSE
;

26 
s
->
sig«lsInfo
.
amInSig«lH™dÀr
 = 
TRUE
;

27 
	`as£π
 (
s
->
ßvedThªad
 =
BOGUS_OBJPTR
);

28 
s
->
ßvedThªad
 = s->
cuºítThªad
;

35 
s
->
©omicSèã
 = 2;

36 
	}
}

38 
	$GC_föishSig«lH™dÀr
 (
GC_°©e
 
s
) {

39 i‡(
DEBUG_SIGNALS
)

40 
	`Ârötf
 (
°dîr
, "GC_finishSignalHandler ()\n");

41 
	`as£π
 (
s
->
©omicSèã
 == 1);

42 
s
->
sig«lsInfo
.
amInSig«lH™dÀr
 = 
FALSE
;

43 
	}
}

45 
	$swôchToSig«lH™dÀrThªadIfN⁄AtomicAndSig«lPídög
 (
GC_°©e
 
s
) {

46 i‡(
s
->
©omicSèã
 == 1

47 
™d
 
s
->
sig«lsInfo
.
sig«lIsPídög
) {

48 
	`GC_°¨tSig«lH™dÀr
 (
s
);

49 
	`swôchToThªad
 (
s
, s->
sig«lH™dÀrThªad
);

51 
	}
}

59 
	$GC_h™dÀr
 (
GC_°©e
 
s
, 
signum
) {

60 i‡(
DEBUG_SIGNALS
)

61 
	`Ârötf
 (
°dîr
, "GC_h™dÀ∏signum = %d\n", 
signum
);

62 
	`as£π
 (
	`sigismembî
 (&
s
->
sig«lsInfo
.
sig«lsH™dÀd
, 
signum
));

63 i‡(
s
->
©omicSèã
 == 0)

64 
s
->
limô
 = 0;

65 
s
->
sig«lsInfo
.
sig«lIsPídög
 = 
TRUE
;

66 
	`sigadd£t
 (&
s
->
sig«lsInfo
.
sig«lsPídög
, 
signum
);

67 i‡(
DEBUG_SIGNALS
)

68 
	`Ârötf
 (
°dîr
, "GC_handler done\n");

69 
	}
}

	@handler.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
swôchToSig«lH™dÀrThªadIfN⁄AtomicAndSig«lPídög
 (
GC_°©e
 
s
);

15 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

17 
PRIVATE
 
GC_°¨tSig«lH™dÀr
 (
GC_°©e
 
s
);

18 
PRIVATE
 
GC_föishSig«lH™dÀr
 (
GC_°©e
 
s
);

22 
PRIVATE
 
GC_h™dÀr
 (
GC_°©e
 
s
, 
signum
);

	@hash-cons.c

29 
GC_obje˘HashTabÀ
 
	$ÆlocHashTabÀ
 (
GC_°©e
 
s
) {

30 
uöt32_t
 
ñemítsLígthMax
;

31 
poöãr
 
ªgi⁄Sèπ
;

32 
poöãr
 
ªgi⁄End
;

33 
GC_obje˘HashTabÀ
 
t
;

35 
t
 = (
GC_obje˘HashTabÀ
)(
	`mÆloc_ß„
 ((*t)));

37 i‡(
	`nŸ
 (
	`isHópInô
 (&
s
->
£c⁄d¨yHóp
))) {

38 i‡(
DEBUG_SHARE
)

39 
	`Ârötf
 (
°dîr
, "using secondaryHeap\n");

40 
ªgi⁄Sèπ
 = 
s
->
£c⁄d¨yHóp
.
°¨t
;

41 
ªgi⁄End
 = 
s
->
£c⁄d¨yHóp
.
°¨t
 + s->£c⁄d¨yHóp.
size
;

42 } i‡(
s
->
amInGC
 
‹
 
nŸ
 s->
ˇnMö‹
) {

43 i‡(
DEBUG_SHARE
)

44 
	`Ârötf
 (
°dîr
, "usingÉnd of heap\n");

45 
ªgi⁄Sèπ
 = 
s
->
‰⁄tõr
;

46 
ªgi⁄End
 = 
s
->
limôPlusSl›
;

48 i‡(
DEBUG_SHARE
)

49 
	`Ârötf
 (
°dîr
, "using minor space\n");

50 
	`as£π
 (
s
->
ˇnMö‹
);

51 
ªgi⁄Sèπ
 = 
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
;

52 
ªgi⁄End
 = 
s
->
hóp
.
nur£ry
;

54 
ñemítsLígthMax
 = (
uöt32_t
)((
size_t
)(
ªgi⁄End
 - 
ªgi⁄Sèπ
Ë/  (*(
t
->
ñemíts
)));

55 i‡(
DEBUG_SHARE
)

56 
	`Ârötf
 (
°dîr
, "ñemítsLígthMax = %"
PRIu32
"\n", 
ñemítsLígthMax
);

57 
t
->
ñemítsLígthMax
 = 64;

58 
t
->
ñemítsLígthMaxLog2
 = 6;

59 i‡(
ñemítsLígthMax
 < 
t
->elementsLengthMax) {

60 i‡(
DEBUG_SHARE
)

61 
	`Ârötf
 (
°dîr
, "elementsLengthMaxÅoo small -- using calloc\n");

62 
t
->
ñemítsIsInHóp
 = 
FALSE
;

63 
t
->
ñemíts
 =

64 (
GC_obje˘HashEÀmít
 *)

65 (
	`ˇŒoc_ß„
(
t
->
ñemítsLígthMax
, (*—->
ñemíts
))));

67 i‡(
DEBUG_SHARE
)

68 
	`Ârötf
 (
°dîr
, "elementsLengthMax bigÉnough -- using heap\n");

69 
t
->
ñemítsIsInHóp
 = 
TRUE
;

70 
t
->
ñemíts
 = (
GC_obje˘HashEÀmít
*)
ªgi⁄Sèπ
;

73 
t
->
ñemítsLígthMax
 <=ÉlementsLengthMax;

74 
t
->
ñemítsLígthMax
 <<1,Å->
ñemítsLígthMaxLog2
++)

76 
t
->
ñemítsLígthMax
 >>= 1;

77 
t
->
ñemítsLígthMaxLog2
--;

78 
	`as£π
 (
t
->
ñemítsLígthMax
 <=ÉlementsLengthMax);

79 
i
 = 0; i < 
t
->
ñemítsLígthMax
; ++i)

80 
t
->
ñemíts
[
i
].
obje˘
 = 
NULL
;

82 
t
->
ñemítsLígthCur
 = 0;

83 
t
->
mayIn£π
 = 
TRUE
;

84 i‡(
DEBUG_SHARE
) {

85 
	`Ârötf
 (
°dîr
, "elementsIsInHeap = %s\n",

86 
	`boﬁToSåög
 (
t
->
ñemítsIsInHóp
));

87 
	`Ârötf
 (
°dîr
, "ñemítsLígthMax = %"
PRIu32
"\n", 
t
->
ñemítsLígthMax
);

88 
	`Ârötf
 (
°dîr
, 
FMTPTR
" =áŒocHashTabÀ ()\n", (
uöçå_t
)
t
);

90  
t
;

91 
	}
}

93 
	$‰ìHashTabÀ
 (
GC_obje˘HashTabÀ
 
t
) {

94 
	`u∆ess
 (
t
->
ñemítsIsInHóp
)

95 
	`‰ì
 (
t
->
ñemíts
);

96 
	`‰ì
 (
t
);

97 
	}
}

99 
poöãr
 
	$ö£πHashTabÀEÀm
 (
GC_°©e
 
s
,

100 
GC_obje˘HashTabÀ
 
t
,

101 
GC_hash
 
hash
, 
poöãr
 
obje˘
,

102 
poöãr
 
max
, 
boﬁ
 
mightBeThîe
) {

103 
boﬁ
 
öô
 = 
FALSE
;

104 
uöt64_t
 
mu…
;

105 
uöt32_t
 
maxNumProbes
 = 0;

107 
GC_obje˘HashEÀmít
 
e
;

108 
uöt32_t
 
numProbes
;

109 
uöt32_t
 
¥obe
;

110 
uöt32_t
 
¶Ÿ
;

111 *
p1
;

112 *
p2
;

114 i‡(
DEBUG_SHARE
)

115 
	`Ârötf
 (
°dîr
, "ö£πHashTabÀEÀm ("
FMTHASH
", "
FMTPTR
", "FMTPTR", %s)\n",

116 
hash
,

117 (
uöçå_t
)
obje˘
,

118 (
uöçå_t
)
max
,

119 
	`boﬁToSåög
 (
mightBeThîe
));

120 i‡(! 
öô
) {

121 
öô
 = 
TRUE
;

122 
dmu…
 = 
	`Êo‹
 (((
	`sqπ
 (5.0) - 1.0) / 2.0) * ()0x100000000llu);

123 
mu…
 = (
uöt64_t
)
dmu…
;

125 
¶Ÿ
 = (
uöt32_t
)(
mu…
 * (
uöt64_t
)
hash
Ë>> (32 - 
t
->
ñemítsLígthMaxLog2
);

126 
¥obe
 = (1 =
¶Ÿ
 % 2) ? slot : slot - 1;

127 i‡(
DEBUG_SHARE
)

128 
	`Ârötf
 (
°dîr
, "¥obê0x%"
PRIx32
"\n", 
¥obe
);

129 
	`as£π
 (1 =
¥obe
 % 2);

130 
numProbes
 = 0;

131 
look
:

132 i‡(
DEBUG_SHARE
)

133 
	`Ârötf
 (
°dîr
, "¶Ÿ = 0x%"
PRIx32
"\n", 
¶Ÿ
);

134 
	`as£π
 (
¶Ÿ
 < 
t
->
ñemítsLígthMax
);

135 
numProbes
++;

136 
e
 = &
t
->
ñemíts
[
¶Ÿ
];

137 i‡(
NULL
 =
e
->
obje˘
) {

139 
	`u∆ess
 (
t
->
mayIn£π
) {

140 i‡(
DEBUG_SHARE
)

141 
	`Ârötf
 (
°dîr
, "not inserting\n");

142  
obje˘
;

144 
e
->
hash
 = hash;

145 
e
->
obje˘
 = object;

146 
t
->
ñemítsLígthCur
++;

147 i‡(
numProbes
 > 
maxNumProbes
) {

148 
maxNumProbes
 = 
numProbes
;

149 i‡(
DEBUG_SHARE
)

150 
	`Ârötf
 (
°dîr
, "numProbe†%"
PRIu32
"\n", 
numProbes
);

152  
obje˘
;

154 
	`u∆ess
 (
hash
 =
e
->hash) {

155 
lookNext
:

156 
¶Ÿ
 = (¶Ÿ + 
¥obe
Ë% 
t
->
ñemítsLígthMax
;

157 
look
;

159 
	`u∆ess
 (
mightBeThîe
)

160 
lookNext
;

161 i‡(
DEBUG_SHARE
)

162 
	`Ârötf
 (
°dîr
, "com∑rög "
FMTPTR
"Åo "FMTPTR"\n",

163 (
uöçå_t
)
obje˘
, (uöçå_t)
e
->object);

165 
	`u∆ess
 (
obje˘
 =
e
->object) {

166 
GC_hódî
 
hódî
;

167 
GC_obje˘Ty≥Tag
 
èg
;

169 
hódî
 = 
	`gëHódî
 (
obje˘
);

170 
	`u∆ess
 (
hódî
 =
	`gëHódî
 (
e
->
obje˘
))

171 
lookNext
;

172 
p1
 = (*)
obje˘
,

173 
p2
 = (*)
e
->
obje˘
;

174 
p1
 < (*)
max
;

175 ++
p1
, ++
p2
)

176 
	`u∆ess
 (*
p1
 =*
p2
)

177 
lookNext
;

178 
	`•lôHódî
 (
s
, 
hódî
, &
èg
, 
NULL
, NULL, NULL);

179 i‡(
ARRAY_TAG
 =
èg


180 
	`™d
 (
	`gëAºayLígth
 (
obje˘
Ë!gëAºayLígth (
e
->object)))

181 
lookNext
;

184  
e
->
obje˘
;

185 
	}
}

187 
	$growHashTabÀMaybe
 (
GC_°©e
 
s
, 
GC_obje˘HashTabÀ
 
t
) {

188 
GC_obje˘HashEÀmít
 
ﬁdEÀmít
;

189 
GC_obje˘HashEÀmít
 *
ﬁdEÀmíts
;

190 
uöt32_t
 
ﬁdEÀmítsLígthMax
;

191 
uöt32_t
 
√wEÀmítsLígthMax
;

193 i‡(
nŸ
 
t
->
mayIn£π
 
‹
Å->
ñemítsLígthCur
 * 2 <t->
ñemítsLígthMax
)

195 
ﬁdEÀmíts
 = 
t
->
ñemíts
;

196 
ﬁdEÀmítsLígthMax
 = 
t
->
ñemítsLígthMax
;

197 
√wEÀmítsLígthMax
 = 
ﬁdEÀmítsLígthMax
 * 2;

198 i‡(
DEBUG_SHARE
)

199 
	`Ârötf
 (
°dîr
,

200 "åyögÅÿgrowÅabÀÅÿˇrdöÆôy %"
PRIu32
"\n",

201 
√wEÀmítsLígthMax
);

203 
t
->
ñemíts
 =

204 (
GC_obje˘HashEÀmít
 *)

205 (
	`ˇŒoc
(
√wEÀmítsLígthMax
, (*(
t
->
ñemíts
))));

206 i‡(
NULL
 =
t
->
ñemíts
) {

207 
t
->
mayIn£π
 = 
FALSE
;

208 
t
->
ñemíts
 = 
ﬁdEÀmíts
;

209 i‡(
DEBUG_SHARE
)

210 
	`Ârötf
 (
°dîr
, "unableÅo growÅable\n");

213 
t
->
ñemítsLígthMax
 = 
√wEÀmítsLígthMax
;

214 
t
->
ñemítsLígthMaxLog2
++;

215 
i
 = 0; i < 
ﬁdEÀmítsLígthMax
; ++i) {

216 
ﬁdEÀmít
 = &
ﬁdEÀmíts
[
i
];

217 
	`u∆ess
 (
NULL
 =
ﬁdEÀmít
->
obje˘
)

218 
ö£πHashTabÀEÀm


219 (
s
, 
t
, 
ﬁdEÀmít
->
hash
, oldEÀmít->
obje˘
, 
NULL
, 
FALSE
);

221 i‡(
t
->
ñemítsIsInHóp
)

222 
t
->
ñemítsIsInHóp
 = 
FALSE
;

224 
	`‰ì
 (
ﬁdEÀmíts
);

225 i‡(
DEBUG_SHARE
)

226 
	`Ârötf
 (
°dîr
, "done growingÅable\n");

227 
	}
}

229 
poöãr
 
	$hashC⁄sPoöãr
 (
GC_°©e
 
s
, 
poöãr
 
obje˘
, 
boﬁ
 
cou¡ByãsHashC⁄£d
) {

230 
GC_obje˘HashTabÀ
 
t
;

231 
GC_hódî
 
hódî
;

232 
uöt16_t
 
byãsN⁄Obj±rs
;

233 
uöt16_t
 
numObj±rs
;

234 
boﬁ
 
hasIdítôy
;

235 
GC_obje˘Ty≥Tag
 
èg
;

236 
poöãr
 
max
;

237 
GC_hash
 
hash
;

238 
GC_hash
* 
p
;

239 
poöãr
 
ªs
;

241 i‡(
DEBUG_SHARE
)

242 
	`Ârötf
 (
°dîr
, "hashC⁄sPoöã∏("
FMTPTR
")\n", (
uöçå_t
)
obje˘
);

243 
t
 = 
s
->
obje˘HashTabÀ
;

244 
hódî
 = 
	`gëHódî
 (
obje˘
);

245 
	`•lôHódî
(
s
, 
hódî
, &
èg
, &
hasIdítôy
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

246 i‡(
hasIdítôy
) {

248 
ªs
 = 
obje˘
;

249 
d⁄e
;

251 
	`as£π
 ((
ARRAY_TAG
 =
èg
Ë
	`‹
 (
NORMAL_TAG
 ==Åag));

252 
max
 =

253 
obje˘


254 + (
ARRAY_TAG
 =
èg


255 ? (
	`sizeofAºayNoHódî
 (
s
, 
	`gëAºayLígth
 (
obje˘
),

256 
byãsN⁄Obj±rs
, 
numObj±rs
))

257 : (
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
)));

259 
hash
 = (
GC_hash
)
hódî
;

260 
p
 = (
GC_hash
*)
obje˘
;Ö < (GC_hash*)
max
; ++p)

261 
hash
 = hash * 31 + *
p
;

263 
ªs
 = 
	`ö£πHashTabÀEÀm
 (
s
, 
t
, 
hash
, 
obje˘
, 
max
, 
TRUE
);

264 
	`growHashTabÀMaybe
 (
s
, 
t
);

265 i‡(
cou¡ByãsHashC⁄£d
 
™d
 
ªs
 !
obje˘
) {

266 
size_t
 
amou¡
;

268 
amou¡
 = (
size_t
)(
max
 - 
obje˘
);

269 i‡(
ARRAY_TAG
 =
èg
)

270 
amou¡
 +
GC_ARRAY_HEADER_SIZE
;

272 
amou¡
 +
GC_NORMAL_HEADER_SIZE
;

273 
s
->
œ°Maj‹Sèti°ics
.
byãsHashC⁄£d
 +
amou¡
;

275 
d⁄e
:

276 i‡(
DEBUG_SHARE
)

277 
	`Ârötf
 (
°dîr
, 
FMTPTR
" = hashConsPointer ("FMTPTR")\n",

278 (
uöçå_t
)
ªs
, (uöçå_t)
obje˘
);

279  
ªs
;

280 
	}
}

282 
	$sh¨eObj±r
 (
GC_°©e
 
s
, 
obj±r
 *
›p
) {

283 
poöãr
 
p
;

285 
p
 = 
	`obj±rToPoöãr
 (*
›p
, 
s
->
hóp
.
°¨t
);

286 i‡(
DEBUG_SHARE
)

287 
	`Ârötf
 (
°dîr
, "sh¨eObj±∏ oµ = "
FMTPTR
" *›∞"
FMTOBJPTR
"\n",

288 (
uöçå_t
)
›p
, *opp);

289 
p
 = 
	`hashC⁄sPoöãr
 (
s
,Ö, 
FALSE
);

290 *
›p
 = 
	`poöãrToObj±r
 (
p
, 
s
->
hóp
.
°¨t
);

291 
	`m¨kI¡îgíî©i⁄ÆObj±r
 (
s
, 
›p
);

292 
	}
}

294 
	$¥ötByãsHashC⁄£dMesßge
 (
size_t
 
byãsHashC⁄£d
, size_à
byãsExamöed
) {

295 
	`Ârötf
 (
°dîr
, "[GC: hash-consed %s bytes (%.1f%% of bytesÉxamined).]\n",

296 
	`uötmaxToCommaSåög
(
byãsHashC⁄£d
),

297 100.0 * (()
byãsHashC⁄£d
 / ()
byãsExamöed
));

298 
	}
}

	@hash-cons.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

15 
uöt32_t
 
	tGC_hash
;

16 
	#GC_HASH_SIZE
 (
GC_hash
)

	)

17 
	#PRIxHASH
 
PRIx32


	)

18 
	#FMTHASH
 "0x%08"
PRIxHASH


	)

20 
	sGC_obje˘HashEÀmít
 {

21 
GC_hash
 
	mhash
;

22 
poöãr
 
	mobje˘
;

23 } *
	tGC_obje˘HashEÀmít
;

25 
	sGC_obje˘HashTabÀ
 {

26 
GC_obje˘HashEÀmít
 *
	mñemíts
;

27 
boﬁ
 
	mñemítsIsInHóp
;

28 
uöt32_t
 
	mñemítsLígthCur
;

29 
uöt32_t
 
	mñemítsLígthMax
;

30 
uöt32_t
 
	mñemítsLígthMaxLog2
;

31 
boﬁ
 
	mmayIn£π
;

32 } *
	tGC_obje˘HashTabÀ
;

36 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

38 
ölöe
 
GC_obje˘HashTabÀ
 
ÆlocHashTabÀ
 (
GC_°©e
 
s
);

39 
ölöe
 
‰ìHashTabÀ
 (
GC_obje˘HashTabÀ
 
t
);

41 
ölöe
 
poöãr
 
ö£πHashTabÀEÀm
 (
GC_°©e
 
s
,

42 
GC_obje˘HashTabÀ
 
t
, 
GC_hash
 
hash
,

43 
poöãr
 
obje˘
,Öoöã∏
max
, 
boﬁ
 
mightBeThîe
);

44 
ölöe
 
growHashTabÀMaybe
 (
GC_°©e
 
s
, 
GC_obje˘HashTabÀ
 
t
);

46 
poöãr
 
hashC⁄sPoöãr
 (
GC_°©e
 
s
,Öoöã∏
obje˘
, 
boﬁ
 
cou¡ByãsHashC⁄£d
);

47 
ölöe
 
sh¨eObj±r
 (
GC_°©e
 
s
, 
obj±r
 *
›p
);

49 
¥ötByãsHashC⁄£dMesßge
 (
size_t
 
byãsHashC⁄£d
, size_à
byãsExamöed
);

	@heap.c

9 
di•œyHóp
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

10 
GC_hóp
 
hóp
,

11 
FILE
 *
°ªam
) {

12 
Ârötf
(
°ªam
,

13 "\t\äur£ry = "
FMTPTR
"\n"

14 "\t\tﬁdGíSizê%"
PRIuMAX
"\n"

15 "\t\tsizê%"
PRIuMAX
"\n"

16 "\t\t°¨à"
FMTPTR
"\n"

17 "\t\twôhM≠sSizê%"
PRIuMAX
"\n",

18 (
uöçå_t
)
hóp
->
nur£ry
,

19 (
uötmax_t
)
hóp
->
ﬁdGíSize
,

20 (
uötmax_t
)
hóp
->
size
,

21 (
uöçå_t
)
hóp
->
°¨t
,

22 (
uötmax_t
)
hóp
->
wôhM≠sSize
);

26 
öôHóp
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

27 
GC_hóp
 
h
) {

28 
	gh
->
	gnur£ry
 = 
NULL
;

29 
	gh
->
	gﬁdGíSize
 = 0;

30 
	gh
->
	gsize
 = 0;

31 
	gh
->
	g°¨t
 = 
NULL
;

32 
	gh
->
	gwôhM≠sSize
 = 0;

40 
size_t
 
	$sizeofHópDesúed
 (
GC_°©e
 
s
, 
size_t
 
liveSize
, size_à
cuºítSize
) {

41 
size_t
 
liveM≠sSize
, 
liveWôhM≠sSize
;

42 
size_t
 
cuºítM≠sSize
, 
cuºítWôhM≠sSize
;

43 
size_t
 
ªsSize
, 
ªsWôhM≠sSize
;

44 
size_t
 
sy¶imSize
, 
sy¶imWôhM≠sSize
;

45 
LOCAL_USED_FOR_ASSERT
 
size_t
 
sy¶imM≠sSize
;

46 
øtio
;

48 
sy¶imWôhM≠sSize
 = 
	`ÆignDown
 (
SIZE_MAX
, 
s
->
sysvÆs
.
∑geSize
);

49 
sy¶imSize
 = 
	`övîtSizeofC¨dM≠AndCrossM≠
 (
s
, 
sy¶imWôhM≠sSize
);

50 
sy¶imM≠sSize
 = 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, 
sy¶imSize
);

51 
	`as£π
 (
sy¶imSize
 + 
sy¶imM≠sSize
 <
sy¶imWôhM≠sSize
);

53 
liveSize
 = 
	`Æign
 (liveSize, 
s
->
sysvÆs
.
∑geSize
);

54 i‡(
sy¶imSize
 < 
liveSize
)

55 
	`dõ
 ("Out of memory with system-limit heap size %s.\n",

56 
	`uötmaxToCommaSåög
(
sy¶imSize
));

57 
liveM≠sSize
 = 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, 
liveSize
);

58 
liveWôhM≠sSize
 = 
liveSize
 + 
liveM≠sSize
;

60 
	`as£π
 (
	`isAlig√d
 (
cuºítSize
, 
s
->
sysvÆs
.
∑geSize
));

61 
cuºítM≠sSize
 = 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, 
cuºítSize
);

62 
cuºítWôhM≠sSize
 = 
cuºítSize
 + 
cuºítM≠sSize
;

64 
øtio
 = ()
s
->
sysvÆs
.
øm
 / ()
liveWôhM≠sSize
;

66 i‡(
øtio
 >
s
->
c⁄åﬁs
.
øtios
.
live
 + s->c⁄åﬁs.øtios.
grow
) {

68 
ªsWôhM≠sSize
 = (
size_t
)(
liveWôhM≠sSize
 * 
s
->
c⁄åﬁs
.
øtios
.
live
);

72 i‡(0.5 * 
cuºítWôhM≠sSize
 <
ªsWôhM≠sSize


73 
™d
 
ªsWôhM≠sSize
 <1.1 * 
cuºítWôhM≠sSize
) {

74 
ªsWôhM≠sSize
 = 
cuºítWôhM≠sSize
;

76 
ªsWôhM≠sSize
 = 
	`Æign
 (ªsWôhM≠sSize, 
s
->
sysvÆs
.
∑geSize
);

78 } i‡(
s
->
c⁄åﬁs
.
øtios
.
grow
 >s->c⁄åﬁs.øtios.
c›y


79 
™d
 
øtio
 >2.0 * 
s
->
c⁄åﬁs
.
øtios
.
c›y
) {

85 
ªsWôhM≠sSize
 = 
	`ÆignDown
 (
s
->
sysvÆs
.
øm
 / 2, s->sysvÆs.
∑geSize
);

86 } i‡(
øtio
 >
s
->
c⁄åﬁs
.
øtios
.
c›y
 + s->c⁄åﬁs.øtios.
grow
) {

88 
ªsWôhM≠sSize
 = 
s
->
sysvÆs
.
øm
 - (
size_t
)(s->
c⁄åﬁs
.
øtios
.
grow
 * 
liveWôhM≠sSize
);

94 i‡(1.0 * 
cuºítWôhM≠sSize
 <
ªsWôhM≠sSize


95 
™d
 
ªsWôhM≠sSize
 <1.1 * 
cuºítWôhM≠sSize
) {

96 
ªsWôhM≠sSize
 = 
cuºítWôhM≠sSize
;

98 
ªsWôhM≠sSize
 = 
	`Æign
 (ªsWôhM≠sSize, 
s
->
sysvÆs
.
∑geSize
);

100 } i‡(
øtio
 >
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘
) {

107 
ªsWôhM≠sSize
 = 
s
->
sysvÆs
.
øm
;

109 
ªsWôhM≠sSizeD
 = 
liveWôhM≠sSize
 * ()(
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘
);

110 i‡(
ªsWôhM≠sSizeD
 > ()
sy¶imWôhM≠sSize
) {

111 
ªsWôhM≠sSize
 = 
sy¶imWôhM≠sSize
;

113 
ªsWôhM≠sSize
 = 
	`Æign
 ((
size_t
)
ªsWôhM≠sSizeD
, 
s
->
sysvÆs
.
∑geSize
);

122 i‡(
s
->
c⁄åﬁs
.
fixedHóp
 > 0) {

123 i‡(
ªsWôhM≠sSize
 > 
s
->
c⁄åﬁs
.
fixedHóp
 / 2)

124 
ªsWôhM≠sSize
 = 
s
->
c⁄åﬁs
.
fixedHóp
;

126 
ªsWôhM≠sSize
 = 
s
->
c⁄åﬁs
.
fixedHóp
 / 2;

127 i‡(
ªsWôhM≠sSize
 < 
liveWôhM≠sSize
)

128 
	`dõ
 ("Out of memory with fixed heap size %s.",

129 
	`uötmaxToCommaSåög
(
s
->
c⁄åﬁs
.
fixedHóp
));

130 } i‡(
s
->
c⁄åﬁs
.
maxHóp
 > 0) {

131 i‡(
ªsWôhM≠sSize
 > 
s
->
c⁄åﬁs
.
maxHóp
)

132 
ªsWôhM≠sSize
 = 
s
->
c⁄åﬁs
.
maxHóp
;

133 i‡(
ªsWôhM≠sSize
 < 
liveWôhM≠sSize
)

134 
	`dõ
 ("Out of memory with max heap size %s.",

135 
	`uötmaxToCommaSåög
(
s
->
c⁄åﬁs
.
maxHóp
));

137 
ªsSize
 = 
	`övîtSizeofC¨dM≠AndCrossM≠
 (
s
, 
ªsWôhM≠sSize
);

138 
	`as£π
 (
	`isAlig√d
 (
ªsSize
, 
s
->
sysvÆs
.
∑geSize
));

139 i‡(
DEBUG_RESIZING
)

140 
	`Ârötf
 (
°dîr
, "%s = sizeofHeapDesired (%s, %s)\n",

141 
	`uötmaxToCommaSåög
(
ªsSize
),

142 
	`uötmaxToCommaSåög
(
liveSize
),

143 
	`uötmaxToCommaSåög
(
cuºítSize
));

144 
	`as£π
 (
ªsSize
 >
liveSize
);

145  
ªsSize
;

146 
	}
}

148 
	$ªÀa£Hóp
 (
GC_°©e
 
s
, 
GC_hóp
 
h
) {

149 i‡(
NULL
 =
h
->
°¨t
)

151 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

152 
	`Ârötf
 (
°dîr
,

153 "[GC: Rñósög hó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map).]\n",

154 (
uöçå_t
)(
h
->
°¨t
),

155 
	`uötmaxToCommaSåög
(
h
->
size
),

156 
	`uötmaxToCommaSåög
(
h
->
wôhM≠sSize
 - h->
size
));

157 
	`GC_ªÀa£
 (
h
->
°¨t
, h->
wôhM≠sSize
);

158 
	`öôHóp
 (
s
, 
h
);

159 
	}
}

163 
	$shrökHóp
 (
GC_°©e
 
s
, 
GC_hóp
 
h
, 
size_t
 
kìpSize
) {

164 
	`as£π
 (
kìpSize
 <
h
->
size
);

165 i‡(0 =
kìpSize
) {

166 
	`ªÀa£Hóp
 (
s
, 
h
);

169 
kìpSize
 = 
	`Æign
 (kìpSize, 
s
->
sysvÆs
.
∑geSize
);

170 i‡(
kìpSize
 < 
h
->
size
) {

171 
size_t
 
kìpWôhM≠sSize
;

172 
kìpWôhM≠sSize
 = 
kìpSize
 + 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, keepSize);

173 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

174 
	`Ârötf
 (
°dîr
,

175 "[GC: Shrökög hó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map)]\n",

176 (
uöçå_t
)(
h
->
°¨t
),

177 
	`uötmaxToCommaSåög
(
h
->
size
),

178 
	`uötmaxToCommaSåög
(
h
->
wôhM≠sSize
 - h->
size
));

179 
	`Ârötf
 (
°dîr
,

181 
	`uötmaxToCommaSåög
(
kìpSize
),

182 
	`uötmaxToCommaSåög
(
kìpWôhM≠sSize
 - 
kìpSize
));

184 
	`as£π
 (
	`isAlig√d
 (
kìpWôhM≠sSize
, 
s
->
sysvÆs
.
∑geSize
));

185 
	`as£π
 (
kìpWôhM≠sSize
 <
h
->
wôhM≠sSize
);

186 
	`GC_ªÀa£
 (
h
->
°¨t
 + 
kìpWôhM≠sSize
, h->
wôhM≠sSize
 - keepWithMapsSize);

187 
h
->
size
 = 
kìpSize
;

188 
h
->
wôhM≠sSize
 = 
kìpWôhM≠sSize
;

190 
	}
}

199 
boﬁ
 
	$¸óãHóp
 (
GC_°©e
 
s
, 
GC_hóp
 
h
,

200 
size_t
 
desúedSize
,

201 
size_t
 
möSize
) {

202 
size_t
 
√wSize
;

203 
size_t
 
√wWôhM≠sSize
;

205 i‡(
DEBUG_MEM
)

206 
	`Ârötf
 (
°dîr
, "createHeap desired size = %s min size = %s\n",

207 
	`uötmaxToCommaSåög
(
desúedSize
),

208 
	`uötmaxToCommaSåög
(
möSize
));

209 i‡(
desúedSize
 < 
möSize
)

210 
desúedSize
 = 
möSize
;

211 
möSize
 = 
	`Æign
 (möSize, 
s
->
sysvÆs
.
∑geSize
);

212 
desúedSize
 = 
	`Æign
 (desúedSize, 
s
->
sysvÆs
.
∑geSize
);

213 
	`as£π
 (
	`isHópInô
 (
h
Ë
™d
 
NULL
 =h->
°¨t
);

221 
size_t
 
Á˘‹
 = 16;

222 c⁄° 
size_t
 
maxFa˘‹
 = 
s
->
sysvÆs
.
∑geSize
;

223 
size_t
 
lowSize
 = 
möSize
;

224 
size_t
 
highSize
 = 
desúedSize
;

225 
√wSize
 = 
highSize
;

226 
lo›Cou¡
 = 0;

227 
lowSize
 <
highSize
) {

228 
poöãr
 
√wSèπ
;

230 
√wWôhM≠sSize
 = 
√wSize
 + 
	`sizeofC¨dM≠AndCrossM≠
 (
s
,ÇewSize);

232 
	`as£π
 (
	`isAlig√d
 (
√wWôhM≠sSize
, 
s
->
sysvÆs
.
∑geSize
));

234 c⁄° 
addªssCou¡Log2
 = 5;

235 c⁄° 
addªssCou¡
 = 0x1 << 
addªssCou¡Log2
;

236 c⁄° 
size_t
 
addªssSãp
 = (size_t)0x1 << (
ADDRESS_BITS
 - 
addªssCou¡Log2
);

237 #i‡
ADDRESS_BITS
 =
POINTER_BITS


238 c⁄° 
size_t
 
addªssHigh
 = 0;

240 c⁄° 
size_t
 
addªssHigh
 = (size_t)0x1 << 
ADDRESS_BITS
;

242 
boﬁ
 
addªssSˇnDú
 = 
TRUE
;

243 
i
 = 1; i <
addªssCou¡
; i++) {

244 
size_t
 
addªss
 = (size_t)
i
 * 
addªssSãp
;

245 i‡(
addªssSˇnDú
)

246 
addªss
 = 
addªssHigh
 -áddress;

248 i‡(
i
 =
addªssCou¡
)

249 
addªss
 = 0;

251 
√wSèπ
 = 
	`GC_mm≠An⁄
 ((
poöãr
)
addªss
, 
√wWôhM≠sSize
);

252 
	`u∆ess
 ((*)-1 =
√wSèπ
) {

253 
addªssSˇnDú
 = 
nŸ
áddressScanDir;

254 
h
->
°¨t
 = 
√wSèπ
;

255 
h
->
size
 = 
√wSize
;

256 
h
->
wôhM≠sSize
 = 
√wWôhM≠sSize
;

257 i‡(
h
->
size
 > 
s
->
cumuœtiveSèti°ics
.
maxHópSize
)

258 
s
->
cumuœtiveSèti°ics
.
maxHópSize
 = 
h
->
size
;

259 
	`as£π
 (
möSize
 <
h
->
size
 
™d
 h->sizê<
desúedSize
);

260 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

261 
	`Ârötf
 (
°dîr
,

262 "[GC: Cª©ed hó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map).]\n",

263 (
uöçå_t
)(
h
->
°¨t
),

264 
	`uötmaxToCommaSåög
(
h
->
size
),

265 
	`uötmaxToCommaSåög
(
h
->
wôhM≠sSize
 - h->
size
));

266  
TRUE
;

269 
size_t
 
¥evSize
 = 
√wSize
;

270 
size_t
 
¥evWôhM≠sSize
 = 
√wWôhM≠sSize
;

271 
highSize
 = 
√wSize
 - 
s
->
sysvÆs
.
∑geSize
;

272 
√wSize
 = 
	`Æign
((
Á˘‹
-1Ë* (
highSize
 / fa˘‹Ë+ (
lowSize
 / fa˘‹), 
s
->
sysvÆs
.
∑geSize
);

273 i‡(
s
->
c⁄åﬁs
.
mesßges
) {

274 
	`Ârötf
 (
°dîr
,

276 
	`uötmaxToCommaSåög
 (
¥evSize
),

277 
	`uötmaxToCommaSåög
 (
¥evWôhM≠sSize
 - 
¥evSize
));

278 
	`Ârötf
 (
°dîr
,

280 
	`uötmaxToCommaSåög
 (
¥evSize
 - 
√wSize
),

281 
	`uötmaxToCommaSåög
 (
möSize
));

283 i‡(
Á˘‹
 < 
maxFa˘‹


284 
™d
 ++
lo›Cou¡
 % 64 == 0) {

285 
Á˘‹
 += factor;

288  
FALSE
;

289 
	}
}

293 
boﬁ
 
	$¸óãHópSec⁄d¨y
 (
GC_°©e
 
s
, 
size_t
 
desúedSize
) {

294 
size_t
 
desúedWôhM≠sSize
;

295 
size_t
 
möSize
, 
möWôhM≠sSize
;

296 
desúedWôhM≠sSize
 = 
desúedSize
 + 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, desiredSize);

297 i‡((
s
->
c⁄åﬁs
.
fixedHóp
 > 0

298 
™d
 
s
->
hóp
.
wôhM≠sSize
 + 
desúedWôhM≠sSize
 > s->
c⁄åﬁs
.
fixedHóp
)

299 
	`‹
 (
s
->
c⁄åﬁs
.
maxHóp
 > 0

300 
™d
 
s
->
hóp
.
wôhM≠sSize
 + 
desúedWôhM≠sSize
 > s->
c⁄åﬁs
.
maxHóp
))

301  
FALSE
;

302 
möSize
 = 
	`Æign
 (
s
->
hóp
.
ﬁdGíSize
, s->
sysvÆs
.
∑geSize
);

303 
möWôhM≠sSize
 = 
möSize
 + 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, minSize);

304 i‡(
möWôhM≠sSize
 > 
SIZE_MAX
 - 
s
->
hóp
.
wôhM≠sSize
)

305  
FALSE
;

306  
	`¸óãHóp
 (
s
, &s->
£c⁄d¨yHóp
, 
desúedSize
, s->
hóp
.
ﬁdGíSize
);

307 
	}
}

311 #i‡
nŸ
 
HAS_REMAP


312 
boﬁ
 
ªm≠Hóp
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

313 
__©åibuã__
 ((
unu£d
)Ë
GC_hóp
 
h
,

314 
__©åibuã__
 ((
unu£d
)Ë
size_t
 
desúedSize
,

315 
__©åibuã__
 ((
unu£d
)Ë
size_t
 
möSize
) {

316  
	gFALSE
;

319 
boﬁ
 
	$ªm≠Hóp
 (
GC_°©e
 
s
, 
GC_hóp
 
h
,

320 
size_t
 
desúedSize
,

321 
size_t
 
möSize
) {

323 
size_t
 
√wSize
;

324 
size_t
 
√wWôhM≠sSize
;

325 
ªsu…
;

327 i‡(
DEBUG_MEM
)

328 
	`Ârötf
 (
°dîr
, "remapHeap desired size = %s min size = %s\n",

329 
	`uötmaxToCommaSåög
(
desúedSize
),

330 
	`uötmaxToCommaSåög
(
möSize
));

331 
	`as£π
 (
möSize
 <
desúedSize
);

332 
	`as£π
 (
desúedSize
 >
h
->
size
);

333 
möSize
 = 
	`Æign
 (möSize, 
s
->
sysvÆs
.
∑geSize
);

334 
desúedSize
 = 
	`Æign
 (desúedSize, 
s
->
sysvÆs
.
∑geSize
);

339 
size_t
 
Á˘‹
 = 16;

340 
size_t
 
lowSize
 = 
möSize
;

341 
size_t
 
highSize
 = 
desúedSize
;

342 
√wSize
 = 
highSize
;

343 
ªsu…
 = 
FALSE
;

344 
lowSize
 <
highSize
) {

345 
poöãr
 
√wSèπ
;

347 
√wWôhM≠sSize
 = 
√wSize
 + 
	`sizeofC¨dM≠AndCrossM≠
 (
s
,ÇewSize);

349 
	`as£π
 (
	`isAlig√d
 (
√wWôhM≠sSize
, 
s
->
sysvÆs
.
∑geSize
));

351 
√wSèπ
 = 
	`GC_mªm≠
 (
h
->
°¨t
, h->
wôhM≠sSize
, 
√wWôhM≠sSize
);

352 i‡((*)-1 !
√wSèπ
) {

353 
poöãr
 
‹igSèπ
 = 
h
->
°¨t
;

354 
size_t
 
‹igSize
 = 
h
->
size
;

355 
size_t
 
‹igWôhM≠sSize
 = 
h
->
wôhM≠sSize
;

356 
h
->
°¨t
 = 
√wSèπ
;

357 
h
->
size
 = 
√wSize
;

358 
h
->
wôhM≠sSize
 = 
√wWôhM≠sSize
;

359 i‡(
h
->
size
 > 
s
->
cumuœtiveSèti°ics
.
maxHópSize
)

360 
s
->
cumuœtiveSèti°ics
.
maxHópSize
 = 
h
->
size
;

361 
	`as£π
 (
möSize
 <
h
->
size
 
™d
 h->sizê<
desúedSize
);

362 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

363 
	`Ârötf
 (
°dîr
,

364 "[GC: Rem≠≥d hó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map)]\n",

365 (
uöçå_t
)
‹igSèπ
,

366 
	`uötmaxToCommaSåög
(
‹igSize
),

367 
	`uötmaxToCommaSåög
(
‹igWôhM≠sSize
 - 
‹igSize
));

368 
	`Ârötf
 (
°dîr
,

369 "[GC:\âÿhó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map).]\n",

370 (
uöçå_t
)(
h
->
°¨t
),

371 
	`uötmaxToCommaSåög
(
h
->
size
),

372 
	`uötmaxToCommaSåög
(
h
->
wôhM≠sSize
 - h->
size
));

374 
lowSize
 = 
√wSize
 + 
s
->
sysvÆs
.
∑geSize
;

375 
√wSize
 = 
	`Æign
((
Á˘‹
-1Ë* (
highSize
 / fa˘‹Ë+ (
lowSize
 / fa˘‹), 
s
->
sysvÆs
.
∑geSize
);

376 
ªsu…
 = 
TRUE
;

378 
size_t
 
¥evSize
 = 
√wSize
;

379 
size_t
 
¥evWôhM≠sSize
 = 
√wWôhM≠sSize
;

380 
highSize
 = 
√wSize
 - 
s
->
sysvÆs
.
∑geSize
;

381 
√wSize
 = 
	`Æign
((
Á˘‹
-1Ë* (
highSize
 / fa˘‹Ë+ (
lowSize
 / fa˘‹), 
s
->
sysvÆs
.
∑geSize
);

382 i‡(
s
->
c⁄åﬁs
.
mesßges
) {

383 
	`Ârötf
 (
°dîr
,

384 "[GC: Rem≠pög hó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map)]\n",

385 (
uöçå_t
)(
h
->
°¨t
),

386 
	`uötmaxToCommaSåög
 (
h
->
size
),

387 
	`uötmaxToCommaSåög
 (
h
->
wôhM≠sSize
 - h->
size
));

388 
	`Ârötf
 (
°dîr
,

390 
	`uötmaxToCommaSåög
 (
¥evSize
),

391 
	`uötmaxToCommaSåög
 (
¥evWôhM≠sSize
 - 
¥evSize
));

392 i‡(
ªsu…
) {

393 
	`Ârötf
 (
°dîr
,

395 
	`uötmaxToCommaSåög
 (
¥evSize
 - 
√wSize
));

397 
	`Ârötf
 (
°dîr
,

399 
	`uötmaxToCommaSåög
 (
¥evSize
 - 
√wSize
),

400 
	`uötmaxToCommaSåög
 (
möSize
));

405  
ªsu…
;

406 
	}
}

410 
	mCOPY_CHUNK_SIZE
 = 0x2000000,

415 
	$growHóp
 (
GC_°©e
 
s
, 
size_t
 
desúedSize
, size_à
möSize
) {

416 
GC_hóp
 
curHóµ
;

417 
GC_hóp
 
√wHóp
;

418 
GC_hóp
 
√wHóµ
;

420 
boﬁ
 
u£Cuºít
;

421 
poöãr
 
‹igSèπ
;

422 
size_t
 
liveSize
;

424 
	`as£π
 (
	`isAlig√d
 (
desúedSize
, 
s
->
sysvÆs
.
∑geSize
));

425 
	`as£π
 (
	`isAlig√d
 (
möSize
, 
s
->
sysvÆs
.
∑geSize
));

426 
	`as£π
 (
desúedSize
 >
s
->
hóp
.
size
);

427 i‡(
DEBUG_RESIZING
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

428 
	`Ârötf
 (
°dîr
,

429 "[GC: Growög hó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map),]\n",

430 (
uöçå_t
)
s
->
hóp
.
°¨t
,

431 
	`uötmaxToCommaSåög
(
s
->
hóp
.
size
),

432 
	`uötmaxToCommaSåög
(
s
->
hóp
.
wôhM≠sSize
 - s->hóp.
size
));

433 
	`Ârötf
 (
°dîr
,

435 
	`uötmaxToCommaSåög
(
desúedSize
),

436 
	`uötmaxToCommaSåög
(
	`sizeofC¨dM≠AndCrossM≠
 (
s
, 
desúedSize
)));

437 
	`Ârötf
 (
°dîr
,

439 
	`uötmaxToCommaSåög
(
möSize
),

440 
	`uötmaxToCommaSåög
(
	`sizeofC¨dM≠AndCrossM≠
 (
s
, 
möSize
)));

442 i‡(
möSize
 <
s
->
hóp
.
size
) {

443 
u£Cuºít
 = 
TRUE
;

445 
möSize
 = 
s
->
hóp
.
size
 + s->
sysvÆs
.
∑geSize
;

447 
u£Cuºít
 = 
FALSE
;

449 
curHóµ
 = &
s
->
hóp
;

450 
√wHóµ
 = &
√wHóp
;

451 
‹igSèπ
 = 
curHóµ
->
°¨t
;

452 
liveSize
 = 
curHóµ
->
ﬁdGíSize
;

453 
	`as£π
 (
liveSize
 <
curHóµ
->
size
);

454 i‡(
	`ªm≠Hóp
 (
s
, 
curHóµ
, 
desúedSize
, 
möSize
)) {

455 
d⁄e
;

457 i‡(!
u£Cuºít
)

458 
	`shrökHóp
 (
s
, 
curHóµ
, 
liveSize
);

459 
	`öôHóp
 (
s
, 
√wHóµ
);

461 i‡(
möSize
 + 
	`sizeofC¨dM≠AndCrossM≠
 (
s
, möSizeË<
SIZE_MAX
 - 
curHóµ
->
wôhM≠sSize


462 
™d
 
	`¸óãHóp
 (
s
, 
√wHóµ
, 
desúedSize
, 
möSize
)) {

463 
poöãr
 
‰om
;

464 
poöãr
 
to
;

465 
size_t
 
ªmaöög
;

467 
‰om
 = 
curHóµ
->
°¨t
 + 
liveSize
;

468 
to
 = 
√wHóµ
->
°¨t
 + 
liveSize
;

469 
ªmaöög
 = 
liveSize
;

470 
	`shrökHóp
 (
s
, 
curHóµ
, 
ªmaöög
);

471 
c›y
:

472 
	`as£π
 (
ªmaöög
 =(
size_t
)(
‰om
 - 
curHóµ
->
°¨t
)

473 
™d
 
‰om
 >
curHóµ
->
°¨t


474 
™d
 
to
 >
√wHóµ
->
°¨t
);

475 i‡(
ªmaöög
 < 
COPY_CHUNK_SIZE
) {

476 
	`GC_mem˝y
 (
curHóµ
->
°¨t
, 
√wHóµ
->°¨t, 
ªmaöög
);

477 
	`ªÀa£Hóp
 (
s
, 
curHóµ
);

479 
ªmaöög
 -
COPY_CHUNK_SIZE
;

480 
‰om
 -
COPY_CHUNK_SIZE
;

481 
to
 -
COPY_CHUNK_SIZE
;

482 
	`GC_mem˝y
 (
‰om
, 
to
, 
COPY_CHUNK_SIZE
);

483 
	`shrökHóp
 (
s
, 
curHóµ
, 
ªmaöög
);

484 
c›y
;

486 
√wHóµ
->
ﬁdGíSize
 = 
liveSize
;

487 *
curHóµ
 = *
√wHóµ
;

488 } i‡(
u£Cuºít
) {

489 i‡(
DEBUG_RESIZING
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

490 
	`Ârötf
 (
°dîr
,

491 "[GC: Usög hó∞© "
FMTPTR
" of size %s bytes (+ %s bytes card/cross map).]\n",

492 (
uöçå_t
)
s
->
hóp
.
°¨t
,

493 
	`uötmaxToCommaSåög
(
s
->
hóp
.
size
),

494 
	`uötmaxToCommaSåög
(
s
->
hóp
.
wôhM≠sSize
 - s->hóp.
size
));

496 } i‡(
s
->
c⁄åﬁs
.
mayPageHóp
) {

498 *
d©a
;

500 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

501 
	`Ârötf
 (
°dîr
,

502 "[GC: Wrôög hó∞© "
FMTPTR
" of size %s bytesÅo disk.]\n",

503 (
uöçå_t
)
curHóµ
->
°¨t
,

504 
	`uötmaxToCommaSåög
(
liveSize
));

506 
d©a
 = 
	`GC_diskBack_wrôe
 (
curHóµ
->
°¨t
, 
liveSize
);

507 
	`ªÀa£Hóp
 (
s
, 
curHóµ
);

508 i‡(
	`¸óãHóp
 (
s
, 
curHóµ
, 
desúedSize
, 
möSize
)) {

509 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

510 
	`Ârötf
 (
°dîr
,

511 "[GC: Ródög hó∞tÿ"
FMTPTR
" of size %s bytes from disk.]\n",

512 (
uöçå_t
)(
curHóµ
->
°¨t
),

513 
	`uötmaxToCommaSåög
(
liveSize
));

515 
	`GC_diskBack_ªad
 (
d©a
, 
curHóµ
->
°¨t
, 
liveSize
);

516 
	`GC_diskBack_˛o£
 (
d©a
);

517 
curHóµ
->
ﬁdGíSize
 = 
liveSize
;

519 
	`GC_diskBack_˛o£
 (
d©a
);

520 
oom
;

523 
oom
;

525 
d⁄e
:

526 
	`u∆ess
 (
‹igSèπ
 =
s
->
hóp
.
°¨t
) {

527 
	`å™¶©eHóp
 (
s
, 
‹igSèπ
, s->
hóp
.
°¨t
, s->hóp.
ﬁdGíSize
);

530 
oom
:

531 i‡(
s
->
c⁄åﬁs
.
mesßges
)

532 
	`GC_di•œyMem
 ();

533 
	`dõ
 ("Out of memory. UnableÅoállocate heap with %s bytes.\n",

534 
	`uötmaxToCommaSåög
(
möSize
));

535 
	}
}

539 
	$ªsizeHóp
 (
GC_°©e
 
s
, 
size_t
 
möSize
) {

540 
size_t
 
desúedSize
;

542 i‡(
DEBUG_RESIZING
)

543 
	`Ârötf
 (
°dîr
, "resizeHeap minSize = %s size = %s\n",

544 
	`uötmaxToCommaSåög
(
möSize
),

545 
	`uötmaxToCommaSåög
(
s
->
hóp
.
size
));

546 
desúedSize
 = 
	`sizeofHópDesúed
 (
s
, 
möSize
, s->
hóp
.
size
);

547 
	`as£π
 (
	`isAlig√d
 (
desúedSize
, 
s
->
sysvÆs
.
∑geSize
));

548 
	`as£π
 (
möSize
 <
desúedSize
);

549 
möSize
 = 
	`Æign
 (möSize, 
s
->
sysvÆs
.
∑geSize
);

550 i‡(
desúedSize
 <
s
->
hóp
.
size
) {

551 
	`shrökHóp
 (
s
, &s->
hóp
, 
desúedSize
);

553 
	`ªÀa£Hóp
 (
s
, &s->
£c⁄d¨yHóp
);

554 
	`growHóp
 (
s
, 
desúedSize
, 
möSize
);

556 
	`as£π
 (
s
->
hóp
.
size
 >
möSize
);

557 
	}
}

561 
	$ªsizeHópSec⁄d¨y
 (
GC_°©e
 
s
) {

562 
size_t
 
¥im¨ySize
, 
¥im¨yWôhM≠sSize
;

563 
size_t
 
£c⁄d¨ySize
;

565 
¥im¨ySize
 = 
s
->
hóp
.
size
;

566 
¥im¨yWôhM≠sSize
 = 
s
->
hóp
.
wôhM≠sSize
;

567 
£c⁄d¨ySize
 = 
s
->
£c⁄d¨yHóp
.
size
;

568 i‡(
DEBUG_RESIZING
)

569 
	`Ârötf
 (
°dîr
, "secondaryHeapResize\n");

570 i‡(0 =
£c⁄d¨ySize
)

572 i‡(2 * 
¥im¨yWôhM≠sSize
 > 
s
->
sysvÆs
.
øm
)

574 
	`ªÀa£Hóp
 (
s
, &s->
£c⁄d¨yHóp
);

575 i‡(
£c⁄d¨ySize
 < 
¥im¨ySize
) {

576 
	`u∆ess
 (
	`ªm≠Hóp
 (
s
, &s->
£c⁄d¨yHóp
, 
¥im¨ySize
,ÖrimarySize))

577 
	`ªÀa£Hóp
 (
s
, &s->
£c⁄d¨yHóp
);

578 } i‡(
£c⁄d¨ySize
 > 
¥im¨ySize
)

579 
	`shrökHóp
 (
s
, &s->
£c⁄d¨yHóp
, 
¥im¨ySize
);

580 
	`as£π
 (0 =
s
->
£c⁄d¨yHóp
.
size


581 
‹
 
s
->
hóp
.
size
 =s->
£c⁄d¨yHóp
.size);

582 
	}
}

	@heap.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

26 
	sGC_hóp
 {

27 
poöãr
 
	mnur£ry
;

28 
size_t
 
	mﬁdGíSize
;

29 
size_t
 
	msize
;

30 
poöãr
 
	m°¨t
;

31 
size_t
 
	mwôhM≠sSize
;

32 } *
	tGC_hóp
;

34 
	#GC_HEAP_LIMIT_SLOP
 512

	)

38 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

40 
ölöe
 
boﬁ
 
isPoöãrInOldGí
 (
GC_°©e
 
s
, 
poöãr
 
p
);

41 
ölöe
 
boﬁ
 
isPoöãrInNur£ry
 (
GC_°©e
 
s
, 
poöãr
 
p
);

42 #i‡
ASSERT


43 
ölöe
 
boﬁ
 
isObj±rInOldGí
 (
GC_°©e
 
s
, 
obj±r
 
›
);

45 
ölöe
 
boﬁ
 
isObj±rInNur£ry
 (
GC_°©e
 
s
, 
obj±r
 
›
);

46 #i‡
ASSERT


47 
ölöe
 
boﬁ
 
isObj±rInFromS∑˚
 (
GC_°©e
 
s
, 
obj±r
 
›
);

49 
ölöe
 
boﬁ
 
hasHópByãsFªe
 (
GC_°©e
 
s
, 
size_t
 
ﬁdGí
, size_à
nur£ry
);

50 
ölöe
 
boﬁ
 
isHópInô
 (
GC_hóp
 
h
);

52 
di•œyHóp
 (
GC_°©e
 
s
, 
GC_hóp
 
hóp
, 
FILE
 *
°ªam
);

54 
ölöe
 
öôHóp
 (
GC_°©e
 
s
, 
GC_hóp
 
h
);

55 
ölöe
 
size_t
 
sizeofHópDesúed
 (
GC_°©e
 
s
, size_à
live
, size_à
cuºítSize
);

57 
ölöe
 
ªÀa£Hóp
 (
GC_°©e
 
s
, 
GC_hóp
 
h
);

58 
shrökHóp
 (
GC_°©e
 
s
, 
GC_hóp
 
h
, 
size_t
 
kìpSize
);

59 
boﬁ
 
¸óãHóp
 (
GC_°©e
 
s
, 
GC_hóp
 
h
, 
size_t
 
desúedSize
, size_à
möSize
);

60 
boﬁ
 
¸óãHópSec⁄d¨y
 (
GC_°©e
 
s
, 
size_t
 
desúedSize
);

61 
boﬁ
 
ªm≠Hóp
 (
GC_°©e
 
s
, 
GC_hóp
 
h
, 
size_t
 
desúedSize
, size_à
möSize
);

62 
growHóp
 (
GC_°©e
 
s
, 
size_t
 
desúedSize
, size_à
möSize
);

63 
ªsizeHóp
 (
GC_°©e
 
s
, 
size_t
 
möSize
);

64 
ªsizeHópSec⁄d¨y
 (
GC_°©e
 
s
);

	@heap_predicates.c

9 
boﬁ
 
	$isPoöãrInOldGí
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

10  (
	`nŸ
 (
	`isPoöãr
 (
p
))

11 
	`‹
 (
s
->
hóp
.
°¨t
 <
p


12 
™d
 
p
 < 
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
));

13 
	}
}

15 
boﬁ
 
	$isPoöãrInNur£ry
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

16  (
	`nŸ
 (
	`isPoöãr
 (
p
))

17 
	`‹
 (
s
->
hóp
.
nur£ry
 <
p
 
™d
Ö < s->
‰⁄tõr
));

18 
	}
}

20 #i‡
ASSERT


21 
boﬁ
 
	$isObj±rInOldGí
 (
GC_°©e
 
s
, 
obj±r
 
›
) {

22 
poöãr
 
p
;

23 i‡(
	`nŸ
 (
	`isObj±r
(
›
)))

24  
TRUE
;

25 
p
 = 
	`obj±rToPoöãr
 (
›
, 
s
->
hóp
.
°¨t
);

26  
	`isPoöãrInOldGí
 (
s
, 
p
);

27 
	}
}

30 
boﬁ
 
	$isObj±rInNur£ry
 (
GC_°©e
 
s
, 
obj±r
 
›
) {

31 
poöãr
 
p
;

32 i‡(
	`nŸ
 (
	`isObj±r
(
›
)))

33  
TRUE
;

34 
p
 = 
	`obj±rToPoöãr
 (
›
, 
s
->
hóp
.
°¨t
);

35  
	`isPoöãrInNur£ry
 (
s
, 
p
);

36 
	}
}

38 #i‡
ASSERT


39 
boﬁ
 
	$isObj±rInFromS∑˚
 (
GC_°©e
 
s
, 
obj±r
 
›
) {

40  (
	`isObj±rInOldGí
 (
s
, 
›
)

41 
‹
 
	`isObj±rInNur£ry
 (
s
, 
›
));

42 
	}
}

45 
boﬁ
 
	$hasHópByãsFªe
 (
GC_°©e
 
s
, 
size_t
 
ﬁdGí
, size_à
nur£ry
) {

46 
size_t
 
tŸÆ
;

47 
boﬁ
 
ªs
;

49 
tŸÆ
 =

50 
s
->
hóp
.
ﬁdGíSize
 + 
ﬁdGí


51 + (
s
->
ˇnMö‹
 ? 2 : 1Ë* (
size_t
)(s->
limôPlusSl›
 - s->
hóp
.
nur£ry
);

52 
ªs
 =

53 (
tŸÆ
 <
s
->
hóp
.
size
)

54 
	`™d
 (
nur£ry
 <(
size_t
)(
s
->
limôPlusSl›
 - s->
‰⁄tõr
));

55 i‡(
DEBUG_DETAILED
)

56 
	`Ârötf
 (
°dîr
, "%s = hasBytesFree (%s, %s)\n",

57 
	`boﬁToSåög
 (
ªs
),

58 
	`uötmaxToCommaSåög
(
ﬁdGí
),

59 
	`uötmaxToCommaSåög
(
nur£ry
));

60  
ªs
;

61 
	}
}

63 
boﬁ
 
	$isHópInô
 (
GC_hóp
 
h
) {

64  (0 =
h
->
size
);

65 
	}
}

	@init-world.c

14 
size_t
 
	$sizeofInôülByãsLive
 (
GC_°©e
 
s
) {

15 
uöt32_t
 
i
;

16 
size_t
 
d©aByãs
;

17 
size_t
 
tŸÆ
;

19 
tŸÆ
 = 0;

20 
i
 = 0; i < 
s
->
ve˘‹InôsLígth
; ++i) {

21 
d©aByãs
 =

22 
s
->
ve˘‹Inôs
[
i
].
ñemítSize


23 * 
s
->
ve˘‹Inôs
[
i
].
Àngth
;

24 
tŸÆ
 +
	`Æign
 (
GC_ARRAY_HEADER_SIZE


25 + ((
d©aByãs
 < 
OBJPTR_SIZE
)

26 ? 
OBJPTR_SIZE


27 : 
d©aByãs
),

28 
s
->
Æignmít
);

30  
tŸÆ
;

31 
	}
}

33 
	$öôVe˘‹s
 (
GC_°©e
 
s
) {

34 
GC_ve˘‹Inô
 *
öôs
;

35 
poöãr
 
‰⁄tõr
;

36 
uöt32_t
 
i
;

38 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, s->
‰⁄tõr
));

39 
öôs
 = 
s
->
ve˘‹Inôs
;

40 
‰⁄tõr
 = 
s
->frontier;

41 
i
 = 0; i < 
s
->
ve˘‹InôsLígth
; i++) {

42 
size_t
 
ñemítSize
;

43 
size_t
 
d©aByãs
;

44 
size_t
 
obje˘Size
;

45 
uöt32_t
 
ty≥Index
;

47 
ñemítSize
 = 
öôs
[
i
].elementSize;

48 
d©aByãs
 = 
ñemítSize
 * 
öôs
[
i
].
Àngth
;

49 
obje˘Size
 = 
	`Æign
 (
GC_ARRAY_HEADER_SIZE


50 + ((
d©aByãs
 < 
OBJPTR_SIZE
)

51 ? 
OBJPTR_SIZE


52 : 
d©aByãs
),

53 
s
->
Æignmít
);

54 
	`as£π
 (
obje˘Size
 <(
size_t
)(
s
->
hóp
.
°¨t
 + s->hóp.
size
 - 
‰⁄tõr
));

55 *((
GC_¨øyCou¡î
*)(
‰⁄tõr
)) = 0;

56 
‰⁄tõr
 = fr⁄tõ∏+ 
GC_ARRAY_COUNTER_SIZE
;

57 *((
GC_¨øyLígth
*)(
‰⁄tõr
)Ë
öôs
[
i
].
Àngth
;

58 
‰⁄tõr
 = fr⁄tõ∏+ 
GC_ARRAY_LENGTH_SIZE
;

59 
ñemítSize
) {

61 
ty≥Index
 = 
WORD8_VECTOR_TYPE_INDEX
;

64 
ty≥Index
 = 
WORD16_VECTOR_TYPE_INDEX
;

67 
ty≥Index
 = 
WORD32_VECTOR_TYPE_INDEX
;

70 
ty≥Index
 = 
WORD64_VECTOR_TYPE_INDEX
;

73 
	`dõ
 ("unknow¿ñemíàsizêö ve˘‹Inô: %"
PRIuMAX
"",

74 (
uötmax_t
)
ñemítSize
);

76 *((
GC_hódî
*)(
‰⁄tõr
)Ë
	`buûdHódîFromTy≥Index
 (
ty≥Index
);

77 
‰⁄tõr
 = fr⁄tõ∏+ 
GC_HEADER_SIZE
;

78 
s
->
globÆs
[
öôs
[
i
].
globÆIndex
] = 
	`poöãrToObj±r
(
‰⁄tõr
, s->
hóp
.
°¨t
);

79 i‡(
DEBUG_DETAILED
)

80 
	`Ârötf
 (
°dîr
, "Æloˇãd ve˘‹áà"
FMTPTR
"\n",

81 (
uöçå_t
)(
s
->
globÆs
[
öôs
[
i
].
globÆIndex
]));

82 
	`mem˝y
 (
‰⁄tõr
, 
öôs
[
i
].
w‹ds
, 
d©aByãs
);

83 
‰⁄tõr
 +
obje˘Size
 - 
GC_ARRAY_HEADER_SIZE
;

85 i‡(
DEBUG_DETAILED
)

86 
	`Ârötf
 (
°dîr
, "‰⁄tõ∏a·î såögáŒoˇti⁄ i†"
FMTPTR
"\n",

87 (
uöçå_t
)
‰⁄tõr
);

88 
	`GC_¥ofûeAŒocInc
 (
s
, (
size_t
)(
‰⁄tõr
 - s->frontier));

89 
s
->
cumuœtiveSèti°ics
.
byãsAŒoˇãd
 +(
size_t
)(
‰⁄tõr
 - s->frontier);

90 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, 
‰⁄tõr
));

91 
s
->
‰⁄tõr
 = frontier;

92 
	}
}

94 
	$öôW‹ld
 (
GC_°©e
 
s
) {

95 
uöt32_t
 
i
;

96 
poöãr
 
°¨t
;

97 
GC_thªad
 
thªad
;

99 
i
 = 0; i < 
s
->
globÆsLígth
; ++i)

100 
s
->
globÆs
[
i
] = 
BOGUS_OBJPTR
;

101 
s
->
œ°Maj‹Sèti°ics
.
byãsLive
 = 
	`sizeofInôülByãsLive
 (s);

106 
	#MEGABYTES
 1024*1024

	)

107 
	#MEM_AVAILABLE
 1024

	)

108 
	`¸óãUMHóp
 (
s
, &s->
umhóp
, 
MEM_AVAILABLE
*
MEGABYTES
, MEM_AVAILABLE*MEGABYTES);

110 
	`¸óãUMAºayHóp
 (
s
, &s->
um¨hóp
, 512*
MEGABYTES
, 512*MEGABYTES);

112 
	`¸óãHóp
 (
s
, &s->
hóp
, 100*
MEGABYTES
, 100*MEGABYTES);

118 
s
->
gc_moduÀ
 = 
GC_UM
;

119 
	`£tC¨dM≠AndCrossM≠
 (
s
);

120 
°¨t
 = 
	`ÆignFr⁄tõr
 (
s
, s->
hóp
.start);

121 
s
->
um¨‰⁄tõr
 = s->
um¨hóp
.
°¨t
;

122 
s
->
‰⁄tõr
 = 
°¨t
;

123 
s
->
limôPlusSl›
 = s->
hóp
.
°¨t
 + s->hóp.
size
;

124 
s
->
limô
 = s->
limôPlusSl›
 - 
GC_HEAP_LIMIT_SLOP
;

125 
	`öôVe˘‹s
 (
s
);

126 
	`as£π
 ((
size_t
)(
s
->
‰⁄tõr
 - 
°¨t
Ë<s->
œ°Maj‹Sèti°ics
.
byãsLive
);

127 
s
->
hóp
.
ﬁdGíSize
 = (
size_t
)(s->
‰⁄tõr
 - s->hóp.
°¨t
);

128 
	`£tGCSèãCuºítHóp
 (
s
, 0, 0);

130 
GC_UM_Chunk
 
√xt_chunk
 = 
NULL
;

131 
√xt_chunk
 = 
	`ÆlocNextChunk
(
s
, &(s->
umhóp
));

132 
√xt_chunk
->√xt_chunk = 
NULL
;

133 
s
->
um‰⁄tõr
 = (
Poöãr
Ë
√xt_chunk
->
ml_obje˘
;

136 
thªad
 = 
	`√wThªad
 (
s
, 
	`sizeofSèckInôülRe£rved
 (s));

137 
	`swôchToThªad
 (
s
, 
	`poöãrToObj±r
((
poöãr
)
thªad
 - 
	`off£tofThªad
 (s), s->
hóp
.
°¨t
));

138 i‡(
DEBUG_MEM
) {

139 
	`Ârötf
(
°dîr
, "UMFr⁄tõ∏°¨t: "
FMTPTR
"\n", (
uöçå_t
)(
s
->
um‰⁄tõr
));

141 
	}
}

	@init-world.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

23 
	sGC_ötInfInô
 {

24 
uöt32_t
 
	mglobÆIndex
;

25 c⁄° *
	mml°r
;

29 
	sGC_ve˘‹Inô
 {

30 
size_t
 
	mñemítSize
;

31 
uöt32_t
 
	mglobÆIndex
;

32 
GC_¨øyLígth
 
	mÀngth
;

33 
poöãr
 
	mw‹ds
;

38 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

40 
ölöe
 
size_t
 
sizeofInôülByãsLive
 (
GC_°©e
 
s
);

41 
öôVe˘‹s
 (
GC_°©e
 
s
);

42 
öôW‹ld
 (
GC_°©e
 
s
);

	@init.c

14 
boﬁ
 
	$°rögToBoﬁ
 (*
s
) {

15 i‡(0 =
	`°rcmp
 (
s
, "false"))

16  
FALSE
;

17 i‡(0 =
	`°rcmp
 (
s
, "true"))

18  
TRUE
;

19 
	`dõ
 ("InvÆid @MLt⁄ boﬁ: %s.", 
s
);

20 
	}
}

24 
gdtﬂ__°πof
 (const *, **);

26 
	$°rögToFlﬂt
 (*
s
) {

27 *
íd±r
;

28 
f
;

30 
f
 = 
	`gdtﬂ__°πof
 (
s
, &
íd±r
);

31 i‡(
s
 =
íd±r
)

32 
	`dõ
 ("InvÆid @MLt⁄ flﬂt: %s.", 
s
);

33  
f
;

34 
	}
}

36 
size_t
 
	$°rögToByãs
 (*
s
) {

37 
d
;

38 *
íd±r
;

39 
size_t
 
Á˘‹
;

41 
d
 = 
	`°πod
 (
s
, &
íd±r
);

42 i‡(
s
 =
íd±r
)

43 
bad
;

44 *
íd±r
++) {

47 
Á˘‹
 = 1024 * 1024 * 1024;

51 
Á˘‹
 = 1024;

55 
Á˘‹
 = 1024 * 1024;

58 
bad
;

60 
d
 *
Á˘‹
;

61 
	`u∆ess
 (*
íd±r
 == '\0'

62 
™d
 0.0 <
d


63 
™d
 
d
 <()
SIZE_MAX
)

64 
bad
;

65  (
size_t
)
d
;

66 
bad
:

67 
	`dõ
 ("InvÆid @MLt⁄ mem‹yámou¡: %s.", 
s
);

68 
	}
}

74 
	$¥o˚ssAtMLt⁄
 (
GC_°©e
 
s
, 
¨gc
, **
¨gv
,

75 **
w‹ldFûe
) {

76 
i
;

78 
i
 = 1;

79 
s
->
c⁄åﬁs
.
mayPro˚ssAtMLt⁄


80 
™d
 
i
 < 
¨gc


81 
	`™d
 (0 =
	`°rcmp
 (
¨gv
 [
i
], "@MLton"))) {

82 
boﬁ
 
d⁄e
;

84 
i
++;

85 
d⁄e
 = 
FALSE
;

86 !
d⁄e
) {

87 i‡(
i
 =
¨gc
)

88 
	`dõ
 ("Missing --átÉnd of @MLtonárgs.");

90 *
¨g
;

92 
¨g
 = 
¨gv
[
i
];

93 i‡(0 =
	`°rcmp
 (
¨g
, "copy-generational-ratio")) {

94 
i
++;

95 i‡(
i
 =
¨gc
)

96 
	`dõ
 ("@MLton copy-generational-ratio missingárgument.");

97 
s
->
c⁄åﬁs
.
øtios
.
c›yGíî©i⁄Æ
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

98 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
c›yGíî©i⁄Æ
)

99 
	`dõ
 ("@MLton copy-generational-ratioárgument must be greaterÅhan 1.0.");

100 } i‡(0 =
	`°rcmp
 (
¨g
, "copy-ratio")) {

101 
i
++;

102 i‡(
i
 =
¨gc
)

103 
	`dõ
 ("@MLton copy-ratio missingárgument.");

104 
s
->
c⁄åﬁs
.
øtios
.
c›y
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

105 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
c›y
)

106 
	`dõ
 ("@MLton copy-ratioárgument must be greaterÅhan 1.0.");

107 } i‡(0 =
	`°rcmp
 (
¨g
, "fixed-heap")) {

108 
i
++;

109 i‡(
i
 =
¨gc
)

110 
	`dõ
 ("@MLton fixed-heap missingárgument.");

111 
s
->
c⁄åﬁs
.
fixedHóp
 = 
	`Æign
 (
	`°rögToByãs
 (
¨gv
[
i
++]),

112 2 * 
s
->
sysvÆs
.
∑geSize
);

113 } i‡(0 =
	`°rcmp
 (
¨g
, "gc-messages")) {

114 
i
++;

115 
s
->
c⁄åﬁs
.
mesßges
 = 
TRUE
;

116 } i‡(0 =
	`°rcmp
 (
¨g
, "gc-summary")) {

117 
i
++;

118 
s
->
c⁄åﬁs
.
summ¨y
 = 
TRUE
;

119 } i‡(0 =
	`°rcmp
 (
¨g
, "grow-ratio")) {

120 
i
++;

121 i‡(
i
 =
¨gc
)

122 
	`dõ
 ("@MLton grow-ratio missingárgument.");

123 
s
->
c⁄åﬁs
.
øtios
.
grow
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

124 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
grow
)

125 
	`dõ
 ("@MLton grow-ratioárgument must be greaterÅhan 1.0.");

126 } i‡(0 =
	`°rcmp
 (
¨g
, "hash-cons")) {

127 
i
++;

128 i‡(
i
 =
¨gc
)

129 
	`dõ
 ("@MLton hash-cons missingárgument.");

130 
s
->
c⁄åﬁs
.
øtios
.
hashC⁄s
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

131 
	`u∆ess
 (0.0 <
s
->
c⁄åﬁs
.
øtios
.
hashC⁄s


132 
™d
 
s
->
c⁄åﬁs
.
øtios
.
hashC⁄s
 <= 1.0)

133 
	`dõ
 ("@MLton hash-consárgument must be between 0.0ánd 1.0.");

134 } i‡(0 =
	`°rcmp
 (
¨g
, "live-ratio")) {

135 
i
++;

136 i‡(
i
 =
¨gc
)

137 
	`dõ
 ("@MLtonÜive-ratio missingárgument.");

138 
s
->
c⁄åﬁs
.
øtios
.
live
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

139 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
live
)

140 
	`dõ
 ("@MLtonÜive-ratioárgument must be greaterÅhan 1.0.");

141 } i‡(0 =
	`°rcmp
 (
¨g
, "load-world")) {

142 
	`u∆ess
 (
s
->
c⁄åﬁs
.
mayLﬂdW‹ld
)

143 
	`dõ
 ("MayÇotÜoad world.");

144 
i
++;

145 
s
->
amOrigöÆ
 = 
FALSE
;

146 i‡(
i
 =
¨gc
)

147 
	`dõ
 ("@MLtonÜoad-world missingárgument.");

148 *
w‹ldFûe
 = 
¨gv
[
i
++];

149 } i‡(0 =
	`°rcmp
 (
¨g
, "mark-compact-generational-ratio")) {

150 
i
++;

151 i‡(
i
 =
¨gc
)

152 
	`dõ
 ("@MLton mark-compact-generational-ratio missingárgument.");

153 
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘Gíî©i⁄Æ
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

154 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘Gíî©i⁄Æ
)

155 
	`dõ
 ("@MLton mark-compact-generational-ratioárgument must be greaterÅhan 1.0.");

156 } i‡(0 =
	`°rcmp
 (
¨g
, "mark-compact-ratio")) {

157 
i
++;

158 i‡(
i
 =
¨gc
)

159 
	`dõ
 ("@MLton mark-compact-ratio missingárgument.");

160 
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

161 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘
)

162 
	`dõ
 ("@MLton mark-compact-ratioárgument must be greaterÅhan 1.0.");

163 } i‡(0 =
	`°rcmp
 (
¨g
, "max-heap")) {

164 
i
++;

165 i‡(
i
 =
¨gc
)

166 
	`dõ
 ("@MLton max-heap missingárgument.");

167 
s
->
c⁄åﬁs
.
maxHóp
 = 
	`Æign
 (
	`°rögToByãs
 (
¨gv
[
i
++]),

168 2 * 
s
->
sysvÆs
.
∑geSize
);

169 } i‡(0 =
	`°rcmp
 (
¨g
, "may-page-heap")) {

170 
i
++;

171 i‡(
i
 =
¨gc
)

172 
	`dõ
 ("@MLton may-page-heap missingárgument.");

173 
s
->
c⁄åﬁs
.
mayPageHóp
 = 
	`°rögToBoﬁ
 (
¨gv
[
i
++]);

174 } i‡(0 =
	`°rcmp
 (
¨g
, "no-load-world")) {

175 
i
++;

176 
s
->
c⁄åﬁs
.
mayLﬂdW‹ld
 = 
FALSE
;

177 } i‡(0 =
	`°rcmp
 (
¨g
, "nursery-ratio")) {

178 
i
++;

179 i‡(
i
 =
¨gc
)

180 
	`dõ
 ("@MLtonÇursery-ratio missingárgument.");

181 
s
->
c⁄åﬁs
.
øtios
.
nur£ry
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

182 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
nur£ry
)

183 
	`dõ
 ("@MLtonÇursery-ratioárgument must be greaterÅhan 1.0.");

184 } i‡(0 =
	`°rcmp
 (
¨g
, "ram-slop")) {

185 
i
++;

186 i‡(
i
 =
¨gc
)

187 
	`dõ
 ("@MLtonÑam-slop missingárgument.");

188 
s
->
c⁄åﬁs
.
øtios
.
ømSl›
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

189 } i‡(0 =
	`°rcmp
 (
¨g
, "show-sources")) {

190 
	`showSour˚s
 (
s
);

191 
	`exô
 (0);

192 } i‡(0 =
	`°rcmp
 (
¨g
, "stop")) {

193 
i
++;

194 
s
->
c⁄åﬁs
.
mayPro˚ssAtMLt⁄
 = 
FALSE
;

195 } i‡(0 =
	`°rcmp
 (
¨g
, "stack-current-grow-ratio")) {

196 
i
++;

197 i‡(
i
 =
¨gc
)

198 
	`dõ
 ("@MLton stack-current-grow-ratio missingárgument.");

199 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítGrow
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

200 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítGrow
)

201 
	`dõ
 ("@MLton stack-current-grow-ratioárgument must greaterÅhan 1.0.");

202 } i‡(0 =
	`°rcmp
 (
¨g
, "stack-current-max-reserved-ratio")) {

203 
i
++;

204 i‡(
i
 =
¨gc
)

205 
	`dõ
 ("@MLton stack-current-max-reserved-ratio missingárgument.");

206 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítMaxRe£rved
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

207 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítMaxRe£rved
)

208 
	`dõ
 ("@MLton stack-current-max-reserved-ratioárgument must greaterÅhan 1.0.");

209 } i‡(0 =
	`°rcmp
 (
¨g
, "stack-current-permit-reserved-ratio")) {

210 
i
++;

211 i‡(
i
 =
¨gc
)

212 
	`dõ
 ("@MLton stack-current-permit-reserved-ratio missingárgument.");

213 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítPîmôRe£rved
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

214 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítPîmôRe£rved
)

215 
	`dõ
 ("@MLton stack-current-permit-reserved-ratioárgument must greaterÅhan 1.0.");

216 } i‡(0 =
	`°rcmp
 (
¨g
, "stack-current-shrink-ratio")) {

217 
i
++;

218 i‡(
i
 =
¨gc
)

219 
	`dõ
 ("@MLton stack-current-shrink-ratio missingárgument.");

220 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítShrök
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

221 
	`u∆ess
 (0.0 <
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítShrök


222 
™d
 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítShrök
 <= 1.0)

223 
	`dõ
 ("@MLton stack-current-shrink-ratioárgument must be between 0.0ánd 1.0.");

224 } i‡(0 =
	`°rcmp
 (
¨g
, "stack-max-reserved-ratio")) {

225 
i
++;

226 i‡(
i
 =
¨gc
)

227 
	`dõ
 ("@MLton stack-max-reserved-ratio missingárgument.");

228 
s
->
c⁄åﬁs
.
øtios
.
°ackMaxRe£rved
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

229 
	`u∆ess
 (1.0 < 
s
->
c⁄åﬁs
.
øtios
.
°ackMaxRe£rved
)

230 
	`dõ
 ("@MLton stack-max-reserved-ratioárgument must greaterÅhan 1.0.");

231 } i‡(0 =
	`°rcmp
 (
¨g
, "stack-shrink-ratio")) {

232 
i
++;

233 i‡(
i
 =
¨gc
)

234 
	`dõ
 ("@MLton stack-shrink-ratio missingárgument.");

235 
s
->
c⁄åﬁs
.
øtios
.
°ackShrök
 = 
	`°rögToFlﬂt
 (
¨gv
[
i
++]);

236 
	`u∆ess
 (0.0 <
s
->
c⁄åﬁs
.
øtios
.
°ackShrök


237 
™d
 
s
->
c⁄åﬁs
.
øtios
.
°ackShrök
 <= 1.0)

238 
	`dõ
 ("@MLton stack-shrink-ratioárgument must be between 0.0ánd 1.0.");

239 } i‡(0 =
	`°rcmp
 (
¨g
, "use-mmap")) {

240 
i
++;

241 i‡(
i
 =
¨gc
)

242 
	`dõ
 ("@MLton use-mmap missingárgument.");

243 
	`GC_£tCygwöU£Mm≠
 (
	`°rögToBoﬁ
 (
¨gv
[
i
++]));

244 } i‡(0 =
	`°rcmp
 (
¨g
, "--")) {

245 
i
++;

246 
d⁄e
 = 
TRUE
;

247 } i‡(
i
 > 1)

248 
	`dõ
 ("Så™gê@MLt⁄árg: %s", 
¨gv
[
i
]);

249 
d⁄e
 = 
TRUE
;

253  
i
;

254 
	}
}

256 
	$GC_öô
 (
GC_°©e
 
s
, 
¨gc
, **
¨gv
) {

257 *
w‹ldFûe
;

258 
ªs
;

260 
	`as£π
 (
s
->
Æignmít
 >
GC_MODEL_MINALIGN
);

261 
	`as£π
 (
	`isAlig√d
 ( (
GC_°ack
), 
s
->
Æignmít
));

264 
	`as£π
 (
	`sizeofThªad
 (
s
) == sizeofThread (s));

265 
	`as£π
 (
	`sizeofWók
 (
s
) == sizeofWeak (s));

267 
s
->
amInGC
 = 
TRUE
;

268 
s
->
amOrigöÆ
 = 
TRUE
;

269 
s
->
©omicSèã
 = 0;

270 
s
->
ˇŒFromCH™dÀrThªad
 = 
BOGUS_OBJPTR
;

271 
s
->
c⁄åﬁs
.
fixedHóp
 = 0;

272 
s
->
c⁄åﬁs
.
maxHóp
 = 0;

273 
s
->
c⁄åﬁs
.
mayLﬂdW‹ld
 = 
TRUE
;

274 
s
->
c⁄åﬁs
.
mayPageHóp
 = 
FALSE
;

275 
s
->
c⁄åﬁs
.
mayPro˚ssAtMLt⁄
 = 
TRUE
;

276 
s
->
c⁄åﬁs
.
mesßges
 = 
FALSE
;

277 
s
->
c⁄åﬁs
.
ﬁdGíAºaySize
 = 0x100000;

278 
s
->
c⁄åﬁs
.
øtios
.
c›y
 = 4.0f;

279 
s
->
c⁄åﬁs
.
øtios
.
c›yGíî©i⁄Æ
 = 4.0f;

280 
s
->
c⁄åﬁs
.
øtios
.
grow
 = 8.0f;

281 
s
->
c⁄åﬁs
.
øtios
.
hashC⁄s
 = 0.0f;

282 
s
->
c⁄åﬁs
.
øtios
.
live
 = 8.0f;

283 
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘
 = 1.04f;

284 
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘Gíî©i⁄Æ
 = 8.0f;

285 
s
->
c⁄åﬁs
.
øtios
.
nur£ry
 = 10.0f;

286 
s
->
c⁄åﬁs
.
øtios
.
ømSl›
 = 0.5f;

287 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítGrow
 = 2.0f;

288 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítMaxRe£rved
 = 32.0f;

289 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítPîmôRe£rved
 = 4.0f;

290 
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítShrök
 = 0.5f;

291 
s
->
c⁄åﬁs
.
øtios
.
°ackMaxRe£rved
 = 8.0f;

292 
s
->
c⁄åﬁs
.
øtios
.
°ackShrök
 = 0.5f;

293 
s
->
c⁄åﬁs
.
summ¨y
 = 
FALSE
;

294 
s
->
cumuœtiveSèti°ics
.
byãsAŒoˇãd
 = 0;

295 
s
->
cumuœtiveSèti°ics
.
byãsC›õd
 = 0;

296 
s
->
cumuœtiveSèti°ics
.
byãsC›õdMö‹
 = 0;

297 
s
->
cumuœtiveSèti°ics
.
byãsHashC⁄£d
 = 0;

298 
s
->
cumuœtiveSèti°ics
.
byãsM¨kCom∑˘ed
 = 0;

299 
s
->
cumuœtiveSèti°ics
.
byãsSˇ¬edMö‹
 = 0;

300 
s
->
cumuœtiveSèti°ics
.
maxByãsLive
 = 0;

301 
s
->
cumuœtiveSèti°ics
.
maxHópSize
 = 0;

302 
s
->
cumuœtiveSèti°ics
.
maxPau£Time
 = 0;

303 
s
->
cumuœtiveSèti°ics
.
maxSèckSize
 = 0;

304 
s
->
cumuœtiveSèti°ics
.
numC¨dsM¨ked
 = 0;

305 
s
->
cumuœtiveSèti°ics
.
numC›yögGCs
 = 0;

306 
s
->
cumuœtiveSèti°ics
.
numHashC⁄sGCs
 = 0;

307 
s
->
cumuœtiveSèti°ics
.
numM¨kCom∑˘GCs
 = 0;

308 
s
->
cumuœtiveSèti°ics
.
numMö‹GCs
 = 0;

309 
	`rußgeZîo
 (&
s
->
cumuœtiveSèti°ics
.
ru_gc
);

310 
	`rußgeZîo
 (&
s
->
cumuœtiveSèti°ics
.
ru_gcC›yög
);

311 
	`rußgeZîo
 (&
s
->
cumuœtiveSèti°ics
.
ru_gcM¨kCom∑˘
);

312 
	`rußgeZîo
 (&
s
->
cumuœtiveSèti°ics
.
ru_gcMö‹
);

313 
s
->
cuºítThªad
 = 
BOGUS_OBJPTR
;

314 
s
->
hashC⁄sDurögGC
 = 
FALSE
;

315 
	`öôHóp
 (
s
, &s->
hóp
);

316 
	`öôUMHóp
 (
s
, &s->
umhóp
);

317 
	`öôUMAºayHóp
 (
s
, &s->
um¨hóp
);

318 
s
->
œ°Maj‹Sèti°ics
.
byãsHashC⁄£d
 = 0;

319 
s
->
œ°Maj‹Sèti°ics
.
byãsLive
 = 0;

320 
s
->
œ°Maj‹Sèti°ics
.
köd
 = 
GC_COPYING
;

321 
s
->
œ°Maj‹Sèti°ics
.
numMö‹GCs
 = 0;

322 
s
->
ßvedThªad
 = 
BOGUS_OBJPTR
;

323 
	`öôHóp
 (
s
, &s->
£c⁄d¨yHóp
);

324 
s
->
sig«lH™dÀrThªad
 = 
BOGUS_OBJPTR
;

325 
s
->
sig«lsInfo
.
amInSig«lH™dÀr
 = 
FALSE
;

326 
s
->
sig«lsInfo
.
gcSig«lH™dÀd
 = 
FALSE
;

327 
s
->
sig«lsInfo
.
gcSig«lPídög
 = 
FALSE
;

328 
s
->
sig«lsInfo
.
sig«lIsPídög
 = 
FALSE
;

329 
	`sigem±y£t
 (&
s
->
sig«lsInfo
.
sig«lsH™dÀd
);

330 
	`sigem±y£t
 (&
s
->
sig«lsInfo
.
sig«lsPídög
);

331 
s
->
sysvÆs
.
∑geSize
 = 
	`GC_∑geSize
 ();

332 
s
->
sysvÆs
.
physMem
 = 
	`GC_physMem
 ();

333 
s
->
wóks
 = 
NULL
;

334 
s
->
ßveW‹ldSètus
 = 
åue
;

336 
	`öôI¡Inf
 (
s
);

337 
	`öôSig«lSèck
 (
s
);

338 
w‹ldFûe
 = 
NULL
;

340 
	`u∆ess
 (
	`isAlig√d
 (
s
->
sysvÆs
.
∑geSize
, 
CARD_SIZE
))

341 
	`dõ
 ("Page size must beá multiple of card size.");

342 
	`¥o˚ssAtMLt⁄
 (
s
, s->
©MLt⁄sLígth
, s->
©MLt⁄s
, &
w‹ldFûe
);

343 
ªs
 = 
	`¥o˚ssAtMLt⁄
 (
s
, 
¨gc
, 
¨gv
, &
w‹ldFûe
);

344 i‡(
s
->
c⁄åﬁs
.
fixedHóp
 > 0 
™d
 s->c⁄åﬁs.
maxHóp
 > 0)

345 
	`dõ
 ("Cannot use both fixed-heapánd max-heap.");

346 
	`u∆ess
 (
s
->
c⁄åﬁs
.
øtios
.
m¨kCom∑˘
 <s->c⁄åﬁs.øtios.
c›y


347 
™d
 
s
->
c⁄åﬁs
.
øtios
.
c›y
 <s->c⁄åﬁs.øtios.
live
)

348 
	`dõ
 ("Ratios must satisfy mark-compact-ratio <= copy-ratio <=Üive-ratio.");

349 
	`u∆ess
 (
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítPîmôRe£rved


350 <
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítMaxRe£rved
)

351 
	`dõ
 ("Ratios must satisfy stack-current-permit-reserved <= stack-current-max-reserved.");

357 
uötmax_t
 
øm
;

358 
øm
 = 
	`ÆignMax
 ((
uötmax_t
)(
s
->
c⁄åﬁs
.
øtios
.
ømSl›
 * ()(s->
sysvÆs
.
physMem
)),

359 (
uötmax_t
)(
s
->
sysvÆs
.
∑geSize
));

360 
øm
 = 
	`mö
 (øm, 
	`ÆignMaxDown
((
uötmax_t
)
SIZE_MAX
, (uötmax_t)(
s
->
sysvÆs
.
∑geSize
)));

361 
s
->
sysvÆs
.
øm
 = (
size_t
)ram;

362 i‡(
DEBUG
 
‹
 
DEBUG_RESIZING
 o∏
s
->
c⁄åﬁs
.
mesßges
)

363 
	`Ârötf
 (
°dîr
, "[GC: Found %s bytes of RAM; using %s bytes (%.1f%% of RAM).]\n",

364 
	`uötmaxToCommaSåög
(
s
->
sysvÆs
.
physMem
),

365 
	`uötmaxToCommaSåög
(
s
->
sysvÆs
.
øm
),

366 100.0 * (()
øm
 / ()(
s
->
sysvÆs
.
physMem
)));

367 i‡(
DEBUG_SOURCES
 
‹
 
DEBUG_PROFILE
) {

368 
uöt32_t
 
i
;

369 
i
 = 0; i < 
s
->
sour˚M≠s
.
‰ameSour˚sLígth
; i++) {

370 
uöt32_t
 
j
;

371 
uöt32_t
 *
sour˚Seq
;

372 
	`Ârötf
 (
°dîr
, "%"
PRIu32
"\n", 
i
);

373 
sour˚Seq
 = 
s
->
sour˚M≠s
.
sour˚Seqs
[s->sour˚M≠s.
‰ameSour˚s
[
i
]];

374 
j
 = 1; j <
sour˚Seq
[0]; j++)

375 
	`Ârötf
 (
°dîr
, "\t%s\n",

376 
s
->
sour˚M≠s
.
sour˚Names
[

377 
s
->
sour˚M≠s
.
sour˚s
[
sour˚Seq
[
j
]].
sour˚NameIndex


386 
	`öôProfûög
 (
s
);

387 i‡(
s
->
amOrigöÆ
) {

388 
	`öôW‹ld
 (
s
);

392 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹
 (
s
, 
TRUE
, 
FALSE
));

394 
	`lﬂdW‹ldFromFûeName
 (
s
, 
w‹ldFûe
);

395 i‡(
s
->
¥ofûög
.
isOn
 
™d
 s->¥ofûög.
°ack
)

396 
	`f‹óchSèckFøme
 (
s
, 
íãrFømeF‹Profûög
);

397 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹
 (
s
, 
TRUE
, TRUE));

399 
s
->
amInGC
 = 
FALSE
;

401  
ªs
;

402 
	}
}

	@init.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
¥o˚ssAtMLt⁄
 (
GC_°©e
 
s
, 
¨gc
,

12 **
¨gv
, **
w‹ldFûe
);

16 
PRIVATE
 
GC_öô
 (
GC_°©e
 
s
, 
¨gc
, **
¨gv
);

	@int-inf.c

13 
ölöe
 
boﬁ
 
	$isSmÆl
 (
obj±r
 
¨g
) {

14  (
¨g
 & 1);

15 
	}
}

17 
ölöe
 
boﬁ
 
	$¨eSmÆl
 (
obj±r
 
¨g1
, obj±∏
¨g2
) {

18  ((
¨g1
 & 
¨g2
Ë& (
obj±r
)1);

19 
	}
}

24 
ölöe
 
GC_ötInf
 
	$toBignum
 (
GC_°©e
 
s
, 
obj±r
 
¨g
) {

25 
GC_ötInf
 
bp
;

27 
	`as£π
 (
nŸ
 
	`isSmÆl
(
¨g
));

28 
bp
 = (
GC_ötInf
)(
	`obj±rToPoöãr
(
¨g
, 
s
->
hóp
.
°¨t
)

29 - (
	`off£tof
(
GC_ötInf
, 
obj
)

30 + 
	`off£tof
(
GC_ötInf_obj
, 
i¢eg
)));

31 i‡(
DEBUG_INT_INF
)

32 
	`Ârötf
 (
°dîr
, "bp->hódî = "
FMTHDR
"\n", 
bp
->
hódî
);

33 
	`as£π
 (
bp
->
hódî
 =
GC_INTINF_HEADER
);

34  
bp
;

35 
	}
}

42 
fûlI¡InfArg
 (
GC_°©e
 
s
, 
obj±r
 
¨g
, 
__mpz_°ru˘
 *
ªs
,

43 
mp_limb_t
 
•a˚
[
LIMBS_PER_OBJPTR
 + 1]) {

44 
GC_ötInf
 
	gbp
;

46 i‡(
	gDEBUG_INT_INF
)

47 
Ârötf
 (
°dîr
, "fûlI¡InfArg ("
FMTOBJPTR
", "
FMTPTR
", "FMTPTR")\n",

48 
¨g
, (
uöçå_t
)
ªs
, (uöçå_t)
•a˚
);

49 i‡(
isSmÆl
(
¨g
)) {

50 
	gªs
->
	g_mp_Æloc
 = 
LIMBS_PER_OBJPTR
 + 1;

51 
	gªs
->
	g_mp_d
 = 
•a˚
;

52 i‡(
	g¨g
 =(
obj±r
)1) {

53 
ªs
->
_mp_size
 = 0;

55 c⁄° 
obj±r
 
	ghighBôMask
 = (obj±r)1 << (
CHAR_BIT
 * 
OBJPTR_SIZE
 - 1);

56 
boﬁ
 
	g√g
 = (
¨g
 & 
highBôMask
Ë!(
obj±r
)0;

57 i‡(
	g√g
) {

58 
	g¨g
 = -((
¨g
 >> 1Ë| 
highBôMask
);

60 
	g¨g
 = (
¨g
 >> 1);

62 
	gsize
;

63 i‡((
	gobj±r
Ë<(
mp_limb_t
)) {

64 
•a˚
[0] = (
mp_limb_t
)
¨g
;

65 
	gsize
 = 1;

67 
	gsize
 = 0;

68 
	g¨g
 != 0) {

69 
•a˚
[
size
] = (
mp_limb_t
)
¨g
;

75 
	g¨g
 = 
¨g
 >> ((
obj±r
Ë<(
mp_limb_t
) ?

76 0 : 
CHAR_BIT
 * (
mp_limb_t
));

77 
	gsize
++;

80 i‡(
	g√g
)

81 
	gsize
 = - 
size
;

82 
	gªs
->
	g_mp_size
 = 
size
;

85 
	gbp
 = 
toBignum
 (
s
, 
¨g
);

90 
	gªs
->
	g_mp_Æloc
 = ()(
bp
->
Àngth
 - 1);

91 
	gªs
->
	g_mp_d
 = (
mp_limb_t
*)(
bp
->
obj
.
limbs
);

92 
	gªs
->
	g_mp_size
 = 
bp
->
obj
.
i¢eg
 ? - 
ªs
->
_mp_Æloc
 :Ñes->_mp_alloc;

94 
as£π
 ((
ªs
->
_mp_size
 == 0)

95 
‹
 (
ªs
->
_mp_d
[‘es->
_mp_size
 < 0

96 ? - 
ªs
->
_mp_size


97 : 
ªs
->
_mp_size
) - 1] != 0));

98 i‡(
	gDEBUG_INT_INF_DETAILED
)

99 
Ârötf
 (
°dîr
, "arg --> %s\n",

100 
mpz_gë_°r
 (
NULL
, 10, 
ªs
));

106 
	$öôI¡InfRes
 (
GC_°©e
 
s
, 
__mpz_°ru˘
 *
ªs
,

107 
ARG_USED_FOR_ASSERT
 
size_t
 
byãs
) {

108 
GC_ötInf
 
bp
;

109 
size_t
 
∆imbs
;

111 
	`as£π
 (
byãs
 <(
size_t
)(
s
->
limôPlusSl›
 - s->
‰⁄tõr
));

112 
bp
 = (
GC_ötInf
)
s
->
‰⁄tõr
;

116 
∆imbs
 = ((
size_t
)(
s
->
limôPlusSl›
 - (
poöãr
)
bp
->
obj
.
limbs
)Ë/ ((
mp_limb_t
));

121 
ªs
->
_mp_Æloc
 = ()(
	`mö
(
∆imbs
,(
size_t
)
INT_MAX
));

122 
ªs
->
_mp_d
 = (
mp_limb_t
*)(
bp
->
obj
.
limbs
);

123 
ªs
->
_mp_size
 = 0;

124 
	}
}

134 
obj±r
 
	$föiI¡InfRes
 (
GC_°©e
 
s
, 
__mpz_°ru˘
 *
ªs
, 
size_t
 
byãs
) {

135 
GC_ötInf
 
bp
;

136 
size
;

138 
	`as£π
 ((
ªs
->
_mp_size
 == 0)

139 
	`‹
 (
ªs
->
_mp_d
[‘es->
_mp_size
 < 0

140 ? - 
ªs
->
_mp_size


141 : 
ªs
->
_mp_size
) - 1] != 0));

142 i‡(
DEBUG_INT_INF
)

143 
	`Ârötf
 (
°dîr
, "föiI¡InfRe†("
FMTPTR
", %"
PRIuMAX
")\n",

144 (
uöçå_t
)
ªs
, (
uötmax_t
)
byãs
);

145 i‡(
DEBUG_INT_INF_DETAILED
)

146 
	`Ârötf
 (
°dîr
, "res --> %s\n",

147 
	`mpz_gë_°r
 (
NULL
, 10, 
ªs
));

148 
bp
 = (
GC_ötInf
)((
poöãr
)
ªs
->
_mp_d


149 - (
	`off£tof
(
GC_ötInf
, 
obj
)

150 + 
	`off£tof
(
GC_ötInf_obj
, 
limbs
)));

151 
	`as£π
 (
ªs
->
_mp_d
 =(
mp_limb_t
*)(
bp
->
obj
.
limbs
));

152 
size
 = 
ªs
->
_mp_size
;

153 i‡(
size
 < 0) {

154 
bp
->
obj
.
i¢eg
 = 
TRUE
;

155 
size
 = - size;

157 
bp
->
obj
.
i¢eg
 = 
FALSE
;

158 
	`as£π
 (
size
 >= 0);

159 i‡(
size
 == 0)

160  (
obj±r
)1;

161 i‡(
size
 <
LIMBS_PER_OBJPTR
) {

162 i‡((
obj±r
Ë<(
mp_limb_t
)) {

163 
obj±r
 
™s
;

164 
mp_limb_t
 
vÆ
 = 
bp
->
obj
.
limbs
[0];

165 i‡(
bp
->
obj
.
i¢eg
) {

169 
™s
 = (
obj±r
)(- 
vÆ
);

170 
vÆ
 = val - 1;

175 
™s
 = (
obj±r
)
vÆ
;

181 i‡(
vÆ
 < (
mp_limb_t
)1<<((
obj±r
) > (mp_limb_t) ?

182 0 : 
CHAR_BIT
 * 
OBJPTR_SIZE
 - 2))

183  (
™s
<<1 | 1);

185 
obj±r
 
™s
, 
vÆ
;

186 
vÆ
 = (
obj±r
)(
bp
->
obj
.
limbs
[0]);

187 
i
 = 1; i < 
size
; i++) {

193 
vÆ
 = vÆ << ((
obj±r
Ë<(
mp_limb_t
) ?

194 0 : 
CHAR_BIT
 * (
mp_limb_t
));

195 
vÆ
 = vÆ & (
obj±r
)(
bp
->
obj
.
limbs
[
i
]);

197 i‡(
bp
->
obj
.
i¢eg
) {

201 
™s
 = - 
vÆ
;

202 
vÆ
 = val - 1;

207 
™s
 = 
vÆ
;

208 i‡(
vÆ
 < (
obj±r
)1<<(
CHAR_BIT
 * 
OBJPTR_SIZE
 - 2))

209  (
™s
<<1 | 1);

212 
	`£tFr⁄tõr
 (
s
, (
poöãr
)(&
bp
->
obj
.
limbs
[
size
]), 
byãs
);

213 
bp
->
cou¡î
 = (
GC_¨øyCou¡î
)0;

214 
bp
->
Àngth
 = (
GC_¨øyLígth
)(
size
 + 1);

215 
bp
->
hódî
 = 
GC_INTINF_HEADER
;

216  
	`poöãrToObj±r
 ((
poöãr
)&
bp
->
obj
, 
s
->
hóp
.
°¨t
);

217 
	}
}

219 
obj±r
 
I¡Inf_bö›
 (
GC_°©e
 
s
,

220 
obj±r
 
lhs
, obj±∏
rhs
, 
size_t
 
byãs
,

221 (*
bö›
)(
__mpz_°ru˘
 *
ªsmpz
,

222 c⁄° 
__mpz_°ru˘
 *
lhs•a˚
,

223 c⁄° 
__mpz_°ru˘
 *
rhs•a˚
)) {

224 
__mpz_°ru˘
 
lhsmpz
, 
rhsmpz
, 
ªsmpz
;

225 
mp_limb_t
 
lhs•a˚
[
LIMBS_PER_OBJPTR
 + 1], 
rhs•a˚
[LIMBS_PER_OBJPTR + 1];

227 i‡(
DEBUG_INT_INF
)

228 
	`Ârötf
 (
°dîr
, "I¡Inf_bö› ("
FMTOBJPTR
", "FMTOBJPTR", %"
PRIuMAX
")\n",

229 
lhs
, 
rhs
, (
uötmax_t
)
byãs
);

230 
	`öôI¡InfRes
 (
s
, &
ªsmpz
, 
byãs
);

231 
	`fûlI¡InfArg
 (
s
, 
lhs
, &
lhsmpz
, 
lhs•a˚
);

232 
	`fûlI¡InfArg
 (
s
, 
rhs
, &
rhsmpz
, 
rhs•a˚
);

233 
	`bö›
 (&
ªsmpz
, &
lhsmpz
, &
rhsmpz
);

234  
	`föiI¡InfRes
 (
s
, &
ªsmpz
, 
byãs
);

235 
	}
}

237 
obj±r
 
I¡Inf_un›
 (
GC_°©e
 
s
,

238 
obj±r
 
¨g
, 
size_t
 
byãs
,

239 (*
un›
)(
__mpz_°ru˘
 *
ªsmpz
,

240 c⁄° 
__mpz_°ru˘
 *
¨g•a˚
)) {

241 
__mpz_°ru˘
 
¨gmpz
, 
ªsmpz
;

242 
mp_limb_t
 
¨g•a˚
[
LIMBS_PER_OBJPTR
 + 1];

244 i‡(
DEBUG_INT_INF
)

245 
	`Ârötf
 (
°dîr
, "I¡Inf_un› ("
FMTOBJPTR
", %"
PRIuMAX
")\n",

246 
¨g
, (
uötmax_t
)
byãs
);

248 
	`öôI¡InfRes
 (
s
, &
ªsmpz
, 
byãs
);

249 
	`fûlI¡InfArg
 (
s
, 
¨g
, &
¨gmpz
, 
¨g•a˚
);

250 
	`un›
 (&
ªsmpz
, &
¨gmpz
);

251  
	`föiI¡InfRes
 (
s
, &
ªsmpz
, 
byãs
);

252 
	}
}

254 
obj±r
 
I¡Inf_sh›
 (
GC_°©e
 
s
,

255 
obj±r
 
¨g
, 
W‹d32_t
 
shi·
, 
size_t
 
byãs
,

256 (*
sh›
)(
__mpz_°ru˘
 *
ªsmpz
,

257 c⁄° 
__mpz_°ru˘
 *
¨g•a˚
,

258 
shi·
))

260 
__mpz_°ru˘
 
¨gmpz
, 
ªsmpz
;

261 
mp_limb_t
 
¨g•a˚
[
LIMBS_PER_OBJPTR
 + 1];

263 i‡(
DEBUG_INT_INF
)

264 
	`Ârötf
 (
°dîr
, "I¡Inf_sh› ("
FMTOBJPTR
", %"
PRIu32
", %"
PRIuMAX
")\n",

265 
¨g
, 
shi·
, (
uötmax_t
)
byãs
);

267 
	`öôI¡InfRes
 (
s
, &
ªsmpz
, 
byãs
);

268 
	`fûlI¡InfArg
 (
s
, 
¨g
, &
¨gmpz
, 
¨g•a˚
);

269 
	`sh›
 (&
ªsmpz
, &
¨gmpz
, ()
shi·
);

270  
	`föiI¡InfRes
 (
s
, &
ªsmpz
, 
byãs
);

271 
	}
}

273 
I¡32_t
 
I¡Inf_cmp›
 (
GC_°©e
 
s
, 
obj±r
 
lhs
, obj±∏
rhs
,

274 (*
cmp›
)(c⁄° 
__mpz_°ru˘
 *
lhs•a˚
,

275 c⁄° 
__mpz_°ru˘
 *
rhs•a˚
))

277 
__mpz_°ru˘
 
lhsmpz
, 
rhsmpz
;

278 
mp_limb_t
 
lhs•a˚
[
LIMBS_PER_OBJPTR
 + 1], 
rhs•a˚
[LIMBS_PER_OBJPTR + 1];

279 
ªs
;

281 i‡(
DEBUG_INT_INF
)

282 
	`Ârötf
 (
°dîr
, "I¡Inf_cmp› ("
FMTOBJPTR
", "FMTOBJPTR")\n",

283 
lhs
, 
rhs
);

284 
	`fûlI¡InfArg
 (
s
, 
lhs
, &
lhsmpz
, 
lhs•a˚
);

285 
	`fûlI¡InfArg
 (
s
, 
rhs
, &
rhsmpz
, 
rhs•a˚
);

286 
ªs
 = 
	`cmp›
 (&
lhsmpz
, &
rhsmpz
);

287 i‡(
ªs
 < 0)  -1;

288 i‡(
ªs
 > 0)  1;

290 
	}
}

292 
obj±r
 
I¡Inf_°r›
 (
GC_°©e
 
s
, obj±∏
¨g
, 
I¡32_t
 
ba£
, 
size_t
 
byãs
,

293 *(*
°r›
)(*
°r
,

294 
ba£
,

295 c⁄° 
__mpz_°ru˘
 *
¨g•a˚
))

297 
GC_°rög8
 
	g•
;

298 
__mpz_°ru˘
 
	g¨gmpz
;

299 
mp_limb_t
 
	g¨g•a˚
[
LIMBS_PER_OBJPTR
 + 1];

300 *
	g°r
;

301 
size_t
 
	gsize
;

303 i‡(
	gDEBUG_INT_INF
)

304 
Ârötf
 (
°dîr
, "I¡Inf_°r› ("
FMTOBJPTR
", %"
PRId32
", %"
PRIuMAX
")\n",

305 
¨g
, 
ba£
, (
uötmax_t
)
byãs
);

306 
as£π
 (
ba£
 == 2 || base == 8 || base == 10 || base == 16);

307 
fûlI¡InfArg
 (
s
, 
¨g
, &
¨gmpz
, 
¨g•a˚
);

308 
as£π
 (
byãs
 <(
size_t
)(
s
->
limôPlusSl›
 - s->
‰⁄tõr
));

309 
	g•
 = (
GC_°rög8
)
s
->
‰⁄tõr
;

310 
	g°r
 = 
°r›
 ((*)&
•
->
obj
, -
ba£
, &
¨gmpz
);

311 
as£π
 (
°r
 =(*)&
•
->
obj
);

312 
	gsize
 = 
°æí
(
°r
);

313 i‡(
	g•
->
	gobj
.
	gch¨s
[0] == '-')

314 
•
->
obj
.
ch¨s
[0] = '~';

315 
£tFr⁄tõr
 (
s
, (
poöãr
)&
•
->
obj
 + 
size
, 
byãs
);

316 
	g•
->
	gcou¡î
 = (
GC_¨øyCou¡î
)0;

317 
	g•
->
	gÀngth
 = (
GC_¨øyLígth
)
size
;

318 
	g•
->
	ghódî
 = 
GC_STRING8_HEADER
;

319  
poöãrToObj±r
 ((
poöãr
)&
•
->
obj
, 
s
->
hóp
.
°¨t
);

366 
öôI¡Inf
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
) {

	@int-inf.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

15 
	sGC_ötInf_obj
 {

16 
mp_limb_t
 
	mi¢eg
;

17 
mp_limb_t
 
	mlimbs
[1];

19 
	sGC_ötInf
 {

20 
GC_¨øyCou¡î
 
	mcou¡î
;

21 
GC_¨øyLígth
 
	mÀngth
;

22 
GC_hódî
 
	mhódî
;

23 
GC_ötInf_obj
 
	mobj
;

24 } 
	t__©åibuã__
 ((
	t∑cked
)Ë*
	tGC_ötInf
;

26 
COMPILE_TIME_ASSERT
(
GC_ötInf__obj_∑cked
,

27 
off£tof
(
GC_ötInf
, 
obj
) ==

28 (
GC_¨øyCou¡î
)

29 + (
GC_¨øyLígth
)

30 + (
GC_hódî
));

31 
COMPILE_TIME_ASSERT
(
GC_ötInf_obj__i¢eg_∑cked
,

32 
off£tof
(
GC_ötInf_obj
, 
i¢eg
) ==

34 
COMPILE_TIME_ASSERT
(
GC_ötInf_obj__limbs_∑cked
,

35 
off£tof
(
GC_ötInf_obj
, 
limbs
) ==

36 0 + (
mp_limb_t
));

40 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

42 
COMPILE_TIME_ASSERT
(
sizeof_mp_limb_t__is_four_‹_eight
,

43 ((
mp_limb_t
) == 4 || (mp_limb_t) == 8));

44 
	#GC_INTINF_HEADER
 ( \

45 
CHAR_BIT
 * (
mp_limb_t
) == 32 ? \

46 
GC_WORD32_VECTOR_HEADER
 : ( \

47 
CHAR_BIT
 * (
mp_limb_t
) == 64 ? \

48 
GC_WORD64_VECTOR_HEADER
 : ( 0 ) ) )

	)

50 
COMPILE_TIME_ASSERT
(
sizeof_mp_limb_t__com∑t__sizeof_obj±r
,

51 (
obj±r
Ë<(
mp_limb_t
) ?

52 (
mp_limb_t
Ë% (
obj±r
) == 0 :

53 (
obj±r
Ë% (
mp_limb_t
) == 0);

55 
	#LIMBS_PER_OBJPTR
 ( \

56 (
mp_limb_t
Ë>(
obj±r
) ? \

57 1 : ()((
obj±r
Ë/ (
mp_limb_t
)))

	)

59 
PRIVATE
 
öôI¡Inf
 (
GC_°©e
 
s
);

60 
ölöe
 
fûlI¡InfArg
 (
GC_°©e
 
s
, 
obj±r
 
¨g
, 
__mpz_°ru˘
 *
ªs
,

61 
mp_limb_t
 
•a˚
[
LIMBS_PER_OBJPTR
 + 1]);

62 
ölöe
 
öôI¡InfRes
 (
GC_°©e
 
s
, 
__mpz_°ru˘
 *
ªs
, 
size_t
 
byãs
);

63 
ölöe
 
obj±r
 
föiI¡InfRes
 (
GC_°©e
 
s
, 
__mpz_°ru˘
 *
ªs
, 
size_t
 
byãs
);

67 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

69 
PRIVATE
 
obj±r
 
I¡Inf_bö›
 (
GC_°©e
 
s
, obj±∏
lhs
, obj±∏
rhs
, 
size_t
 
byãs
,

70 (*
bö›
)(
__mpz_°ru˘
 *
ªsmpz
,

71 c⁄° 
__mpz_°ru˘
 *
lhs•a˚
,

72 c⁄° 
__mpz_°ru˘
 *
rhs•a˚
));

73 
PRIVATE
 
obj±r
 
	`I¡Inf_un›
 (
GC_°©e
 
s
, obj±∏
¨g
, 
size_t
 
byãs
,

74 (*
un›
)(
__mpz_°ru˘
 *
ªsmpz
,

75 c⁄° 
__mpz_°ru˘
 *
¨g•a˚
));

76 
PRIVATE
 
obj±r
 
	`I¡Inf_sh›
 (
GC_°©e
 
s
, obj±∏
¨g
, 
W‹d32_t
 
shi·
, 
size_t
 
byãs
,

77 (*
sh›
)(
__mpz_°ru˘
 *
ªsmpz
,

78 c⁄° 
__mpz_°ru˘
 *
¨g•a˚
,

79 
shi·
));

80 
PRIVATE
 
I¡32_t
 
	`I¡Inf_cmp›
 (
GC_°©e
 
s
, 
obj±r
 
lhs
, obj±∏
rhs
,

81 (*
cmp›
)(c⁄° 
__mpz_°ru˘
 *
lhs•a˚
,

82 c⁄° 
__mpz_°ru˘
 *
rhs•a˚
));

83 
PRIVATE
 
obj±r
 
	`I¡Inf_°r›
 (
GC_°©e
 
s
, obj±∏
¨g
, 
I¡32_t
 
ba£
, 
size_t
 
byãs
,

84 *(*
°r›
)(*
°r
,

85 
ba£
,

86 c⁄° 
__mpz_°ru˘
 *
¨g•a˚
));

	@invariant.c

10 #i‡
ASSERT


11 
	$as£πIsObj±rInFromS∑˚
 (
GC_°©e
 
s
, 
obj±r
 *
›p
) {

12 
	`as£π
 (
	`isObj±rInFromS∑˚
 (
s
, *
›p
));

13 
	`u∆ess
 (
	`isObj±rInFromS∑˚
 (
s
, *
›p
))

14 
	`dõ
 ("gc.c:ássertIsObjptrInFromSpace "

15 "›∞"
FMTPTR
" "

16 "*›∞"
FMTOBJPTR
"\n",

17 (
uöçå_t
)
›p
, *opp);

23 i‡(
FALSE
 
™d
 
s
->
muèt‹M¨ksC¨ds


24 
™d
 
	`isPoöãrInOldGí
 (
s
, (
poöãr
)
›p
)

25 
™d
 
	`isObj±rInNur£ry
 (
s
, *
›p
)

26 
™d
 
nŸ
 
	`isC¨dM¨ked
 (
s
, (
poöãr
)
›p
)) {

27 
	`di•œyGCSèã
 (
s
, 
°dîr
);

28 
	`dõ
 ("gc.c: i¡îgíî©i⁄ÆÖoöã∏‰om "
FMTPTR
"Åÿ"
FMTOBJPTR
" with unmarked card.\n",

29 (
uöçå_t
)
›p
, *opp);

31 
	}
}

33 
boﬁ
 
	$öv¨ü¡F‹GC
 (
GC_°©e
 
s
) {

34 i‡(
DEBUG
)

35 
	`Ârötf
 (
°dîr
, "invariantForGC\n");

37 
i
 = 0; i < 
s
->
‰ameLayoutsLígth
; ++i) {

38 
GC_‰ameLayout
 
œyout
;

40 
œyout
 = &(
s
->
‰ameLayouts
[
i
]);

41 i‡(
œyout
->
size
 > 0) {

42 
GC_‰ameOff£ts
 
off£ts
;

44 
	`as£π
 (
œyout
->
size
 <
s
->
maxFømeSize
);

45 
off£ts
 = 
œyout
->offsets;

46 
j
 = 0; j < 
off£ts
[0]; ++j)

47 
	`as£π
 (
off£ts
[
j
 + 1] < 
œyout
->
size
);

51 i‡(
s
->
muèt‹M¨ksC¨ds
) {

52 
	`as£π
 (
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠
 ==

53 &(
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Absﬁuã


54 [
	`poöãrToC¨dM≠IndexAbsﬁuã
(
s
->
hóp
.
°¨t
)]));

55 
	`as£π
 (&(
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Absﬁuã


56 [
	`poöãrToC¨dM≠IndexAbsﬁuã
(
s
->
hóp
.
°¨t
 + s->hóp.
size
 - 1)])

57 < (
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠


58 + (
s
->
gíî©i⁄ÆM≠s
.
ˇrdM≠Lígth
 * 
CARD_MAP_ELEM_SIZE
)));

60 
	`as£π
 (
	`isAlig√d
 (
s
->
hóp
.
size
, s->
sysvÆs
.
∑geSize
));

61 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
s
->
hóp
.
°¨t
, 
CARD_SIZE
));

62 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, s->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
));

63 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, s->
hóp
.
nur£ry
));

64 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, s->
‰⁄tõr
));

65 
	`as£π
 (
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
 <s->hóp.
nur£ry
);

66 
	`as£π
 (
s
->
hóp
.
nur£ry
 <s->hóp.
°¨t
 + s->hóp.
size
);

67 
	`as£π
 (
s
->
hóp
.
nur£ry
 <s->
‰⁄tõr
);

68 
	`u∆ess
 (0 =
s
->
hóp
.
size
) {

69 
	`as£π
 (
s
->
‰⁄tõr
 <s->
limôPlusSl›
);

70 
	`as£π
 (
s
->
limô
 =s->
limôPlusSl›
 - 
GC_HEAP_LIMIT_SLOP
);

71 
	`as£π
 (
	`hasHópByãsFªe
 (
s
, 0, 0));

73 
	`as£π
 (
s
->
£c⁄d¨yHóp
.
°¨t
 =
NULL


74 
‹
 
s
->
hóp
.
size
 =s->
£c⁄d¨yHóp
.size);

76 
	`f‹óchGlobÆObj±r
 (
s
, 
as£πIsObj±rInFromS∑˚
);

77 
poöãr
 
back
 = 
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
;

78 i‡(
DEBUG_DETAILED
)

79 
	`Ârötf
 (
°dîr
, "Checking old generation.\n");

80 
	`f‹óchObj±rInR™ge
 (
s
, 
	`ÆignFr⁄tõr
 (s, s->
hóp
.
°¨t
), &
back
,

81 
as£πIsObj±rInFromS∑˚
, 
FALSE
);

82 i‡(
DEBUG_DETAILED
)

83 
	`Ârötf
 (
°dîr
, "CheckingÇursery.\n");

84 
	`f‹óchObj±rInR™ge
 (
s
, s->
hóp
.
nur£ry
, &s->
‰⁄tõr
,

85 
as£πIsObj±rInFromS∑˚
, 
FALSE
);

87 
GC_°ack
 
°ack
 = 
	`gëSèckCuºít
(
s
);

88 
	`as£π
 (
	`isSèckRe£rvedAlig√d
 (
s
, 
°ack
->
ª£rved
));

89 
	`as£π
 (
s
->
°ackBŸtom
 =
	`gëSèckBŸtom
 (s, 
°ack
));

90 
	`as£π
 (
s
->
°ackT›
 =
	`gëSèckT›
 (s, 
°ack
));

91 
	`as£π
 (
s
->
°ackLimô
 =
	`gëSèckLimô
 (s, 
°ack
));

92 
	`as£π
 (
s
->
°ackBŸtom
 <s->
°ackT›
);

93 
	`as£π
 (
°ack
->
u£d
 =
	`sizeofGCSèãCuºítSèckU£d
 (
s
));

94 
	`as£π
 (
°ack
->
u£d
 <°ack->
ª£rved
);

95 i‡(
DEBUG
)

96 
	`Ârötf
 (
°dîr
, "invariantForGCÖassed\n");

97  
TRUE
;

98 
	}
}

101 
boﬁ
 
	$öv¨ü¡F‹Muèt‹Fr⁄tõr
 (
GC_°©e
 
s
) {

102 
GC_thªad
 
thªad
 = 
	`gëThªadCuºít
(
s
);

103  (
thªad
->
byãsNìded


104 <(
size_t
)(
s
->
limôPlusSl›
 - s->
‰⁄tõr
));

105 
	}
}

107 
boﬁ
 
	$öv¨ü¡F‹Muèt‹Sèck
 (
GC_°©e
 
s
) {

108 
GC_°ack
 
°ack
 = 
	`gëSèckCuºít
(
s
);

109  (
	`gëSèckT›
 (
s
, 
°ack
)

110 <
	`gëSèckLimô
 (
s
, 
°ack
Ë+ 
	`gëSèckT›FømeSize
 (s, stack));

111 
	}
}

113 #i‡
ASSERT


114 
boﬁ
 
	$öv¨ü¡F‹Muèt‹
 (
GC_°©e
 
s
, 
boﬁ
 
‰⁄tõr
, boﬁ 
°ack
) {

115 i‡(
DEBUG
)

116 
	`di•œyGCSèã
 (
s
, 
°dîr
);

117 i‡(
‰⁄tõr
)

118 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Fr⁄tõr
(
s
));

119 i‡(
°ack
)

120 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Sèck
(
s
));

121 
	`as£π
 (
	`öv¨ü¡F‹GC
 (
s
));

122  
TRUE
;

123 
	}
}

	@invariant.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

12 #i‡
ASSERT


13 
ölöe
 
as£πIsObj±rInFromS∑˚
 (
GC_°©e
 
s
, 
obj±r
 *
›p
);

14 
boﬁ
 
öv¨ü¡F‹GC
 (
GC_°©e
 
s
);

16 
ölöe
 
boﬁ
 
öv¨ü¡F‹Muèt‹Fr⁄tõr
 (
GC_°©e
 
s
);

17 
ölöe
 
boﬁ
 
öv¨ü¡F‹Muèt‹Sèck
 (
GC_°©e
 
s
);

18 #i‡
ASSERT


19 
boﬁ
 
öv¨ü¡F‹Muèt‹
 (
GC_°©e
 
s
, boﬁ 
‰⁄tõr
, boﬁ 
°ack
);

	@major.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

12 
	mGC_COPYING
,

13 
	mGC_MARK_COMPACT
,

14 } 
	tGC_maj‹Köd
;

	@mark-compact.c

14 
	$c›yF‹ThªadI¡î«l
 (
poöãr
 
d°
,Öoöã∏
§c
) {

15 i‡(
FALSE
)

16 
	`Ârötf
 (
°dîr
,

17 "c›yF‹ThªadI¡î«»d° = "
FMTPTR
" src = "FMTPTR"\n",

18 (
uöçå_t
)
d°
, (uöçå_t)
§c
);

19 i‡(
OBJPTR_SIZE
 > 
GC_HEADER_SIZE
) {

20 
size_t
 
cou¡
;

22 
	`as£π
 (0 =(
OBJPTR_SIZE
 % 
GC_HEADER_SIZE
));

23 
cou¡
 = (
OBJPTR_SIZE
 - 
GC_HEADER_SIZE
) / GC_HEADER_SIZE;

24 
§c
 = sr¯+ 
GC_HEADER_SIZE
 * 
cou¡
;

26 
size_t
 
i
 = 0; i <
cou¡
; i++) {

27 *((
GC_hódî
*)
d°
Ë*((GC_hódî*)
§c
);

28 
d°
 +
GC_HEADER_SIZE
;

29 
§c
 -
GC_HEADER_SIZE
;

31 } i‡(
GC_HEADER_SIZE
 > 
OBJPTR_SIZE
) {

32 
size_t
 
cou¡
;

34 
	`as£π
 (0 =(
GC_HEADER_SIZE
 % 
OBJPTR_SIZE
));

35 
cou¡
 = (
GC_HEADER_SIZE
 - 
OBJPTR_SIZE
) / OBJPTR_SIZE;

36 
d°
 = d° + 
OBJPTR_SIZE
 * 
cou¡
;

38 
size_t
 
i
 = 0; i <
cou¡
; i++) {

39 *((
obj±r
*)
d°
Ë*((obj±r*)
§c
);

40 
d°
 -
OBJPTR_SIZE
;

41 
§c
 +
OBJPTR_SIZE
;

44 *((
GC_hódî
*)
d°
Ë*((GC_hódî*)
§c
);

46 
	}
}

48 
	$thªadI¡î«lObj±r
 (
GC_°©e
 
s
, 
obj±r
 *
›p
) {

49 
obj±r
 
››
;

50 
poöãr
 
p
;

51 
GC_hódî
 *
hódîp
;

53 
››
 = 
	`poöãrToObj±r
 ((
poöãr
)
›p
, 
s
->
hóp
.
°¨t
);

54 
p
 = 
	`obj±rToPoöãr
 (*
›p
, 
s
->
hóp
.
°¨t
);

55 i‡(
FALSE
)

56 
	`Ârötf
 (
°dîr
,

57 "thªadI¡î«»›∞"
FMTPTR
"Ö = "FMTPTR" hódî = "
FMTHDR
"\n",

58 (
uöçå_t
)
›p
, (uöçå_t)
p
, 
	`gëHódî
 (p));

59 
hódîp
 = 
	`gëHódîp
 (
p
);

60 
	`c›yF‹ThªadI¡î«l
 ((
poöãr
)(
›p
), (poöãr)(
hódîp
));

61 
	`c›yF‹ThªadI¡î«l
 ((
poöãr
)(
hódîp
), (poöãr)(&
››
));

62 
	}
}

67 
	$upd©eWóksF‹M¨kCom∑˘
 (
GC_°©e
 
s
) {

68 
poöãr
 
p
;

69 
GC_wók
 
w
;

71 
w
 = 
s
->
wóks
; w !
NULL
; w = w->
lök
) {

72 
	`as£π
 (
BOGUS_OBJPTR
 !
w
->
obj±r
);

74 i‡(
DEBUG_WEAK
)

75 
	`Ârötf
 (
°dîr
, "upd©eWóksF‹M¨kCom∑˘ w = "
FMTPTR
" ", (
uöçå_t
)
w
);

76 
p
 = 
	`obj±rToPoöãr
(
w
->
obj±r
, 
s
->
hóp
.
°¨t
);

78 i‡(
	`isPoöãrM¨ked
(
p
)) {

79 i‡(
DEBUG_WEAK
)

80 
	`Ârötf
 (
°dîr
, "not cleared\n");

82 i‡(
DEBUG_WEAK
)

83 
	`Ârötf
 (
°dîr
, "cleared\n");

84 *(
	`gëHódîp
((
poöãr
)
w
 - 
	`off£tofWók
 (
s
))Ë
GC_WEAK_GONE_HEADER
 | 
MARK_MASK
;

85 
w
->
obj±r
 = 
BOGUS_OBJPTR
;

88 
s
->
wóks
 = 
NULL
;

89 
	}
}

91 
	$upd©eF‹w¨dPoöãrsF‹M¨kCom∑˘
 (
GC_°©e
 
s
, 
GC_°ack
 
cuºítSèck
) {

92 
poöãr
 
back
;

93 
poöãr
 
ídOfLa°M¨ked
;

94 
poöãr
 
‰⁄t
;

95 
size_t
 
g≠
;

96 
GC_hódî
 
hódî
;

97 
GC_hódî
 *
hódîp
;

98 
poöãr
 
p
;

99 
size_t
 
size
, 
skùFr⁄t
, 
skùG≠
;

101 i‡(
DEBUG_MARK_COMPACT
)

102 
	`Ârötf
 (
°dîr
, "Update forwardÖointers.\n");

103 
‰⁄t
 = 
	`ÆignFr⁄tõr
 (
s
, s->
hóp
.
°¨t
);

104 
back
 = 
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
;

105 
g≠
 = 0;

106 
ídOfLa°M¨ked
 = 
‰⁄t
;

107 
upd©eObje˘
:

108 i‡(
DEBUG_MARK_COMPACT
)

109 
	`Ârötf
 (
°dîr
, "upd©eObje˘ fr⁄à"
FMTPTR
" back = "FMTPTR"\n",

110 (
uöçå_t
)
‰⁄t
, (uöçå_t)
back
);

111 i‡(
‰⁄t
 =
back
)

112 
d⁄e
;

113 
p
 = 
	`adv™˚ToObje˘D©a
 (
s
, 
‰⁄t
);

114 
hódîp
 = 
	`gëHódîp
 (
p
);

115 
hódî
 = *
hódîp
;

116 i‡(
GC_VALID_HEADER_MASK
 & 
hódî
) {

118 i‡(
MARK_MASK
 & 
hódî
) {

122 
thªad
:

123 
	`as£π
 (
GC_VALID_HEADER_MASK
 & 
hódî
);

124 
	`as£π
 (
MARK_MASK
 & 
hódî
);

126 
size_t
 
hódîByãs
, 
obje˘Byãs
;

127 
GC_obje˘Ty≥Tag
 
èg
;

128 
uöt16_t
 
byãsN⁄Obj±rs
, 
numObj±rs
;

130 
	`as£π
 (
hódî
 =
	`gëHódî
 (
p
));

131 
	`•lôHódî
(
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

134 i‡((
NORMAL_TAG
 =
èg
Ë
	`‹
 (
WEAK_TAG
 ==Åag)) {

135 
hódîByãs
 = 
GC_NORMAL_HEADER_SIZE
;

136 
obje˘Byãs
 = 
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
);

137 
skùFr⁄t
 = 0;

138 
skùG≠
 = 0;

139 } i‡(
ARRAY_TAG
 =
èg
) {

140 
hódîByãs
 = 
GC_ARRAY_HEADER_SIZE
;

141 
obje˘Byãs
 = 
	`sizeofAºayNoHódî
 (
s
, 
	`gëAºayLígth
 (
p
),

142 
byãsN⁄Obj±rs
, 
numObj±rs
);

143 
skùFr⁄t
 = 0;

144 
skùG≠
 = 0;

146 
boﬁ
 
cuºít
;

147 
size_t
 
ª£rvedNew
, 
ª£rvedOld
;

148 
GC_°ack
 
°ack
;

150 
	`as£π
 (
STACK_TAG
 =
èg
);

151 
hódîByãs
 = 
GC_STACK_HEADER_SIZE
;

152 
°ack
 = (
GC_°ack
)
p
;

153 
cuºít
 = 
cuºítSèck
 =
°ack
;

155 
ª£rvedOld
 = 
°ack
->
ª£rved
;

156 
ª£rvedNew
 = 
	`sizeofSèckShrökRe£rved
 (
s
, 
°ack
, 
cuºít
);

157 
obje˘Byãs
 =  (
GC_°ack
Ë+ 
°ack
->
u£d
;

158 
skùFr⁄t
 = 
ª£rvedOld
 - 
°ack
->
u£d
;

159 
skùG≠
 = 
ª£rvedOld
 - 
ª£rvedNew
;

161 
size
 = 
hódîByãs
 + 
obje˘Byãs
;

162 i‡(
DEBUG_MARK_COMPACT
)

163 
	`Ârötf
 (
°dîr
, "thªadög "
FMTPTR
" o‡sizê%"
PRIuMAX
"\n",

164 (
uöçå_t
)
p
, (
uötmax_t
)
size
);

165 i‡((
size_t
)(
‰⁄t
 - 
ídOfLa°M¨ked
Ë>
GC_ARRAY_HEADER_SIZE
 + 
OBJPTR_SIZE
) {

166 
poöãr
 
√wAºay
 = 
ídOfLa°M¨ked
;

176 i‡(
DEBUG_MARK_COMPACT
)

177 
	`Ârötf
 (
°dîr
, "com¥essög from "
FMTPTR
"Åÿ"FMTPTR" (Àngth = %"
PRIuMAX
")\n",

178 (
uöçå_t
)
ídOfLa°M¨ked
, (uöçå_t)
‰⁄t
,

179 (
uötmax_t
)(
‰⁄t
 - 
ídOfLa°M¨ked
));

180 *((
GC_¨øyCou¡î
*)(
√wAºay
)) = 0;

181 
√wAºay
 +
GC_ARRAY_COUNTER_SIZE
;

182 *((
GC_¨øyLígth
*)(
√wAºay
)) =

183 ((
size_t
)(
‰⁄t
 - 
ídOfLa°M¨ked
)Ë- 
GC_ARRAY_HEADER_SIZE
;

184 
√wAºay
 +
GC_ARRAY_LENGTH_SIZE
;

185 *((
GC_hódî
*)(
√wAºay
)Ë
GC_WORD8_VECTOR_HEADER
;

187 
g≠
 +
skùG≠
;

188 
‰⁄t
 +
size
 + 
skùFr⁄t
;

189 
ídOfLa°M¨ked
 = 
‰⁄t
;

190 
	`f‹óchObj±rInObje˘
 (
s
, 
p
, 
thªadI¡î«lObj±r
, 
FALSE
);

191 
upd©eObje˘
;

194 
size
 = 
	`sizeofObje˘
 (
s
, 
p
);

195 
g≠
 +
size
;

196 
‰⁄t
 +
size
;

197 
upd©eObje˘
;

200 
poöãr
 
√w
;

201 
obj±r
 
√wObj±r
;

203 
	`as£π
 (
	`nŸ
 (
GC_VALID_HEADER_MASK
 & 
hódî
));

208 
√w
 = 
p
 - 
g≠
;

209 
√wObj±r
 = 
	`poöãrToObj±r
 (
√w
, 
s
->
hóp
.
°¨t
);

211 
poöãr
 
cur
;

212 
obj±r
 
curObj±r
;

214 
	`c›yF‹ThªadI¡î«l
 ((
poöãr
)(&
curObj±r
), (poöãr)
hódîp
);

215 
cur
 = 
	`obj±rToPoöãr
 (
curObj±r
, 
s
->
hóp
.
°¨t
);

217 
	`c›yF‹ThªadI¡î«l
 ((
poöãr
)
hódîp
, 
cur
);

218 *((
obj±r
*)
cur
Ë
√wObj±r
;

220 
hódî
 = *
hódîp
;

221 } 0 =(1 & 
hódî
));

222 
thªad
;

224 
	`as£π
 (
FALSE
);

225 
d⁄e
:

227 
	}
}

229 
	$upd©eBackw¨dPoöãrsAndSlideF‹M¨kCom∑˘
 (
GC_°©e
 
s
, 
GC_°ack
 
cuºítSèck
) {

230 
poöãr
 
back
;

231 
poöãr
 
‰⁄t
;

232 
size_t
 
g≠
;

233 
GC_hódî
 
hódî
;

234 
GC_hódî
 *
hódîp
;

235 
poöãr
 
p
;

236 
size_t
 
size
, 
skùFr⁄t
, 
skùG≠
;

238 i‡(
DEBUG_MARK_COMPACT
)

239 
	`Ârötf
 (
°dîr
, "Update backwardÖointersánd slide.\n");

240 
‰⁄t
 = 
	`ÆignFr⁄tõr
 (
s
, s->
hóp
.
°¨t
);

241 
back
 = 
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
;

242 
g≠
 = 0;

243 
upd©eObje˘
:

244 i‡(
DEBUG_MARK_COMPACT
)

245 
	`Ârötf
 (
°dîr
, "upd©eObje˘ fr⁄à"
FMTPTR
" back = "FMTPTR"\n",

246 (
uöçå_t
)
‰⁄t
, (uöçå_t)
back
);

247 i‡(
‰⁄t
 =
back
)

248 
d⁄e
;

249 
p
 = 
	`adv™˚ToObje˘D©a
 (
s
, 
‰⁄t
);

250 
hódîp
 = 
	`gëHódîp
 (
p
);

251 
hódî
 = *
hódîp
;

252 i‡(
GC_VALID_HEADER_MASK
 & 
hódî
) {

254 i‡(
MARK_MASK
 & 
hódî
) {

258 
unm¨k
:

259 
	`as£π
 (
GC_VALID_HEADER_MASK
 & 
hódî
);

260 
	`as£π
 (
MARK_MASK
 & 
hódî
);

262 
size_t
 
hódîByãs
, 
obje˘Byãs
;

263 
GC_obje˘Ty≥Tag
 
èg
;

264 
uöt16_t
 
byãsN⁄Obj±rs
, 
numObj±rs
;

266 
	`as£π
 (
hódî
 =
	`gëHódî
 (
p
));

267 
	`•lôHódî
(
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

270 i‡((
NORMAL_TAG
 =
èg
Ë
	`‹
 (
WEAK_TAG
 ==Åag)) {

271 
hódîByãs
 = 
GC_NORMAL_HEADER_SIZE
;

272 
obje˘Byãs
 = 
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
);

273 
skùFr⁄t
 = 0;

274 
skùG≠
 = 0;

275 } i‡(
ARRAY_TAG
 =
èg
) {

276 
hódîByãs
 = 
GC_ARRAY_HEADER_SIZE
;

277 
obje˘Byãs
 = 
	`sizeofAºayNoHódî
 (
s
, 
	`gëAºayLígth
 (
p
),

278 
byãsN⁄Obj±rs
, 
numObj±rs
);

279 
skùFr⁄t
 = 0;

280 
skùG≠
 = 0;

282 
boﬁ
 
cuºít
;

283 
size_t
 
ª£rvedNew
, 
ª£rvedOld
;

284 
GC_°ack
 
°ack
;

286 
	`as£π
 (
STACK_TAG
 =
èg
);

287 
hódîByãs
 = 
GC_STACK_HEADER_SIZE
;

288 
°ack
 = (
GC_°ack
)
p
;

289 
cuºít
 = 
cuºítSèck
 =
°ack
;

291 
ª£rvedOld
 = 
°ack
->
ª£rved
;

292 
ª£rvedNew
 = 
	`sizeofSèckShrökRe£rved
 (
s
, 
°ack
, 
cuºít
);

293 i‡(
ª£rvedNew
 < 
°ack
->
ª£rved
) {

294 i‡(
DEBUG_STACKS
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

295 
	`Ârötf
 (
°dîr
,

297 
	`uötmaxToCommaSåög
(
°ack
->
ª£rved
),

298 
	`uötmaxToCommaSåög
(
ª£rvedNew
),

299 
	`uötmaxToCommaSåög
(
°ack
->
u£d
));

300 
°ack
->
ª£rved
 = 
ª£rvedNew
;

302 
obje˘Byãs
 =  (
GC_°ack
Ë+ 
°ack
->
u£d
;

303 
skùFr⁄t
 = 
ª£rvedOld
 - 
°ack
->
u£d
;

304 
skùG≠
 = 
ª£rvedOld
 - 
ª£rvedNew
;

306 
size
 = 
hódîByãs
 + 
obje˘Byãs
;

308 i‡(
DEBUG_MARK_COMPACT
)

309 
	`Ârötf
 (
°dîr
, "unm¨kög "
FMTPTR
" o‡sizê%"
PRIuMAX
"\n",

310 (
uöçå_t
)
p
, (
uötmax_t
)
size
);

311 *
hódîp
 = 
hódî
 & ~
MARK_MASK
;

313 i‡(
DEBUG_MARK_COMPACT
)

314 
	`Ârötf
 (
°dîr
, "¶idög "
FMTPTR
" dow¿%"
PRIuMAX
"Åo "FMTPTR"\n",

315 (
uöçå_t
)
‰⁄t
, (
uötmax_t
)
g≠
, (uintptr_t)(front - gap));

316 
	`GC_memmove
 (
‰⁄t
, fr⁄à- 
g≠
, 
size
);

317 
g≠
 +
skùG≠
;

318 
‰⁄t
 +
size
 + 
skùFr⁄t
;

319 
upd©eObje˘
;

322 
size
 = 
	`sizeofObje˘
 (
s
, 
p
);

323 i‡(
DEBUG_MARK_COMPACT
)

324 
	`Ârötf
 (
°dîr
, "skùpög "
FMTPTR
" o‡sizê%"
PRIuMAX
"\n",

325 (
uöçå_t
)
p
, (
uötmax_t
)
size
);

326 
g≠
 +
size
;

327 
‰⁄t
 +
size
;

328 
upd©eObje˘
;

331 
poöãr
 
√w
;

332 
obj±r
 
√wObj±r
;

334 
	`as£π
 (
	`nŸ
 (
GC_VALID_HEADER_MASK
 & 
hódî
));

338 
√w
 = 
p
 - 
g≠
;

339 
√wObj±r
 = 
	`poöãrToObj±r
 (
√w
, 
s
->
hóp
.
°¨t
);

341 
poöãr
 
cur
;

342 
obj±r
 
curObj±r
;

344 
	`c›yF‹ThªadI¡î«l
 ((
poöãr
)(&
curObj±r
), (poöãr)
hódîp
);

345 
cur
 = 
	`obj±rToPoöãr
 (
curObj±r
, 
s
->
hóp
.
°¨t
);

347 
	`c›yF‹ThªadI¡î«l
 ((
poöãr
)
hódîp
, 
cur
);

348 *((
obj±r
*)
cur
Ë
√wObj±r
;

350 
hódî
 = *
hódîp
;

351 } 0 =(1 & 
hódî
));

353 
unm¨k
;

355 
	`as£π
 (
FALSE
);

356 
d⁄e
:

357 
s
->
hóp
.
ﬁdGíSize
 = (
size_t
)((
‰⁄t
 - 
g≠
Ë- s->hóp.
°¨t
);

358 i‡(
DEBUG_MARK_COMPACT
)

359 
	`Ârötf
 (
°dîr
, "ﬁdGíSizê%"
PRIuMAX
"\n",

360 (
uötmax_t
)
s
->
hóp
.
ﬁdGíSize
);

362 
	}
}

364 
	$maj‹M¨kCom∑˘GC
 (
GC_°©e
 
s
) {

365 
size_t
 
byãsHashC⁄£d
;

366 
size_t
 
byãsM¨kCom∑˘ed
;

367 
GC_°ack
 
cuºítSèck
;

368 
rußge
 
ru_°¨t
;

370 i‡(
	`dëaûedGCTime
 (
s
))

371 
	`°¨tTimög
 (&
ru_°¨t
);

372 
s
->
cumuœtiveSèti°ics
.
numM¨kCom∑˘GCs
++;

373 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

374 
	`Ârötf
 (
°dîr
,

376 
	`Ârötf
 (
°dîr
,

377 "[GC:\thó∞© "
FMTPTR
" of size %s bytes.]\n",

378 (
uöçå_t
)(
s
->
hóp
.
°¨t
),

379 
	`uötmaxToCommaSåög
(
s
->
hóp
.
size
));

381 
cuºítSèck
 = 
	`gëSèckCuºít
 (
s
);

382 i‡(
s
->
hashC⁄sDurögGC
) {

383 
s
->
œ°Maj‹Sèti°ics
.
byãsHashC⁄£d
 = 0;

384 
s
->
cumuœtiveSèti°ics
.
numHashC⁄sGCs
++;

385 
s
->
obje˘HashTabÀ
 = 
	`ÆlocHashTabÀ
 (s);

386 
	`f‹óchGlobÆObj±r
 (
s
, 
dfsM¨kWôhHashC⁄sWôhLökWóks
);

387 
	`‰ìHashTabÀ
 (
s
->
obje˘HashTabÀ
);

389 
	`f‹óchGlobÆObj±r
 (
s
, 
dfsM¨kWôhoutHashC⁄sWôhLökWóks
);

391 
	`upd©eWóksF‹M¨kCom∑˘
 (
s
);

392 
	`f‹óchGlobÆObj±r
 (
s
, 
thªadI¡î«lObj±r
);

393 
	`upd©eF‹w¨dPoöãrsF‹M¨kCom∑˘
 (
s
, 
cuºítSèck
);

394 
	`upd©eBackw¨dPoöãrsAndSlideF‹M¨kCom∑˘
 (
s
, 
cuºítSèck
);

395 
byãsHashC⁄£d
 = 
s
->
œ°Maj‹Sèti°ics
.bytesHashConsed;

396 
s
->
cumuœtiveSèti°ics
.
byãsHashC⁄£d
 += bytesHashConsed;

397 
byãsM¨kCom∑˘ed
 = 
s
->
hóp
.
ﬁdGíSize
;

398 
s
->
cumuœtiveSèti°ics
.
byãsM¨kCom∑˘ed
 += bytesMarkCompacted;

399 
s
->
œ°Maj‹Sèti°ics
.
köd
 = 
GC_MARK_COMPACT
;

400 i‡(
	`dëaûedGCTime
 (
s
))

401 
	`°›Timög
 (&
ru_°¨t
, &
s
->
cumuœtiveSèti°ics
.
ru_gcM¨kCom∑˘
);

402 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
) {

403 
	`Ârötf
 (
°dîr
,

405 
	`uötmaxToCommaSåög
(
byãsM¨kCom∑˘ed
));

406 i‡(
s
->
hashC⁄sDurögGC
)

407 
	`¥ötByãsHashC⁄£dMesßge
(
byãsHashC⁄£d
,

408 
byãsHashC⁄£d
 + 
byãsM¨kCom∑˘ed
);

410 
	}
}

	@mark-compact.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
c›yF‹ThªadI¡î«l
 (
poöãr
 
d°
,Öoöã∏
§c
);

12 
ölöe
 
thªadI¡î«lObj±r
 (
GC_°©e
 
s
, 
obj±r
 *
›p
);

13 
ölöe
 
upd©eWóksF‹M¨kCom∑˘
 (
GC_°©e
 
s
);

14 
upd©eF‹w¨dPoöãrsF‹M¨kCom∑˘
 (
GC_°©e
 
s
, 
GC_°ack
 
cuºítSèck
);

15 
upd©eBackw¨dPoöãrsAndSlideF‹M¨kCom∑˘
 (
GC_°©e
 
s
, 
GC_°ack
 
cuºítSèck
);

16 
maj‹M¨kCom∑˘GC
 (
GC_°©e
 
s
);

	@model.c

	@model.h

8 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

140 #i‡
deföed
 (
GC_MODEL_NATIVE32
)

141 
	#GC_MODEL_OBJPTR_SIZE
 32

	)

142 
	#GC_MODEL_OBJPTR_SHIFT
 0

	)

143 
	#GC_MODEL_OBJPTR_BASE
 0

	)

144 
	#GC_MODEL_HEADER_SIZE
 32

	)

145 
	#GC_MODEL_ARRLEN_SIZE
 32

	)

146 #ñi‡
deföed
 (
GC_MODEL_NATIVE64
)

147 
	#GC_MODEL_OBJPTR_SIZE
 64

	)

148 
	#GC_MODEL_OBJPTR_SHIFT
 0

	)

149 
	#GC_MODEL_OBJPTR_BASE
 0

	)

150 
	#GC_MODEL_HEADER_SIZE
 64

	)

151 
	#GC_MODEL_ARRLEN_SIZE
 64

	)

153 #îr‹ 
GC_MODEL_
* 
undeföed


156 
	#GC_MODEL_MINALIGN_SHIFT
 
	`max
(2, 
GC_MODEL_OBJPTR_SHIFT
 + 1)

	)

157 
	#GC_MODEL_MINALIGN
 
	`TWOPOWER
(
GC_MODEL_MINALIGN_SHIFT
)

	)

	@new-object.c

15 
poöãr
 
	$√wObje˘
 (
GC_°©e
 
s
,

16 
GC_hódî
 
hódî
,

17 
size_t
 
byãsReque°ed
,

18 
boﬁ
 
ÆlocInOldGí
) {

20  
	`√wUMObje˘
(
s
, 
hódî
, 
byãsReque°ed
, 
ÆlocInOldGí
);

21 
poöãr
 
‰⁄tõr
;

22 
poöãr
 
ªsu…
;

24 
	`as£π
 (
	`isAlig√d
 (
byãsReque°ed
, 
s
->
Æignmít
));

25 
	`as£π
 (
ÆlocInOldGí


26 ? 
	`hasHópByãsFªe
 (
s
, 
byãsReque°ed
, 0)

27 : 
	`hasHópByãsFªe
 (
s
, 0, 
byãsReque°ed
));

28 i‡(
ÆlocInOldGí
) {

29 
‰⁄tõr
 = 
s
->
hóp
.
°¨t
 + s->hóp.
ﬁdGíSize
;

30 
s
->
hóp
.
ﬁdGíSize
 +
byãsReque°ed
;

31 
s
->
cumuœtiveSèti°ics
.
byãsAŒoˇãd
 +
byãsReque°ed
;

33 i‡(
DEBUG_DETAILED
)

34 
	`Ârötf
 (
°dîr
, "‰⁄tõ∏ch™ged from "
FMTPTR
"Åo "FMTPTR"\n",

35 (
uöçå_t
)
s
->
‰⁄tõr
,

36 (
uöçå_t
)(
s
->
‰⁄tõr
 + 
byãsReque°ed
));

37 
‰⁄tõr
 = 
s
->frontier;

38 
s
->
‰⁄tõr
 +
byãsReque°ed
;

40 
	`GC_¥ofûeAŒocInc
 (
s
, 
byãsReque°ed
);

41 *((
GC_hódî
*)
‰⁄tõr
Ë
hódî
;

42 
ªsu…
 = 
‰⁄tõr
 + 
GC_NORMAL_HEADER_SIZE
;

43 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
ªsu…
, 
s
->
Æignmít
));

44 i‡(
DEBUG
)

45 
	`Ârötf
 (
°dîr
, 
FMTPTR
 " =ÇewObje˘ ("
FMTHDR
", %"
PRIuMAX
", %s)\n",

46 (
uöçå_t
)
ªsu…
,

47 
hódî
,

48 (
uötmax_t
)
byãsReque°ed
,

49 
	`boﬁToSåög
 (
ÆlocInOldGí
));

50  
ªsu…
;

51 
	}
}

53 
poöãr
 
√wUMObje˘
 (
GC_°©e
 
s
,

54 
GC_hódî
 
hódî
,

55 
size_t
 
byãsReque°ed
,

56 
__©åibuã__
 ((
unu£d
)Ë
boﬁ
 
ÆlocInOldGí
) {

57 
poöãr
 
	g‰⁄tõr
;

58 
poöãr
 
	gªsu…
;

60 
	g‰⁄tõr
 = 
s
->
‰⁄tõr
;

61 
	gs
->
	g‰⁄tõr
 +
byãsReque°ed
;

62 *((
	gGC_hódî
*)
	g‰⁄tõr
Ë
hódî
;

63 
	gªsu…
 = 
‰⁄tõr
 + 
GC_NORMAL_HEADER_SIZE
;

64  
	gªsu…
;

67 
GC_°ack
 
	$√wSèck
 (
GC_°©e
 
s
,

68 
size_t
 
ª£rved
,

69 
boﬁ
 
ÆlocInOldGí
) {

70 
GC_°ack
 
°ack
;

71 
ª£rved
 = 100 * 1024 * 1024;

72 
	`as£π
 (
	`isSèckRe£rvedAlig√d
 (
s
, 
ª£rved
));

73 i‡(
ª£rved
 > 
s
->
cumuœtiveSèti°ics
.
maxSèckSize
)

74 
s
->
cumuœtiveSèti°ics
.
maxSèckSize
 = 
ª£rved
;

75 
°ack
 = (
GC_°ack
)(
	`√wUMObje˘
 (
s
, 
GC_STACK_HEADER
,

76 
	`sizeofSèckWôhHódî
 (
s
, 
ª£rved
),

77 
ÆlocInOldGí
));

78 
°ack
->
ª£rved
 =Ñeserved;

79 
°ack
->
u£d
 = 0;

80 i‡(
DEBUG_STACKS
)

81 
	`Ârötf
 (
°dîr
, 
FMTPTR
 " =ÇewSèck (%"
PRIuMAX
")\n",

82 (
uöçå_t
)
°ack
,

83 (
uötmax_t
)
ª£rved
);

84  
°ack
;

85 
	}
}

87 
GC_thªad
 
	$√wThªad
 (
GC_°©e
 
s
, 
size_t
 
ª£rved
) {

88 
GC_°ack
 
°ack
;

89 
GC_thªad
 
thªad
;

90 
poöãr
 
ªs
;

92 
	`as£π
 (
	`isSèckRe£rvedAlig√d
 (
s
, 
ª£rved
));

93 
	`ísuªHasHópByãsFªe
 (
s
, 0, 
	`sizeofSèckWôhHódî
 (s, 
ª£rved
Ë+ 
	`sizeofThªad
 (s));

94 
°ack
 = 
	`√wSèck
 (
s
, 
ª£rved
, 
FALSE
);

95 
ªs
 = 
	`√wUMObje˘
 (
s
, 
GC_THREAD_HEADER
,

96 
	`sizeofThªad
 (
s
),

97 
FALSE
);

98 
thªad
 = (
GC_thªad
)(
ªs
 + 
	`off£tofThªad
 (
s
));

99 
thªad
->
byãsNìded
 = 0;

100 
thªad
->
exnSèck
 = 
BOGUS_EXN_STACK
;

101 
thªad
->
°ack
 = 
	`poöãrToObj±r
((
poöãr
)°ack, 
s
->
hóp
.
°¨t
);

102 i‡(
DEBUG_THREADS
)

103 
	`Ârötf
 (
°dîr
, 
FMTPTR
" =ÇewThªadOfSizê(%"
PRIuMAX
")\n",

104 (
uöçå_t
)
thªad
, (
uötmax_t
)
ª£rved
);;

105  
thªad
;

106 
	}
}

108 
ölöe
 
	$£tFr⁄tõr
 (
GC_°©e
 
s
, 
poöãr
 
p
,

109 
ARG_USED_FOR_ASSERT
 
size_t
 
byãs
) {

110 
p
 = 
	`ÆignFr⁄tõr
 (
s
,Ö);

111 
	`as£π
 ((
size_t
)(
p
 - 
s
->
‰⁄tõr
Ë<
byãs
);

112 
	`GC_¥ofûeAŒocInc
 (
s
, (
size_t
)(
p
 - s->
‰⁄tõr
));

113 
s
->
cumuœtiveSèti°ics
.
byãsAŒoˇãd
 +(
size_t
)(
p
 - s->
‰⁄tõr
);

114 
s
->
‰⁄tõr
 = 
p
;

115 
	`as£π
 (
s
->
‰⁄tõr
 <s->
limôPlusSl›
);

116 
	}
}

	@new-object.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
poöãr
 
√wObje˘
 (
GC_°©e
 
s
, 
GC_hódî
 
hódî
,

12 
size_t
 
byãsReque°ed
, 
boﬁ
 
ÆlocInOldGí
);

13 
ölöe
 
poöãr
 
√wUMObje˘
 (
GC_°©e
 
s
, 
GC_hódî
 
hódî
,

14 
size_t
 
byãsReque°ed
, 
boﬁ
 
ÆlocInOldGí
);

15 
ölöe
 
GC_°ack
 
√wSèck
 (
GC_°©e
 
s
, 
size_t
 
ª£rved
, 
boﬁ
 
ÆlocInOldGí
);

16 
GC_thªad
 
√wThªad
 (
GC_°©e
 
s
, 
size_t
 
°ackSize
);

18 
ölöe
 
£tFr⁄tõr
 (
GC_°©e
 
s
, 
poöãr
 
p
, 
size_t
 
byãs
);

	@object-size.c

9 
size_t
 
	$sizeofAºayNoHódî
 (
GC_°©e
 
s
,

10 
GC_¨øyLígth
 
numEÀmíts
,

11 
uöt16_t
 
byãsN⁄Obj±rs
, uöt16_à
numObj±rs
) {

12 
size_t
 
ªsu…
;

14 
ªsu…
 = 
numEÀmíts
 * (
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
));

18 i‡(
ªsu…
 < 
OBJPTR_SIZE
)

19 
ªsu…
 = 
OBJPTR_SIZE
;

20  
	`ÆignWôhExåa
 (
s
, 
ªsu…
, 
GC_ARRAY_HEADER_SIZE
);

21 
	}
}

23 
size_t
 
sizeofSèckNoHódî
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

24 
GC_°ack
 
°ack
) {

25 
size_t
 
	gªsu…
;

27 
	gªsu…
 =  (
GC_°ack
Ë+ 
°ack
->
ª£rved
;

28  
	gªsu…
;

31 
size_t
 
	$sizeofObje˘
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

32 
size_t
 
hódîByãs
, 
obje˘Byãs
;

33 
GC_hódî
 
hódî
;

34 
GC_obje˘Ty≥Tag
 
èg
;

35 
uöt16_t
 
byãsN⁄Obj±rs
, 
numObj±rs
;

37 
hódî
 = 
	`gëHódî
 (
p
);

38 
	`•lôHódî
 (
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

39 i‡((
NORMAL_TAG
 =
èg
Ë
	`‹
 (
WEAK_TAG
 ==Åag)) {

40 
hódîByãs
 = 
GC_NORMAL_HEADER_SIZE
;

41 
obje˘Byãs
 = 
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
);

42 } i‡(
ARRAY_TAG
 =
èg
) {

43 
hódîByãs
 = 
GC_ARRAY_HEADER_SIZE
;

44 
obje˘Byãs
 = 
	`sizeofAºayNoHódî
 (
s
, 
	`gëAºayLígth
 (
p
),

45 
byãsN⁄Obj±rs
, 
numObj±rs
);

47 
	`as£π
 (
STACK_TAG
 =
èg
);

48 
hódîByãs
 = 
GC_STACK_HEADER_SIZE
;

49 
obje˘Byãs
 = 
	`sizeofSèckNoHódî
 (
s
, (
GC_°ack
)
p
);

51  
hódîByãs
 + 
obje˘Byãs
;

52 
	}
}

	@object-size.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
size_t
 
sizeofAºayNoHódî
 (
GC_°©e
 
s
, 
GC_¨øyLígth
 
numEÀmíts
,

12 
uöt16_t
 
byãsN⁄Obj±rs
, uöt16_à
numObj±rs
);

13 
ölöe
 
size_t
 
sizeofSèckNoHódî
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

15 
ölöe
 
size_t
 
sizeofObje˘
 (
GC_°©e
 
s
, 
poöãr
 
p
);

	@object.c

10 c⁄° * 
	$obje˘Ty≥TagToSåög
 (
GC_obje˘Ty≥Tag
 
èg
) {

11 
èg
) {

12 
ARRAY_TAG
:

14 
NORMAL_TAG
:

16 
STACK_TAG
:

18 
WEAK_TAG
:

21 
	`dõ
 ("bad GC_obje˘Ty≥Tag %u", 
èg
);

23 
	}
}

29 
GC_hódî
* 
	$gëHódîp
 (
poöãr
 
p
) {

30  (
GC_hódî
*)(
p


31 - 
GC_HEADER_SIZE
);

32 
	}
}

38 
GC_hódî
 
	$gëHódî
 (
poöãr
 
p
) {

39  *(
	`gëHódîp
(
p
));

40 
	}
}

45 
GC_hódî
 
	$buûdHódîFromTy≥Index
 (
uöt32_t
 
t
) {

46 
	`as£π
 (
t
 < 
	`TWOPOWER
 (
TYPE_INDEX_BITS
));

47  1 | (
t
 << 1);

48 
	}
}

50 
	$•lôHódî
(
GC_°©e
 
s
, 
GC_hódî
 
hódî
,

51 
GC_obje˘Ty≥Tag
 *
ègRë
, 
boﬁ
 *
hasIdítôyRë
,

52 
uöt16_t
 *
byãsN⁄Obj±rsRë
, uöt16_à*
numObj±rsRë
) {

53 
obje˘Ty≥Index
;

54 
GC_obje˘Ty≥
 
obje˘Ty≥
;

55 
GC_obje˘Ty≥Tag
 
èg
;

56 
boﬁ
 
hasIdítôy
;

57 
uöt16_t
 
byãsN⁄Obj±rs
, 
numObj±rs
;

59 
	`as£π
 (1 =(
hódî
 & 
GC_VALID_HEADER_MASK
));

60 
obje˘Ty≥Index
 = (
hódî
 & 
TYPE_INDEX_MASK
Ë>> 
TYPE_INDEX_SHIFT
;

61 
	`as£π
 (
obje˘Ty≥Index
 < 
s
->
obje˘Ty≥sLígth
);

62 
obje˘Ty≥
 = &(
s
->
obje˘Ty≥s
[
obje˘Ty≥Index
]);

63 
èg
 = 
obje˘Ty≥
->tag;

64 
hasIdítôy
 = 
obje˘Ty≥
->hasIdentity;

65 
byãsN⁄Obj±rs
 = 
obje˘Ty≥
->bytesNonObjptrs;

66 
numObj±rs
 = 
obje˘Ty≥
->numObjptrs;

68 i‡(
DEBUG_DETAILED
)

69 
	`Ârötf
 (
°dîr
,

70 "•lôHódî ("
FMTHDR
")"

74 " byãsN⁄Obj±r†%"
PRIu16


75 "ÇumObj±r†%"
PRIu16
"\n",

76 
hódî
,

77 
obje˘Ty≥Index
,

78 
	`obje˘Ty≥TagToSåög
(
èg
),

79 
	`boﬁToSåög
(
hasIdítôy
),

80 
byãsN⁄Obj±rs
, 
numObj±rs
);

82 i‡(
ègRë
 !
NULL
)

83 *
ègRë
 = 
èg
;

84 i‡(
hasIdítôyRë
 !
NULL
)

85 *
hasIdítôyRë
 = 
hasIdítôy
;

86 i‡(
byãsN⁄Obj±rsRë
 !
NULL
)

87 *
byãsN⁄Obj±rsRë
 = 
byãsN⁄Obj±rs
;

88 i‡(
numObj±rsRë
 !
NULL
)

89 *
numObj±rsRë
 = 
numObj±rs
;

90 
	}
}

97 
poöãr
 
	$adv™˚ToObje˘D©a
 (
ARG_USED_FOR_ASSERT
 
GC_°©e
 
s
, 
poöãr
 
p
) {

98 
GC_hódî
 
hódî
;

99 
poöãr
 
ªs
;

101 
	`as£π
 (
	`isFr⁄tõrAlig√d
 (
s
, 
p
));

102 
hódî
 = *(
GC_hódî
*)
p
;

103 i‡(0 =
hódî
)

105 
ªs
 = 
p
 + 
GC_ARRAY_HEADER_SIZE
;

108 
ªs
 = 
p
 + 
GC_NORMAL_HEADER_SIZE
;

109 
	`as£π
 (
	`isAlig√d
 ((
uöçå_t
)
ªs
, 
s
->
Æignmít
));

110 i‡(
DEBUG_DETAILED
)

111 
	`Ârötf
 (
°dîr
, 
FMTPTR
" =ádvanceToObjectData ("FMTPTR")\n",

112 (
uöçå_t
)
ªs
, (uöçå_t)
p
);

113  
ªs
;

114 
	}
}

	@object.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

18 
	mARRAY_TAG
 = 0,

19 
	mNORMAL_TAG
 = 1,

20 
	mSTACK_TAG
 = 2,

21 
	mWEAK_TAG
 = 3,

22 } 
	tGC_obje˘Ty≥Tag
;

26 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

28 c⁄° * 
obje˘Ty≥TagToSåög
 (
GC_obje˘Ty≥Tag
 
èg
);

33 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

46 
	#GC_HEADER_TYPE__
(
z
Ë
uöt
 ## z ## 
_t


	)

47 
	#GC_HEADER_TYPE_
(
z
Ë
	`GC_HEADER_TYPE__
(z)

	)

48 
	#GC_HEADER_TYPE
 
	`GC_HEADER_TYPE_
(
GC_MODEL_HEADER_SIZE
)

	)

49 
GC_HEADER_TYPE
 
	tGC_hódî
;

50 
	#GC_HEADER_SIZE
 (
GC_hódî
)

	)

51 
	#PRIxHDR__
(
z
Ë
PRIx
 ## 
	)
z

52 
	#PRIxHDR_
(
z
Ë
	`PRIxHDR__
(z)

	)

53 
	#PRIxHDR
 
	`PRIxHDR_
(
GC_MODEL_HEADER_SIZE
)

	)

54 
	#FMTHDR
 "%08"
PRIxHDR


	)

56 
COMPILE_TIME_ASSERT
(
sizeof_obj±r__eq__sizeof_hódî
,

57 (
obj±r
Ë=(
GC_hódî
));

59 
	#GC_VALID_HEADER_MASK
 ((
GC_hódî
)0x1)

	)

60 
	#TYPE_INDEX_BITS
 19

	)

61 
	#TYPE_INDEX_MASK
 ((
GC_hódî
)0x000FFFFE)

	)

62 
	#TYPE_INDEX_SHIFT
 1

	)

63 
	#COUNTER_BITS
 10

	)

64 
	#COUNTER_MASK
 ((
GC_hódî
)0x7FF00000)

	)

65 
	#COUNTER_SHIFT
 20

	)

66 
	#MARK_BITS
 1

	)

67 
	#MARK_MASK
 ((
GC_hódî
)0x80000000)

	)

68 
	#MARK_SHIFT
 31

	)

72 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

74 
ölöe
 
GC_hódî
* 
gëHódîp
 (
poöãr
 
p
);

75 
ölöe
 
GC_hódî
 
gëHódî
 (
poöãr
 
p
);

76 
ölöe
 
GC_hódî
 
buûdHódîFromTy≥Index
 (
uöt32_t
 
t
);

81 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

97 
	#GC_NORMAL_HEADER_SIZE
 
GC_HEADER_SIZE


	)

109 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

132 
	sGC_obje˘Ty≥
 {

134 
GC_obje˘Ty≥Tag
 
	mèg
;

135 
boﬁ
 
	mhasIdítôy
;

136 
uöt16_t
 
	mbyãsN⁄Obj±rs
;

137 
uöt16_t
 
	mnumObj±rs
;

138 } *
	tGC_obje˘Ty≥
;

141 
	mSTACK_TYPE_INDEX
 = 0,

142 
	mTHREAD_TYPE_INDEX
 = 1,

143 
	mWEAK_GONE_TYPE_INDEX
 = 2,

144 
	mWORD8_VECTOR_TYPE_INDEX
 = 3,

145 
	mWORD32_VECTOR_TYPE_INDEX
 = 4,

146 
	mWORD16_VECTOR_TYPE_INDEX
 = 5,

147 
	mWORD64_VECTOR_TYPE_INDEX
 = 6,

152 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

154 
	#GC_STACK_HEADER
 
	`buûdHódîFromTy≥Index
 (
STACK_TYPE_INDEX
)

	)

155 
	#GC_THREAD_HEADER
 
	`buûdHódîFromTy≥Index
 (
THREAD_TYPE_INDEX
)

	)

156 
	#GC_WEAK_GONE_HEADER
 
	`buûdHódîFromTy≥Index
 (
WEAK_GONE_TYPE_INDEX
)

	)

157 
	#GC_WORD8_VECTOR_HEADER
 
	`buûdHódîFromTy≥Index
 (
WORD8_VECTOR_TYPE_INDEX
)

	)

158 
	#GC_WORD16_VECTOR_HEADER
 
	`buûdHódîFromTy≥Index
 (
WORD16_VECTOR_TYPE_INDEX
)

	)

159 
	#GC_WORD32_VECTOR_HEADER
 
	`buûdHódîFromTy≥Index
 (
WORD32_VECTOR_TYPE_INDEX
)

	)

160 
	#GC_WORD64_VECTOR_HEADER
 
	`buûdHódîFromTy≥Index
 (
WORD64_VECTOR_TYPE_INDEX
)

	)

162 
ölöe
 
•lôHódî
 (
GC_°©e
 
s
, 
GC_hódî
 
hódî
,

163 
GC_obje˘Ty≥Tag
 *
ègRë
, 
boﬁ
 *
hasIdítôyRë
,

164 
uöt16_t
 *
byãsN⁄Obj±rsRë
, uöt16_à*
numObj±rsRë
);

165 
ölöe
 
poöãr
 
adv™˚ToObje˘D©a
 (
GC_°©e
 
s
,Öoöã∏
p
);

	@objptr.c

9 
boﬁ
 
	$isObj±r
 (
obj±r
 
p
) {

10 
shi·
 = 
GC_MODEL_MINALIGN_SHIFT
 - 
GC_MODEL_OBJPTR_SHIFT
;

11 
obj±r
 
mask
 = ~((~((obj±r)0)Ë<< 
shi·
);

12  (0 =(
p
 & 
mask
));

13 
	}
}

15 
poöãr
 
	$obj±rToPoöãr
 (
obj±r
 
O
, 
poöãr
 
B
) {

16 
uöçå_t
 
O_
 = (uöçå_t)
O
;

17 
uöçå_t
 
B_
;

18 
S_
 = 
GC_MODEL_OBJPTR_SHIFT
;

19 
uöçå_t
 
P_
;

20 
poöãr
 
P
;

22 i‡(
GC_MODEL_OBJPTR_BASE
) {

23 
B_
 = (
uöçå_t
)
B
;

25 
B_
 = 0;

28 
P_
 = ((
O_
 << 
S_
Ë+ 
B_
);

29 
P
 = (
poöãr
)
P_
;

30 i‡(
DEBUG_OBJPTR
)

31 
	`Ârötf
 (
°dîr
, "obj±rToPoöã∏("
FMTOBJPTR
"Ë"
FMTPTR
"\n", 
O
, (
uöçå_t
)
P
);

33  
P
;

34 
	}
}

36 
obj±r
 
	$poöãrToObj±r
 (
poöãr
 
P
,Öoöã∏
B
) {

37 
uöçå_t
 
P_
 = (uöçå_t)
P
;

38 
uöçå_t
 
B_
;

39 
S_
 = 
GC_MODEL_OBJPTR_SHIFT
;

40 
uöçå_t
 
O_
;

41 
obj±r
 
O
;

43 i‡(
GC_MODEL_OBJPTR_BASE
) {

44 
B_
 = (
uöçå_t
)
B
;

46 
B_
 = 0;

49 
O_
 = ((
P_
 - 
B_
Ë>> 
S_
);

50 
O
 = (
obj±r
)
O_
;

51 i‡(
DEBUG_OBJPTR
)

52 
	`Ârötf
 (
°dîr
, "poöãrToObj±∏("
FMTPTR
"Ë"
FMTOBJPTR
"\n", (
uöçå_t
)
P
, 
O
);

54  
O
;

55 
	}
}

66 
poöãr
 
	$„tchObj±rToPoöãr
 (
poöãr
 
OP
,Öoöã∏
B
) {

67  
	`obj±rToPoöãr
 (*((
obj±r
*)
OP
), 
B
);

68 
	}
}

69 
	$°‹eObj±rFromPoöãr
 (
poöãr
 
OP
,Öoöã∏
P
,Öoöã∏
B
) {

70 *((
obj±r
*)
OP
Ë
	`poöãrToObj±r
 (
P
, 
B
);

71 
	}
}

	@objptr.h

8 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

10 
	#OBJPTR_TYPE__
(
z
Ë
uöt
 ## z ## 
_t


	)

11 
	#OBJPTR_TYPE_
(
z
Ë
	`OBJPTR_TYPE__
(z)

	)

12 
	#OBJPTR_TYPE
 
	`OBJPTR_TYPE_
(
GC_MODEL_OBJPTR_SIZE
)

	)

13 
OBJPTR_TYPE
 
	tobj±r
;

14 
	#OBJPTR_SIZE
 (
obj±r
)

	)

15 
	#PRIxOBJPTR__
(
z
Ë
PRIx
 ## 
	)
z

16 
	#PRIxOBJPTR_
(
z
Ë
	`PRIxOBJPTR__
(z)

	)

17 
	#PRIxOBJPTR
 
	`PRIxOBJPTR_
(
GC_MODEL_OBJPTR_SIZE
)

	)

18 
	#FMTOBJPTR
 "0x%016"
PRIxOBJPTR


	)

20 
COMPILE_TIME_ASSERT
(
sizeof_voidSèr__gã__sizeof_obj±r
,

21 (*Ë>(
obj±r
));

23 
	#BOGUS_OBJPTR
 (
obj±r
)0x1

	)

27 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

29 
ölöe
 
boﬁ
 
isObj±r
 (
obj±r
 
p
);

30 
ölöe
 
poöãr
 
obj±rToPoöãr
 (
obj±r
 
O
,Öoöã∏
B
);

31 
ölöe
 
obj±r
 
poöãrToObj±r
 (
poöãr
 
P
,Öoöã∏
B
);

32 
ölöe
 
poöãr
 
„tchObj±rToPoöãr
 (poöã∏
OP
,Öoöã∏
B
);

33 
ölöe
 
°‹eObj±rFromPoöãr
 (
poöãr
 
OP
,Öoöã∏
P
,Öoöã∏
B
);

	@pack.c

10 
	$GC_∑ck
 (
GC_°©e
 
s
) {

11 
size_t
 
kìp
;

13 
	`íãr
 (
s
);

14 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

15 
	`Ârötf
 (
°dîr
,

16 "[GC: Packög hó∞© "
FMTPTR
" of size %s bytes.]\n",

17 (
uöçå_t
)(
s
->
hóp
.
°¨t
),

18 
	`uötmaxToCommaSåög
(
s
->
hóp
.
size
));

23 
	`≥rf‹mGC
 (
s
, 0, 0, 
TRUE
, 
FALSE
);

24 
kìp
 = (
size_t
)(
s
->
hóp
.
ﬁdGíSize
 * 1.1);

25 i‡(
kìp
 <
s
->
hóp
.
size
) {

26 
	`shrökHóp
 (
s
, &s->
hóp
, 
kìp
);

27 
	`£tC¨dM≠AndCrossM≠
 (
s
);

28 
	`£tGCSèãCuºítHóp
 (
s
, 0, 0);

29 
	`£tGCSèãCuºítThªadAndSèck
 (
s
);

31 
	`ªÀa£Hóp
 (
s
, &s->
£c⁄d¨yHóp
);

32 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

33 
	`Ârötf
 (
°dîr
,

34 "[GC: Packed hó∞© "
FMTPTR
"Åo size %s bytes.]\n",

35 (
uöçå_t
)(
s
->
hóp
.
°¨t
),

36 
	`uötmaxToCommaSåög
(
s
->
hóp
.
size
));

37 
	`Àave
 (
s
);

38 
	}
}

40 
	$GC_u≈ack
 (
GC_°©e
 
s
) {

41 
	`íãr
 (
s
);

42 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

43 
	`Ârötf
 (
°dîr
,

44 "[GC: U≈ackög hó∞© "
FMTPTR
" of size %s bytes.]\n",

45 (
uöçå_t
)(
s
->
hóp
.
°¨t
),

46 
	`uötmaxToCommaSåög
(
s
->
hóp
.
size
));

51 
	`íãrGC
 (
s
);

52 
	`mö‹GC
 (
s
);

53 
	`ªsizeHóp
 (
s
, s->
hóp
.
ﬁdGíSize
);

54 
	`£tC¨dM≠AndCrossM≠
 (
s
);

55 
	`ªsizeHópSec⁄d¨y
 (
s
);

56 
	`£tGCSèãCuºítHóp
 (
s
, 0, 0);

57 
	`£tGCSèãCuºítThªadAndSèck
 (
s
);

58 
	`ÀaveGC
 (
s
);

59 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

60 
	`Ârötf
 (
°dîr
,

61 "[GC: U≈acked hó∞© "
FMTPTR
"Åo size %s bytes.]\n",

62 (
uöçå_t
)(
s
->
hóp
.
°¨t
),

63 
	`uötmaxToCommaSåög
(
s
->
hóp
.
size
));

64 
	`Àave
 (
s
);

65 
	}
}

	@pack.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

11 
PRIVATE
 
GC_∑ck
 (
GC_°©e
 
s
);

12 
PRIVATE
 
GC_u≈ack
 (
GC_°©e
 
s
);

	@pointer.c

10 
boﬁ
 
	$isPoöãr
 (
poöãr
 
p
) {

11 
uöçå_t
 
mask
 = ~((~((uöçå_t)0)Ë<< 
GC_MODEL_MINALIGN_SHIFT
);

12  (0 =((
uöçå_t
)
p
 & 
mask
));

13 
	}
}

	@pointer.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
	#BOGUS_POINTER
 (
poöãr
)0x1

	)

13 
ölöe
 
boﬁ
 
isPoöãr
 (
poöãr
 
p
);

	@profiling.c

10 
GC_¥ofûeMa°îIndex
 
	$sour˚IndexToProfûeMa°îIndex
 (
GC_°©e
 
s
,

11 
GC_sour˚Index
 
i
)

13 
GC_¥ofûeMa°îIndex
 
pmi
;

14 
pmi
 = 
s
->
sour˚M≠s
.
sour˚s
[
i
].
sour˚NameIndex
 + s->sour˚M≠s.
sour˚sLígth
;

15 i‡(
DEBUG_PROFILE
)

16 
	`Ârötf
 (
°dîr
, "%"
PRIu32
" = sour˚IndexToProfûeMa°îIndex ("
FMTSI
")\n", 
pmi
, 
i
);

17  
pmi
;

18 
	}
}

20 
GC_sour˚NameIndex
 
	$¥ofûeMa°îIndexToSour˚NameIndex
 (
GC_°©e
 
s
,

21 
GC_¥ofûeMa°îIndex
 
i
) {

22 
	`as£π
 (
i
 >
s
->
sour˚M≠s
.
sour˚sLígth
);

23  
i
 - 
s
->
sour˚M≠s
.
sour˚sLígth
;

24 
	}
}

26 * 
	$¥ofûeIndexSour˚Name
 (
GC_°©e
 
s
, 
GC_sour˚Index
 
i
) {

27 * 
ªs
;

29 i‡(
i
 < 
s
->
sour˚M≠s
.
sour˚sLígth
)

30 
ªs
 = 
	`gëSour˚Name
 (
s
, 
i
);

32 
ªs
 = 
s
->
sour˚M≠s
.
sour˚Names
[
	`¥ofûeMa°îIndexToSour˚NameIndex
 (s, 
i
)];

33  
ªs
;

34 
	}
}

36 
GC_¥ofûeSèck
 
	$gëProfûeSèckInfo
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
) {

37 
	`as£π
 (
s
->
¥ofûög
.
d©a
 !
NULL
);

38  &(
s
->
¥ofûög
.
d©a
->
°ack
[
i
]);

39 
	}
}

41 
	g¥ofûeDïth
 = 0;

43 
	$¥ofûeIndít
 () {

44 
i
;

46 
i
 = 0; i < 
¥ofûeDïth
; ++i)

47 
	`Ârötf
 (
°dîr
, " ");

48 
	}
}

50 
	$addToSèckF‹Profûög
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
) {

51 
GC_¥ofûeD©a
 
p
;

52 
GC_¥ofûeSèck
 
ps
;

54 
p
 = 
s
->
¥ofûög
.
d©a
;

55 
ps
 = 
	`gëProfûeSèckInfo
 (
s
, 
i
);

56 i‡(
DEBUG_PROFILE
)

57 
	`Ârötf
 (
°dîr
, "addög %†tÿ°ackÜa°TŸÆ = %"
PRIuMAX
"ÜastTotalGC = %"PRIuMAX"\n",

58 
	`gëSour˚Name
 (
s
, 
i
),

59 (
uötmax_t
)
p
->
tŸÆ
,

60 (
uötmax_t
)
p
->
tŸÆGC
);

61 
ps
->
œ°TŸÆ
 = 
p
->
tŸÆ
;

62 
ps
->
œ°TŸÆGC
 = 
p
->
tŸÆGC
;

63 
	}
}

65 
	$íãrSour˚F‹Profûög
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
) {

66 
GC_¥ofûeSèck
 
ps
;

68 
ps
 = 
	`gëProfûeSèckInfo
 (
s
, 
i
);

70 
ps
->
numOccuºí˚s
++;

71 i‡(1 =
ps
->
numOccuºí˚s
) {

72 
	`addToSèckF‹Profûög
 (
s
, 
i
);

74 
	}
}

76 
	$íãrF‹Profûög
 (
GC_°©e
 
s
, 
GC_sour˚SeqIndex
 
sour˚SeqIndex
) {

77 
uöt32_t
 
i
;

78 
GC_sour˚Index
 
sour˚Index
;

79 
uöt32_t
 *
sour˚Seq
;

81 i‡(
DEBUG_PROFILE
)

82 
	`Ârötf
 (
°dîr
, "íãrF‹Profûög ("
FMTSSI
")\n", 
sour˚SeqIndex
);

83 
	`as£π
 (
s
->
¥ofûög
.
°ack
);

84 
	`as£π
 (
sour˚SeqIndex
 < 
s
->
sour˚M≠s
.
sour˚SeqsLígth
);

85 
sour˚Seq
 = 
s
->
sour˚M≠s
.
sour˚Seqs
[
sour˚SeqIndex
];

86 
i
 = 1; i <
sour˚Seq
[0]; i++) {

87 
sour˚Index
 = 
sour˚Seq
[
i
];

88 i‡(
DEBUG_ENTER_LEAVE
 
‹
 
DEBUG_PROFILE
) {

89 
	`¥ofûeIndít
 ();

90 
	`Ârötf
 (
°dîr
, "(entering %s\n",

91 
	`gëSour˚Name
 (
s
, 
sour˚Index
));

92 
¥ofûeDïth
++;

94 
	`íãrSour˚F‹Profûög
 (
s
, (
GC_¥ofûeMa°îIndex
)
sour˚Index
);

95 
	`íãrSour˚F‹Profûög
 (
s
, 
	`sour˚IndexToProfûeMa°îIndex
 (s, 
sour˚Index
));

97 
	}
}

99 
	$íãrFømeF‹Profûög
 (
GC_°©e
 
s
, 
GC_‰ameIndex
 
i
) {

100 
	`íãrF‹Profûög
 (
s
, s->
sour˚M≠s
.
‰ameSour˚s
[
i
]);

101 
	}
}

103 
	$GC_¥ofûeE¡î
 (
GC_°©e
 
s
) {

104 
	`íãrF‹Profûög
 (
s
, 
	`gëCachedSèckT›FømeSour˚SeqIndex
 (s));

105 
	}
}

107 
	$ªmoveFromSèckF‹Profûög
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
) {

108 
GC_¥ofûeD©a
 
p
;

109 
GC_¥ofûeSèck
 
ps
;

111 
p
 = 
s
->
¥ofûög
.
d©a
;

112 
ps
 = 
	`gëProfûeSèckInfo
 (
s
, 
i
);

113 i‡(
DEBUG_PROFILE
)

114 
	`Ârötf
 (
°dîr
, "ªmovög %†‰om sèckÅicksIn¯%"
PRIuMAX
"ÅicksGCInc = %"PRIuMAX"\n",

115 
	`¥ofûeIndexSour˚Name
 (
s
, 
i
),

116 (
uötmax_t
)(
p
->
tŸÆ
 - 
ps
->
œ°TŸÆ
),

117 (
uötmax_t
)(
p
->
tŸÆGC
 - 
ps
->
œ°TŸÆGC
));

118 
ps
->
ticks
 +
p
->
tŸÆ
 -Ös->
œ°TŸÆ
;

119 
ps
->
ticksGC
 +
p
->
tŸÆGC
 -Ös->
œ°TŸÆGC
;

120 
	}
}

122 
	$ÀaveSour˚F‹Profûög
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
) {

123 
GC_¥ofûeSèck
 
ps
;

125 
ps
 = 
	`gëProfûeSèckInfo
 (
s
, 
i
);

126 
	`as£π
 (
ps
->
numOccuºí˚s
 > 0);

127 
ps
->
numOccuºí˚s
--;

128 i‡(0 =
ps
->
numOccuºí˚s
)

129 
	`ªmoveFromSèckF‹Profûög
 (
s
, 
i
);

130 
	}
}

132 
	$ÀaveF‹Profûög
 (
GC_°©e
 
s
, 
GC_sour˚SeqIndex
 
sour˚SeqIndex
) {

133 
uöt32_t
 
i
;

134 
GC_sour˚Index
 
sour˚Index
;

135 
uöt32_t
 *
sour˚Seq
;

137 i‡(
DEBUG_PROFILE
)

138 
	`Ârötf
 (
°dîr
, "ÀaveF‹Profûög ("
FMTSSI
")\n", 
sour˚SeqIndex
);

139 
	`as£π
 (
s
->
¥ofûög
.
°ack
);

140 
	`as£π
 (
sour˚SeqIndex
 < 
s
->
sour˚M≠s
.
sour˚SeqsLígth
);

141 
sour˚Seq
 = 
s
->
sour˚M≠s
.
sour˚Seqs
[
sour˚SeqIndex
];

142 
i
 = 
sour˚Seq
[0]; i > 0; i--) {

143 
sour˚Index
 = 
sour˚Seq
[
i
];

144 i‡(
DEBUG_ENTER_LEAVE
 
‹
 
DEBUG_PROFILE
) {

145 
¥ofûeDïth
--;

146 
	`¥ofûeIndít
 ();

147 
	`Ârötf
 (
°dîr
, "leaving %s)\n",

148 
	`gëSour˚Name
 (
s
, 
sour˚Index
));

150 
	`ÀaveSour˚F‹Profûög
 (
s
, (
GC_¥ofûeMa°îIndex
)
sour˚Index
);

151 
	`ÀaveSour˚F‹Profûög
 (
s
, 
	`sour˚IndexToProfûeMa°îIndex
 (s, 
sour˚Index
));

153 
	}
}

155 
	$GC_¥ofûeLóve
 (
GC_°©e
 
s
) {

156 
	`ÀaveF‹Profûög
 (
s
, 
	`gëCachedSèckT›FømeSour˚SeqIndex
 (s));

157 
	}
}

160 
	$öcF‹Profûög
 (
GC_°©e
 
s
, 
size_t
 
amou¡
, 
GC_sour˚SeqIndex
 
sour˚SeqIndex
) {

161 
uöt32_t
 *
sour˚Seq
;

162 
GC_sour˚Index
 
t›Sour˚Index
;

164 i‡(
DEBUG_PROFILE
)

165 
	`Ârötf
 (
°dîr
, "öcF‹Profûög (%"
PRIuMAX
", "
FMTSSI
")\n",

166 (
uötmax_t
)
amou¡
, 
sour˚SeqIndex
);

167 
	`as£π
 (
sour˚SeqIndex
 < 
s
->
sour˚M≠s
.
sour˚SeqsLígth
);

168 
sour˚Seq
 = 
s
->
sour˚M≠s
.
sour˚Seqs
[
sour˚SeqIndex
];

169 
t›Sour˚Index
 =

170 
sour˚Seq
[0] > 0

171 ? 
sour˚Seq
[sourceSeq[0]]

172 : 
SOURCES_INDEX_UNKNOWN
;

173 i‡(
DEBUG_PROFILE
) {

174 
	`¥ofûeIndít
 ();

175 
	`Ârötf
 (
°dîr
, "bumpög %†by %"
PRIuMAX
"\n",

176 
	`gëSour˚Name
 (
s
, 
t›Sour˚Index
), (
uötmax_t
)
amou¡
);

178 
s
->
¥ofûög
.
d©a
->
cou¡T›
[
t›Sour˚Index
] +
amou¡
;

179 
s
->
¥ofûög
.
d©a
->
cou¡T›
[
	`sour˚IndexToProfûeMa°îIndex
 (s, 
t›Sour˚Index
)] +
amou¡
;

180 i‡(
s
->
¥ofûög
.
°ack
)

181 
	`íãrF‹Profûög
 (
s
, 
sour˚SeqIndex
);

182 i‡(
SOURCES_INDEX_GC
 =
t›Sour˚Index
)

183 
s
->
¥ofûög
.
d©a
->
tŸÆGC
 +
amou¡
;

185 
s
->
¥ofûög
.
d©a
->
tŸÆ
 +
amou¡
;

186 i‡(
s
->
¥ofûög
.
°ack
)

187 
	`ÀaveF‹Profûög
 (
s
, 
sour˚SeqIndex
);

188 
	}
}

190 
	$GC_¥ofûeInc
 (
GC_°©e
 
s
, 
size_t
 
amou¡
) {

191 i‡(
DEBUG_PROFILE
)

192 
	`Ârötf
 (
°dîr
, "GC_¥ofûeIn¯(%"
PRIuMAX
")\n", (
uötmax_t
)
amou¡
);

193 
	`öcF‹Profûög
 (
s
, 
amou¡
,

194 
s
->
amInGC


195 ? 
SOURCE_SEQ_GC


196 : 
	`gëCachedSèckT›FømeSour˚SeqIndex
 (
s
));

197 
	}
}

199 
	$GC_¥ofûeAŒocInc
 (
GC_°©e
 
s
, 
size_t
 
amou¡
) {

200 i‡(
s
->
¥ofûög
.
isOn
 
	`™d
 (
PROFILE_ALLOC
 =s->¥ofûög.
köd
)) {

201 i‡(
DEBUG_PROFILE
)

202 
	`Ârötf
 (
°dîr
, "GC_¥ofûeAŒocIn¯(%"
PRIuMAX
")\n", (
uötmax_t
)
amou¡
);

203 
	`GC_¥ofûeInc
 (
s
, 
amou¡
);

205 
	}
}

207 
GC_¥ofûeD©a
 
	$¥ofûeMÆloc
 (
GC_°©e
 
s
) {

208 
GC_¥ofûeD©a
 
p
;

209 
uöt32_t
 
¥ofûeMa°îLígth
;

211 
p
 = (
GC_¥ofûeD©a
)(
	`mÆloc_ß„
 ((*p)));

212 
p
->
tŸÆ
 = 0;

213 
p
->
tŸÆGC
 = 0;

214 
¥ofûeMa°îLígth
 = 
s
->
sour˚M≠s
.
sour˚sLígth
 + s->sour˚M≠s.
sour˚NamesLígth
;

215 
p
->
cou¡T›
 = (
uötmax_t
*)(
	`ˇŒoc_ß„
(
¥ofûeMa°îLígth
, (*(p->countTop))));

216 i‡(
s
->
¥ofûög
.
°ack
)

217 
p
->
°ack
 =

218 (
GC_¥ofûeSèck
 *)

219 (
	`ˇŒoc_ß„
(
¥ofûeMa°îLígth
, (*(
p
->
°ack
))));

220 i‡(
DEBUG_PROFILE
)

221 
	`Ârötf
 (
°dîr
, 
FMTPTR
" =ÖrofûeMÆlo¯()\n", (
uöçå_t
)
p
);

222  
p
;

223 
	}
}

225 
GC_¥ofûeD©a
 
	$GC_¥ofûeMÆloc
 (
GC_°©e
 
s
) {

226  
	`¥ofûeMÆloc
 (
s
);

227 
	}
}

229 
	$¥ofûeFªe
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
) {

230 i‡(
DEBUG_PROFILE
)

231 
	`Ârötf
 (
°dîr
, "¥ofûeFªê("
FMTPTR
")\n", (
uöçå_t
)
p
);

232 
	`‰ì
 (
p
->
cou¡T›
);

233 i‡(
s
->
¥ofûög
.
°ack
)

234 
	`‰ì
 (
p
->
°ack
);

235 
	`‰ì
 (
p
);

236 
	}
}

238 
	$GC_¥ofûeFªe
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
) {

239 
	`¥ofûeFªe
 (
s
, 
p
);

240 
	}
}

242 
	$wrôeProfûeCou¡
 (
GC_°©e
 
s
, 
FILE
 *
f
,

243 
GC_¥ofûeD©a
 
p
, 
GC_¥ofûeMa°îIndex
 
i
) {

244 
	`wrôeUötmaxU
 (
f
, 
p
->
cou¡T›
[
i
]);

245 i‡(
s
->
¥ofûög
.
°ack
) {

246 
GC_¥ofûeSèck
 
ps
;

248 
ps
 = &(
p
->
°ack
[
i
]);

249 
	`wrôeSåög
 (
f
, " ");

250 
	`wrôeUötmaxU
 (
f
, 
ps
->
ticks
);

251 
	`wrôeSåög
 (
f
, " ");

252 
	`wrôeUötmaxU
 (
f
, 
ps
->
ticksGC
);

254 
	`wrôeNewlöe
 (
f
);

255 
	}
}

257 
	$¥ofûeWrôe
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
, c⁄° *
fûeName
) {

258 
FILE
 *
f
;

259 c⁄° * 
köd
;

261 i‡(
DEBUG_PROFILE
)

262 
	`Ârötf
 (
°dîr
, "¥ofûeWrôe("
FMTPTR
",%s)\n", (
uöçå_t
)
p
, 
fûeName
);

263 
f
 = 
	`f›í_ß„
 (
fûeName
, "wb");

264 
	`wrôeSåög
 (
f
, "MLtonÖrof\n");

265 
s
->
¥ofûög
.
köd
) {

266 
PROFILE_ALLOC
:

267 
köd
 = "alloc\n";

269 
PROFILE_COUNT
:

270 
köd
 = "count\n";

272 
PROFILE_NONE
:

273 
	`dõ
 ("impossible PROFILE_NONE");

275 
PROFILE_TIME_FIELD
:

276 
köd
 = "time\n";

278 
PROFILE_TIME_LABEL
:

279 
köd
 = "time\n";

282 
köd
 = "";

283 
	`as£π
 (
FALSE
);

285 
	`wrôeSåög
 (
f
, 
köd
);

286 
	`wrôeSåög
 (
f
, 
s
->
¥ofûög
.
°ack
 ? "stack\n" : "current\n");

287 
	`wrôeUöt32X
 (
f
, 
s
->
magic
);

288 
	`wrôeNewlöe
 (
f
);

289 
	`wrôeUötmaxU
 (
f
, 
p
->
tŸÆ
);

290 
	`wrôeSåög
 (
f
, " ");

291 
	`wrôeUötmaxU
 (
f
, 
p
->
tŸÆGC
);

292 
	`wrôeNewlöe
 (
f
);

293 
	`wrôeUöt32U
 (
f
, 
s
->
sour˚M≠s
.
sour˚sLígth
);

294 
	`wrôeNewlöe
 (
f
);

295 
GC_sour˚Index
 
i
 = 0; i < 
s
->
sour˚M≠s
.
sour˚sLígth
; i++)

296 
	`wrôeProfûeCou¡
 (
s
, 
f
, 
p
,

297 (
GC_¥ofûeMa°îIndex
)
i
);

298 
	`wrôeUöt32U
 (
f
, 
s
->
sour˚M≠s
.
sour˚NamesLígth
);

299 
	`wrôeNewlöe
 (
f
);

300 
GC_sour˚NameIndex
 
i
 = 0; i < 
s
->
sour˚M≠s
.
sour˚NamesLígth
; i++)

301 
	`wrôeProfûeCou¡
 (
s
, 
f
, 
p
,

302 (
GC_¥ofûeMa°îIndex
)(
i
 + 
s
->
sour˚M≠s
.
sour˚sLígth
));

303 
	`f˛o£_ß„
 (
f
);

304 
	}
}

306 
	$GC_¥ofûeWrôe
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
, 
NuŒSåög8_t
 
fûeName
) {

307 
	`¥ofûeWrôe
 (
s
, 
p
, (c⁄° *)
fûeName
);

308 
	}
}

310 
	$£tProfTimî
 (
su£c⁄ds_t
 
u£c
) {

311 
ôimîvÆ
 
iv
;

313 
iv
.
ô_öãrvÆ
.
tv_£c
 = 0;

314 
iv
.
ô_öãrvÆ
.
tv_u£c
 = 
u£c
;

315 
iv
.
ô_vÆue
.
tv_£c
 = 0;

316 
iv
.
ô_vÆue
.
tv_u£c
 = 
u£c
;

317 
	`u∆ess
 (0 =
	`£tôimî
 (
ITIMER_PROF
, &
iv
, 
NULL
))

318 
	`dõ
 ("setProfTimer: setitimer failed");

319 
	}
}

321 #i‡
nŸ
 
HAS_TIME_PROFILING


327 
__©åibuã__
 ((
n‹ëu∫
))

328 
öôProfûögTime
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
) {

329 
dõ
 ("noÅimeÖrofiling");

334 
GC_°©e
 
	gh™dÀSigProfSèã
;

336 
	$GC_h™dÀSigProf
 (
code_poöãr
 
pc
) {

337 
GC_‰ameIndex
 
‰ameIndex
;

338 
GC_°©e
 
s
;

339 
GC_sour˚SeqIndex
 
sour˚SeqsIndex
;

341 
s
 = 
h™dÀSigProfSèã
;

342 i‡(
DEBUG_PROFILE
)

343 
	`Ârötf
 (
°dîr
, "GC_h™dÀSigPro‡("
FMTPTR
")\n", (
uöçå_t
)
pc
);

344 i‡(
s
->
amInGC
)

345 
sour˚SeqsIndex
 = 
SOURCE_SEQ_GC
;

347 
‰ameIndex
 = 
	`gëCachedSèckT›FømeIndex
 (
s
);

348 i‡(
C_FRAME
 =
s
->
‰ameLayouts
[
‰ameIndex
].
köd
)

349 
sour˚SeqsIndex
 = 
s
->
sour˚M≠s
.
‰ameSour˚s
[
‰ameIndex
];

351 i‡(
PROFILE_TIME_LABEL
 =
s
->
¥ofûög
.
köd
) {

352 
uöt32_t
 
°¨t
, 
íd
, 
i
;

355 
°¨t
 = 0;

356 
íd
 = 
s
->
sour˚M≠s
.
sour˚LabñsLígth
;

357 
íd
 - 
°¨t
 > 1) {

358 
i
 = (
°¨t
+
íd
)/2;

359 i‡((
uöçå_t
)
s
->
sour˚M≠s
.
sour˚Labñs
[
i
].
œbñ
 <(uöçå_t)
pc
)

360 
°¨t
 = 
i
;

362 
íd
 = 
i
;

364 
i
 = 
°¨t
;

369 i‡(
i
-1 =
s
->
sour˚M≠s
.
sour˚LabñsLígth
 ||

370 (
i
 == 0 &&

371 (
uöçå_t
)
pc
 < (uöçå_t)
s
->
sour˚M≠s
.
sour˚Labñs
[
i
].
œbñ
)) {

372 i‡(
DEBUG_PROFILE
)

373 
	`Ârötf
 (
°dîr
, "pc out of bounds\n");

374 
sour˚SeqsIndex
 = 
SOURCE_SEQ_UNKNOWN
;

376 
sour˚SeqsIndex
 = 
s
->
sour˚M≠s
.
sour˚Labñs
[
°¨t
].
sour˚SeqIndex
;

379 
sour˚SeqsIndex
 = 
s
->
sour˚M≠s
.
curSour˚SeqsIndex
;

383 
	`öcF‹Profûög
 (
s
, 1, 
sour˚SeqsIndex
);

384 
	}
}

386 
	$öôProfûögTime
 (
GC_°©e
 
s
) {

387 
siga˘i⁄
 
ß
;

389 
s
->
¥ofûög
.
d©a
 = 
	`¥ofûeMÆloc
 (s);

390 i‡(
PROFILE_TIME_LABEL
 =
s
->
¥ofûög
.
köd
) {

391 
	`öôSour˚Labñs
 (
s
);

393 
s
->
sour˚M≠s
.
curSour˚SeqsIndex
 = 
SOURCE_SEQ_UNKNOWN
;

408 
h™dÀSigProfSèã
 = 
s
;

409 
	`sigem±y£t
 (&
ß
.
ß_mask
);

410 
	`GC_£tSigProfH™dÀr
 (&
ß
);

411 
	`u∆ess
 (
	`siga˘i⁄
 (
SIGPROF
, &
ß
, 
NULL
) == 0)

412 
	`dõe
 ("initProfilingTime: sigaction failed");

414 
	`£tProfTimî
 (10000);

415 
	}
}

424 
GC_°©e
 
	g©exôF‹ProfûögSèã
;

426 
	$©exôF‹Profûög
 () {

427 
GC_°©e
 
s
;

429 i‡(
DEBUG_PROFILE
)

430 
	`Ârötf
 (
°dîr
, "atexitForProfiling ()\n");

431 
s
 = 
©exôF‹ProfûögSèã
;

432 i‡(
s
->
¥ofûög
.
isOn
) {

433 
	`Ârötf
 (
°dîr
, "profiling is on\n");

434 
	`¥ofûeWrôe
 (
s
, s->
¥ofûög
.
d©a
, "mlmon.out");

436 
	}
}

438 
	$öôProfûög
 (
GC_°©e
 
s
) {

439 i‡(
PROFILE_NONE
 =
s
->
¥ofûög
.
köd
)

440 
s
->
¥ofûög
.
isOn
 = 
FALSE
;

442 
s
->
¥ofûög
.
isOn
 = 
TRUE
;

443 
	`as£π
 (
s
->
sour˚M≠s
.
‰ameSour˚sLígth
 =s->
‰ameLayoutsLígth
);

444 
s
->
¥ofûög
.
köd
) {

445 
PROFILE_ALLOC
:

446 
PROFILE_COUNT
:

447 
s
->
¥ofûög
.
d©a
 = 
	`¥ofûeMÆloc
 (s);

449 
PROFILE_NONE
:

450 
	`dõ
 ("impossible PROFILE_NONE");

452 
PROFILE_TIME_FIELD
:

453 
PROFILE_TIME_LABEL
:

454 
	`öôProfûögTime
 (
s
);

457 
	`as£π
 (
FALSE
);

459 
©exôF‹ProfûögSèã
 = 
s
;

460 
	`©exô
 (
©exôF‹Profûög
);

462 
	}
}

464 
	$GC_¥ofûeD⁄e
 (
GC_°©e
 
s
) {

465 
GC_¥ofûeD©a
 
p
;

466 
GC_¥ofûeMa°îIndex
 
¥ofûeMa°îIndex
;

468 i‡(
DEBUG_PROFILE
)

469 
	`Ârötf
 (
°dîr
, "GC_profileDone ()\n");

470 
	`as£π
 (
s
->
¥ofûög
.
isOn
);

471 i‡(
PROFILE_TIME_FIELD
 =
s
->
¥ofûög
.
köd


472 
‹
 
PROFILE_TIME_LABEL
 =
s
->
¥ofûög
.
köd
)

473 
	`£tProfTimî
 (0);

474 
s
->
¥ofûög
.
isOn
 = 
FALSE
;

475 
p
 = 
s
->
¥ofûög
.
d©a
;

476 i‡(
s
->
¥ofûög
.
°ack
) {

477 
uöt32_t
 
¥ofûeMa°îLígth
 =

478 
s
->
sour˚M≠s
.
sour˚sLígth
 + s->sour˚M≠s.
sour˚NamesLígth
;

479 
¥ofûeMa°îIndex
 = 0;

480 
¥ofûeMa°îIndex
 < 
¥ofûeMa°îLígth
;

481 
¥ofûeMa°îIndex
++) {

482 i‡(
p
->
°ack
[
¥ofûeMa°îIndex
].
numOccuºí˚s
 > 0) {

483 i‡(
DEBUG_PROFILE
)

484 
	`Ârötf
 (
°dîr
, "doneÜeaving %s\n",

485 
	`¥ofûeIndexSour˚Name
 (
s
, 
¥ofûeMa°îIndex
));

486 
	`ªmoveFromSèckF‹Profûög
 (
s
, 
¥ofûeMa°îIndex
);

490 
	}
}

493 
GC_¥ofûeD©a
 
	$GC_gëProfûeCuºít
 (
GC_°©e
 
s
) {

494  
s
->
¥ofûög
.
d©a
;

495 
	}
}

496 
	$GC_£tProfûeCuºít
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
) {

497 
s
->
¥ofûög
.
d©a
 = 
p
;

498 
	}
}

	@profiling.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

13 
	mPROFILE_ALLOC
,

14 
	mPROFILE_COUNT
,

15 
	mPROFILE_NONE
,

16 
	mPROFILE_TIME_FIELD
,

17 
	mPROFILE_TIME_LABEL


18 } 
	tGC_¥ofûeKöd
;

23 
	sGC_¥ofûeSèck
 {

25 
uötmax_t
 
	mticks
;

27 
uötmax_t
 
	mticksGC
;

34 
uötmax_t
 
	mœ°TŸÆ
;

36 
uötmax_t
 
	mœ°TŸÆGC
;

40 
uötmax_t
 
	mnumOccuºí˚s
;

41 } *
	tGC_¥ofûeSèck
;

43 
uöt32_t
 
	tGC_¥ofûeMa°îIndex
;

53 
	sGC_¥ofûeD©a
 {

57 
uötmax_t
 *
	mcou¡T›
;

61 
GC_¥ofûeSèck
 *
	m°ack
;

63 
uötmax_t
 
	mtŸÆ
;

65 
uötmax_t
 
	mtŸÆGC
;

66 } *
	tGC_¥ofûeD©a
;

68 
	sGC_¥ofûög
 {

69 
GC_¥ofûeD©a
 
	md©a
;

70 
boﬁ
 
	misOn
;

71 
GC_¥ofûeKöd
 
	mköd
;

72 
boﬁ
 
	m°ack
;

77 
	gGC_¥ofûeD©a
;

78 
GC_¥ofûeD©a
 *
	tGC_¥ofûeD©a
;

82 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

84 
ölöe
 
GC_¥ofûeMa°îIndex
 
sour˚IndexToProfûeMa°îIndex
 (
GC_°©e
 
s
, 
GC_sour˚Index
 
i
);

85 
ölöe
 
GC_sour˚NameIndex
 
¥ofûeMa°îIndexToSour˚NameIndex
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
);

86 
ölöe
 
GC_¥ofûeSèck
 
gëProfûeSèckInfo
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
);

88 
ölöe
 
addToSèckF‹Profûög
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
);

89 
ölöe
 
íãrSour˚F‹Profûög
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
);

90 
ölöe
 
íãrF‹Profûög
 (
GC_°©e
 
s
, 
GC_sour˚SeqIndex
 
sour˚SeqIndex
);

91 
ölöe
 
íãrFømeF‹Profûög
 (
GC_°©e
 
s
, 
GC_‰ameIndex
 
i
);

93 
ölöe
 
ªmoveFromSèckF‹Profûög
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
);

94 
ölöe
 
ÀaveSour˚F‹Profûög
 (
GC_°©e
 
s
, 
GC_¥ofûeMa°îIndex
 
i
);

95 
ölöe
 
ÀaveF‹Profûög
 (
GC_°©e
 
s
, 
GC_sour˚SeqIndex
 
sour˚SeqIndex
);

97 
ölöe
 
öcF‹Profûög
 (
GC_°©e
 
s
, 
size_t
 
amou¡
, 
GC_sour˚SeqIndex
 
sour˚SeqIndex
);

99 
ölöe
 * 
¥ofûeIndexSour˚Name
 (
GC_°©e
 
s
, 
GC_sour˚Index
 
i
);

101 
wrôeProfûeCou¡
 (
GC_°©e
 
s
, 
FILE
 *
f
, 
GC_¥ofûeD©a
 
p
, 
GC_¥ofûeMa°îIndex
 
i
);

103 
PRIVATE
 
GC_¥ofûeD©a
 
¥ofûeMÆloc
 (
GC_°©e
 
s
);

104 
PRIVATE
 
¥ofûeWrôe
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
, c⁄° * 
fûeName
);

105 
PRIVATE
 
¥ofûeFªe
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
);

107 
£tProfTimî
 (
su£c⁄ds_t
 
u£c
);

108 
öôProfûögTime
 (
GC_°©e
 
s
);

109 
©exôF‹Profûög
 ();

110 
öôProfûög
 (
GC_°©e
 
s
);

114 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

116 
PRIVATE
 
GC_¥ofûeE¡î
 (
GC_°©e
 
s
);

117 
PRIVATE
 
GC_¥ofûeLóve
 (
GC_°©e
 
s
);

118 
PRIVATE
 
GC_¥ofûeInc
 (
GC_°©e
 
s
, 
size_t
 
amou¡
);

119 
PRIVATE
 
GC_¥ofûeAŒocInc
 (
GC_°©e
 
s
, 
size_t
 
amou¡
);

121 
PRIVATE
 
GC_¥ofûeD©a
 
GC_gëProfûeCuºít
 (
GC_°©e
 
s
);

122 
PRIVATE
 
GC_£tProfûeCuºít
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
);

124 
PRIVATE
 
GC_¥ofûeD©a
 
GC_¥ofûeMÆloc
 (
GC_°©e
 
s
);

125 
PRIVATE
 
GC_¥ofûeWrôe
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
, 
NuŒSåög8_t
 
fûeName
);

126 
PRIVATE
 
GC_¥ofûeFªe
 (
GC_°©e
 
s
, 
GC_¥ofûeD©a
 
p
);

128 
PRIVATE
 
GC_¥ofûeD⁄e
 (
GC_°©e
 
s
);

132 
PRIVATE
 
GC_h™dÀSigProf
 (
code_poöãr
 
pc
);

	@read_write.c

9 
ölöe
 
obj±r
 
	$ªadObj±r
 (
FILE
 *
f
) {

10 
obj±r
 
ªs
;

11 
	`‰ód_ß„
 (&
ªs
, (
obj±r
), 1, 
f
);

12  
ªs
;

13 
	}
}

15 
ölöe
 
poöãr
 
	$ªadPoöãr
 (
FILE
 *
f
) {

16 
uöçå_t
 
ªs
;

17 
	`‰ód_ß„
 (&
ªs
, (
uöçå_t
), 1, 
f
);

18  (
poöãr
)
ªs
;

19 
	}
}

21 
ölöe
 
	$wrôeObj±r
 (
FILE
 *
f
, 
obj±r
 
›
) {

22 
	`fwrôe_ß„
 (&
›
, (
obj±r
), 1, 
f
);

23 
	}
}

25 
ölöe
 
	$wrôePoöãr
 (
FILE
 *
f
, 
poöãr
 
p
) {

26 
uöçå_t
 
u
 = (uöçå_t)
p
;

27 
	`fwrôe_ß„
 (&
u
, (
uöçå_t
), 1, 
f
);

28 
	}
}

	@rusage.c

10 
	$rußgeZîo
 (
rußge
 *
ru
) {

11 
	`mem£t
 (
ru
, 0,  (*ru));

12 
	}
}

14 
	$rußgePlusMax
 (
rußge
 *
ru1
,

15 
rußge
 *
ru2
,

16 
rußge
 *
ru
) {

17 c⁄° 
mûli⁄
 = 1000000;

18 
time_t
 
£c
;

19 
su£c⁄ds_t
 
u£c
;

21 
£c
 = 
ru1
->
ru_utime
.
tv_£c
 + 
ru2
->ru_utime.tv_sec;

22 
u£c
 = 
ru1
->
ru_utime
.
tv_u£c
 + 
ru2
->ru_utime.tv_usec;

23 
£c
 +(
u£c
 / 
mûli⁄
);

24 
u£c
 %
mûli⁄
;

25 
ru
->
ru_utime
.
tv_£c
 = 
£c
;

26 
ru
->
ru_utime
.
tv_u£c
 = 
u£c
;

28 
£c
 = 
ru1
->
ru_°ime
.
tv_£c
 + 
ru2
->ru_stime.tv_sec;

29 
u£c
 = 
ru1
->
ru_°ime
.
tv_u£c
 + 
ru2
->ru_stime.tv_usec;

30 
£c
 +(
u£c
 / 
mûli⁄
);

31 
u£c
 %
mûli⁄
;

32 
ru
->
ru_°ime
.
tv_£c
 = 
£c
;

33 
ru
->
ru_°ime
.
tv_u£c
 = 
u£c
;

34 
	}
}

36 
	$rußgeMöusMax
 (
rußge
 *
ru1
,

37 
rußge
 *
ru2
,

38 
rußge
 *
ru
) {

39 c⁄° 
mûli⁄
 = 1000000;

40 
time_t
 
£c
;

41 
su£c⁄ds_t
 
u£c
;

43 
£c
 = (
ru1
->
ru_utime
.
tv_£c
 - 
ru2
->ru_utime.tv_sec) - 1;

44 
u£c
 = 
ru1
->
ru_utime
.
tv_u£c
 + 
mûli⁄
 - 
ru2
->ru_utime.tv_usec;

45 
£c
 +(
u£c
 / 
mûli⁄
);

46 
u£c
 %
mûli⁄
;

47 
ru
->
ru_utime
.
tv_£c
 = 
£c
;

48 
ru
->
ru_utime
.
tv_u£c
 = 
u£c
;

50 
£c
 = (
ru1
->
ru_°ime
.
tv_£c
 - 
ru2
->ru_stime.tv_sec) - 1;

51 
u£c
 = 
ru1
->
ru_°ime
.
tv_u£c
 + 
mûli⁄
 - 
ru2
->ru_stime.tv_usec;

52 
£c
 +(
u£c
 / 
mûli⁄
);

53 
u£c
 %
mûli⁄
;

54 
ru
->
ru_°ime
.
tv_£c
 = 
£c
;

55 
ru
->
ru_°ime
.
tv_u£c
 = 
u£c
;

56 
	}
}

58 
uötmax_t
 
	$rußgeTime
 (
rußge
 *
ru
) {

59 
uötmax_t
 
ªsu…
;

61 
ªsu…
 = 0;

62 
ªsu…
 +1000 * (
uötmax_t
)
ru
->
ru_utime
.
tv_£c
;

63 
ªsu…
 +1000 * (
uötmax_t
)
ru
->
ru_°ime
.
tv_£c
;

64 
ªsu…
 +(
uötmax_t
)
ru
->
ru_utime
.
tv_u£c
 / 1000;

65 
ªsu…
 +(
uötmax_t
)
ru
->
ru_°ime
.
tv_u£c
 / 1000;

66  
ªsu…
;

67 
	}
}

69 
	$°¨tTimög
 (
rußge
 *
ru_°¨t
) {

70 
	`gërußge
 (
RUSAGE_SELF
, 
ru_°¨t
);

71 
	}
}

74 
uötmax_t
 
	$°›Timög
 (
rußge
 *
ru_°¨t
, rußgê*
ru_acc
) {

75 
rußge
 
ru_föish
, 
ru_tŸÆ
;

77 
	`gërußge
 (
RUSAGE_SELF
, &
ru_föish
);

78 
	`rußgeMöusMax
 (&
ru_föish
, 
ru_°¨t
, &
ru_tŸÆ
);

79 
	`rußgePlusMax
 (
ru_acc
, &
ru_tŸÆ
,Ñu_acc);

80  
	`rußgeTime
 (&
ru_tŸÆ
);

81 
	}
}

	@rusage.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
rußgeZîo
 (
rußge
 *
ru
);

12 
ölöe
 
rußgePlusMax
 (
rußge
 *
ru1
,

13 
rußge
 *
ru2
,

14 
rußge
 *
ru
);

15 
ölöe
 
rußgeMöusMax
 (
rußge
 *
ru1
,

16 
rußge
 *
ru2
,

17 
rußge
 *
ru
);

18 
ölöe
 
uötmax_t
 
rußgeTime
 (
rußge
 *
ru
);

19 
ölöe
 
°¨tTimög
 (
rußge
 *
ru_°¨t
);

20 
uötmax_t
 
°›Timög
 (
rußge
 *
ru_°¨t
, rußgê*
ru_gc
);

	@share.c

9 
	$GC_sh¨e
 (
GC_°©e
 
s
, 
poöãr
 
obje˘
) {

10 
size_t
 
byãsExamöed
;

11 
size_t
 
byãsHashC⁄£d
;

13 
	`íãr
 (
s
);

14 i‡(
DEBUG_SHARE
)

15 
	`Ârötf
 (
°dîr
, "GC_sh¨ê"
FMTPTR
"\n", (
uöçå_t
)
obje˘
);

16 i‡(
DEBUG_SHARE
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

17 
s
->
œ°Maj‹Sèti°ics
.
byãsHashC⁄£d
 = 0;

19 
byãsExamöed
 = 
	`dfsM¨kByMode
 (
s
, 
obje˘
, 
MARK_MODE
, 
FALSE
, FALSE);

20 
s
->
obje˘HashTabÀ
 = 
	`ÆlocHashTabÀ
 (s);

22 
	`dfsM¨kByMode
 (
s
, 
obje˘
, 
UNMARK_MODE
, 
TRUE
, 
FALSE
);

23 
	`‰ìHashTabÀ
 (
s
->
obje˘HashTabÀ
);

24 
byãsHashC⁄£d
 = 
s
->
œ°Maj‹Sèti°ics
.bytesHashConsed;

25 
s
->
cumuœtiveSèti°ics
.
byãsHashC⁄£d
 += bytesHashConsed;

26 i‡(
DEBUG_SHARE
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

27 
	`¥ötByãsHashC⁄£dMesßge
 (
byãsHashC⁄£d
, 
byãsExamöed
);

28 
	`Àave
 (
s
);

29 
	}
}

	@share.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

11 
PRIVATE
 
GC_sh¨e
 (
GC_°©e
 
s
, 
poöãr
 
obje˘
);

	@signals.c

10 #i‡
nŸ
 
HAS_SIGALTSTACK


12 
öôSig«lSèck
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
) {

17 
	$öôSig«lSèck
 (
GC_°©e
 
s
) {

18 
boﬁ
 
öô
 = 
FALSE
;

19 
°ack_t
 
Æt°ack
;

21 i‡(! 
öô
) {

22 
öô
 = 
TRUE
;

23 
size_t
 
ss_size
 = 
	`Æign
 (
SIGSTKSZ
, 
s
->
sysvÆs
.
∑geSize
);

24 
size_t
 
psize
 = 
s
->
sysvÆs
.
∑geSize
;

25 *
ss_•
 = 
	`GC_mm≠An⁄_ß„_¥Ÿe˘
 (
NULL
, 2 * 
ss_size
, 
psize
,Ösize);

26 
Æt°ack
.
ss_•
 = (*)((
poöãr
)ss_• + 
ss_size
);

27 
Æt°ack
.
ss_size
 = ss_size;

28 
Æt°ack
.
ss_Êags
 = 0;

30 
	`sigÆt°ack
 (&
Æt°ack
, 
NULL
);

31 
	}
}

35 
	$GC_öôSig«lSèck
 (
GC_°©e
 
s
) {

36 
	`öôSig«lSèck
 (
s
);

37 
	}
}

	@signals.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

12 
	sGC_sig«lsInfo
 {

14 
boﬁ
 
	mamInSig«lH™dÀr
;

15 
boﬁ
 
	mgcSig«lH™dÀd
;

16 
boﬁ
 
	mgcSig«lPídög
;

20 vﬁ©ûê
uöt32_t
 
	msig«lIsPídög
;

24 
sig£t_t
 
	msig«lsH™dÀd
;

28 
sig£t_t
 
	msig«lsPídög
;

33 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

35 
öôSig«lSèck
 (
GC_°©e
 
s
);

39 
GC_öôSig«lSèck
 (
GC_°©e
 
s
);

	@size.c

9 
size_t
 
	$GC_size
 (
GC_°©e
 
s
, 
poöãr
 
roŸ
) {

10 
size_t
 
ªs
;

12 
	`íãr
 (
s
);

13 i‡(
DEBUG_SIZE
)

14 
	`Ârötf
 (
°dîr
, "GC_size marking\n");

15 
ªs
 = 
	`dfsM¨kByMode
 (
s
, 
roŸ
, 
MARK_MODE
, 
FALSE
, FALSE);

16 i‡(
DEBUG_SIZE
)

17 
	`Ârötf
 (
°dîr
, "GC_size unmarking\n");

18 
	`dfsM¨kByMode
 (
s
, 
roŸ
, 
UNMARK_MODE
, 
FALSE
, FALSE);

19 
	`Àave
(
s
);

21  
ªs
;

22 
	}
}

	@size.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

11 
PRIVATE
 
size_t
 
GC_size
 (
GC_°©e
 
s
, 
poöãr
 
roŸ
);

	@sources.c

9 
GC_sour˚SeqIndex
 
	$gëCachedSèckT›FømeSour˚SeqIndex
 (
GC_°©e
 
s
) {

10 
GC_‰ameIndex
 
i
;

12 
i
 = 
	`gëCachedSèckT›FømeIndex
 (
s
);

13 
	`as£π
(
i
 < 
s
->
sour˚M≠s
.
‰ameSour˚sLígth
);

14  
s
->
sour˚M≠s
.
‰ameSour˚s
[
i
];

15 
	}
}

17 * 
	$gëSour˚Name
 (
GC_°©e
 
s
, 
GC_sour˚Index
 
i
) {

18 
	`as£π
 (
i
 < 
s
->
sour˚M≠s
.
sour˚sLígth
);

19  
s
->
sour˚M≠s
.
sour˚Names
[s->sour˚M≠s.
sour˚s
[
i
].
sour˚NameIndex
];

20 
	}
}

22 * 
	$GC_sour˚Name
 (
GC_°©e
 
s
, 
GC_sour˚Index
 
i
) {

23  
	`gëSour˚Name
 (
s
, 
i
);

24 
	}
}

26 #i‡
HAS_TIME_PROFILING


28 
	$com∑ªSour˚Labñs
 (c⁄° *
v1
, c⁄° *
v2
) {

29 c⁄° 
GC_sour˚Labñ
* 
l1
 = (c⁄° GC_sour˚Labñ*)
v1
;

30 c⁄° 
GC_sour˚Labñ
* 
l2
 = (c⁄° GC_sour˚Labñ*)
v2
;

31 
uöçå_t
 
ui1
 = (uöçå_t)(
l1
->
œbñ
);

32 
uöçå_t
 
ui2
 = (uöçå_t)(
l2
->
œbñ
);

34 i‡(
ui1
 < 
ui2
)

36 i‡(
ui1
 =
ui2
)

40 
	}
}

42 
	$s‹tSour˚Labñs
 (
GC_°©e
 
s
) {

43 
GC_sour˚LabñIndex
 
i
;

46 
	`qs‹t
 (
s
->
sour˚M≠s
.
sour˚Labñs
,

47 
s
->
sour˚M≠s
.
sour˚LabñsLígth
,

48  (*
s
->
sour˚M≠s
.
sour˚Labñs
),

49 
com∑ªSour˚Labñs
);

50 i‡(0 =
s
->
sour˚M≠s
.
sour˚Labñs
[s->sour˚M≠s.
sour˚LabñsLígth
 - 1].
œbñ
)

51 
	`dõ
 ("Max sourceÜabel is 0 -- something is wrong.");

52 i‡(
ASSERT
)

53 
i
 = 1; i < 
s
->
sour˚M≠s
.
sour˚LabñsLígth
; i++)

54 
	`as£π
 (
s
->
sour˚M≠s
.
sour˚Labñs
[
i
-1].
œbñ


55 <
s
->
sour˚M≠s
.
sour˚Labñs
[
i
].
œbñ
);

56 
	}
}

58 
	$com¥essSour˚Labñs
 (
GC_°©e
 
s
) {

59 
GC_sour˚LabñIndex
 
ö
, 
out
, 
i
;

60 
GC_sour˚SeqIndex
 
sour˚SeqIndex
;

63 
out
 = 0;

64 
sour˚SeqIndex
 = 
SOURCE_SEQ_UNKNOWN
;

65 
ö
 = 0; i¿< 
s
->
sour˚M≠s
.
sour˚LabñsLígth
; ++in) {

66 i‡(
s
->
sour˚M≠s
.
sour˚Labñs
[
ö
].
sour˚SeqIndex
 != sourceSeqIndex) {

67 
s
->
sour˚M≠s
.
sour˚Labñs
[
out
++] = s->sour˚M≠s.sour˚Labñs[
ö
];

68 
sour˚SeqIndex
 = 
s
->
sour˚M≠s
.
sour˚Labñs
[
ö
].sourceSeqIndex;

72 
s
->
sour˚M≠s
.
sour˚LabñsLígth
 = 
out
;

74 i‡(
DEBUG_SOURCES
)

75 
i
 = 0; i < 
s
->
sour˚M≠s
.
sour˚LabñsLígth
; i++)

76 
	`Ârötf
 (
°dîr
, 
FMTPTR
" "
FMTSSI
"\n",

77 (
uöçå_t
)
s
->
sour˚M≠s
.
sour˚Labñs
[
i
].
œbñ
,

78 
s
->
sour˚M≠s
.
sour˚Labñs
[
i
].
sour˚SeqIndex
);

79 
	}
}

81 
	$öôSour˚Labñs
 (
GC_°©e
 
s
) {

82 
	`s‹tSour˚Labñs
 (
s
);

83 
	`com¥essSour˚Labñs
 (
s
);

84 
	}
}

88 
	$showSour˚s
 (
GC_°©e
 
s
) {

89 
uöt32_t
 
i
;

90 
uöt32_t
 
j
;

92 
	`Ârötf
 (
°dout
, "0x%08"
PRIx32
"\n", 
s
->
magic
);

93 
	`Ârötf
 (
°dout
, "%"
PRIu32
"\n", 
s
->
sour˚M≠s
.
sour˚NamesLígth
);

94 
i
 = 0; i < 
s
->
sour˚M≠s
.
sour˚NamesLígth
; i++)

95 
	`Ârötf
 (
°dout
, "%s\n", 
s
->
sour˚M≠s
.
sour˚Names
[
i
]);

96 
	`Ârötf
 (
°dout
, "%"
PRIu32
"\n", 
s
->
sour˚M≠s
.
sour˚sLígth
);

97 
i
 = 0; i < 
s
->
sour˚M≠s
.
sour˚sLígth
; i++)

98 
	`Ârötf
 (
°dout
, "%"
PRIu32
" %"PRIu32"\n",

99 
s
->
sour˚M≠s
.
sour˚s
[
i
].
sour˚NameIndex
,

100 
s
->
sour˚M≠s
.
sour˚s
[
i
].
suc˚ss‹Sour˚SeqIndex
);

101 
	`Ârötf
 (
°dout
, "%"
PRIu32
"\n", 
s
->
sour˚M≠s
.
sour˚SeqsLígth
);

102 
i
 = 0; i < 
s
->
sour˚M≠s
.
sour˚SeqsLígth
; i++) {

103 
uöt32_t
 *
sour˚Seq
;

105 
sour˚Seq
 = 
s
->
sour˚M≠s
.
sour˚Seqs
[
i
];

106 
j
 = 1; j <
sour˚Seq
[0]; j++)

107 
	`Ârötf
 (
°dout
, "%"
PRIu32
" ", 
sour˚Seq
[
j
]);

108 
	`Ârötf
 (
°dout
, "\n");

110 
	}
}

	@sources.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

11 
uöt32_t
 
	tGC_sour˚NameIndex
;

12 
	#PRISNI
 
PRIu32


	)

13 
	#FMTSNI
 "%"
PRISNI


	)

15 
uöt32_t
 
	tGC_sour˚LabñIndex
;

16 
	#PRISLI
 
PRIu32


	)

17 
	#FMTSLI
 "%"
PRISLI


	)

19 
uöt32_t
 
	tGC_sour˚Index
;

20 
	#PRISI
 
PRIu32


	)

21 
	#FMTSI
 "%"
PRISI


	)

23 
	#SOURCES_INDEX_UNKNOWN
 0

	)

24 
	#SOURCES_INDEX_GC
 1

	)

26 
uöt32_t
 
	tGC_sour˚SeqIndex
;

27 
	#PRISSI
 
PRIu32


	)

28 
	#FMTSSI
 "%"
PRISSI


	)

30 
	#SOURCE_SEQ_UNKNOWN
 0

	)

31 
	#SOURCE_SEQ_GC
 1

	)

33 
	sGC_sour˚
 {

34 
GC_sour˚NameIndex
 
	msour˚NameIndex
;

35 
GC_sour˚SeqIndex
 
	msuc˚ss‹Sour˚SeqIndex
;

36 } *
	tGC_sour˚
;

38 
	sGC_sour˚Labñ
 {

39 
code_poöãr
 
	mœbñ
;

40 
GC_sour˚SeqIndex
 
	msour˚SeqIndex
;

41 } *
	tGC_sour˚Labñ
;

43 
	sGC_sour˚M≠s
 {

44 vﬁ©ûê
GC_sour˚SeqIndex
 
	mcurSour˚SeqsIndex
;

49 
GC_sour˚SeqIndex
 *
	m‰ameSour˚s
;

50 
uöt32_t
 
	m‰ameSour˚sLígth
;

51 
GC_sour˚Labñ
 *
	msour˚Labñs
;

52 
uöt32_t
 
	msour˚LabñsLígth
;

53 **
	msour˚Names
;

54 
uöt32_t
 
	msour˚NamesLígth
;

58 
uöt32_t
 **
	msour˚Seqs
;

59 
uöt32_t
 
	msour˚SeqsLígth
;

64 
GC_sour˚
 *
	msour˚s
;

65 
uöt32_t
 
	msour˚sLígth
;

70 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

72 
ölöe
 
GC_sour˚SeqIndex
 
gëCachedSèckT›FømeSour˚SeqIndex
 (
GC_°©e
 
s
);

74 
ölöe
 * 
gëSour˚Name
 (
GC_°©e
 
s
, 
GC_sour˚Index
 
i
);

76 #i‡
HAS_TIME_PROFILING


77 
ölöe
 
com∑ªSour˚Labñs
 (c⁄° *
v1
, c⁄° *
v2
);

78 
s‹tSour˚Labñs
 (
GC_°©e
 
s
);

79 
com¥essSour˚Labñs
 (
GC_°©e
 
s
);

80 
öôSour˚Labñs
 (
GC_°©e
 
s
);

83 
showSour˚s
 (
GC_°©e
 
s
);

87 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

89 
PRIVATE
 * 
GC_sour˚Name
 (
GC_°©e
 
s
, 
GC_sour˚Index
 
i
);

	@stack.c

10 
di•œySèck
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

11 
GC_°ack
 
°ack
,

12 
FILE
 *
°ªam
) {

13 
Ârötf
(
°ªam
,

14 "\t\åe£rved = %"
PRIuMAX
"\n"

15 "\t\tu£d = %"
PRIuMAX
"\n",

16 (
uötmax_t
)
°ack
->
ª£rved
,

17 (
uötmax_t
)
°ack
->
u£d
);

21 #i‡
ASSERT


22 
boﬁ
 
	$isSèckEm±y
 (
GC_°ack
 
°ack
) {

23  0 =
°ack
->
u£d
;

24 
	}
}

26 
boﬁ
 
	$isSèckRe£rvedAlig√d
 (
GC_°©e
 
s
, 
size_t
 
ª£rved
) {

27  
	`isAlig√d
 (
GC_STACK_HEADER_SIZE
 +  (
GC_°ack
Ë+ 
ª£rved
,

28 
s
->
Æignmít
);

29 
	}
}

35 
size_t
 
	$sizeofSèckSl›
 (
GC_°©e
 
s
) {

37  (
size_t
)(2 * 
s
->
maxFømeSize
);

38 
	}
}

42 
poöãr
 
	$gëSèckBŸtom
 (
ARG_USED_FOR_ASSERT
 
GC_°©e
 
s
, 
GC_°ack
 
°ack
) {

43 
poöãr
 
ªs
;

45 
ªs
 = ((
poöãr
)
°ack
Ë+  (
GC_°ack
);

46 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
ªs
, 
s
->
Æignmít
));

47  
ªs
;

48 
	}
}

51 
poöãr
 
	$gëSèckT›
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
) {

52 
poöãr
 
ªs
;

54 
ªs
 = 
	`gëSèckBŸtom
 (
s
, 
°ack
Ë+ sèck->
u£d
;

55 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
ªs
, 
s
->
Æignmít
));

56  
ªs
;

57 
	}
}

60 
poöãr
 
	$gëSèckLimôPlusSl›
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
) {

61 
poöãr
 
ªs
;

63 
ªs
 = 
	`gëSèckBŸtom
 (
s
, 
°ack
Ë+ sèck->
ª£rved
;

65  
ªs
;

66 
	}
}

69 
poöãr
 
	$gëSèckLimô
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
) {

70 
poöãr
 
ªs
;

72 
ªs
 = 
	`gëSèckLimôPlusSl›
 (
s
, 
°ack
Ë- 
	`sizeofSèckSl›
 (s);

74  
ªs
;

75 
	}
}

77 
GC_‰ameIndex
 
	$gëCachedSèckT›FømeIndex
 (
GC_°©e
 
s
) {

78 
GC_‰ameIndex
 
ªs
;

80 
ªs
 =

81 
gëFømeIndexFromRëu∫Addªss


82 (
s
, *((
GC_ªtu∫Addªss
*)(s->
°ackT›
 - 
GC_RETURNADDRESS_SIZE
)));

83  
ªs
;

84 
	}
}

86 
GC_‰ameIndex
 
	$gëSèckT›FømeIndex
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
) {

87 
GC_‰ameIndex
 
ªs
;

89 
ªs
 =

90 
gëFømeIndexFromRëu∫Addªss


91 (
s
, *((
GC_ªtu∫Addªss
*)(
	`gëSèckT›
 (s, 
°ack
Ë- 
GC_RETURNADDRESS_SIZE
)));

92  
ªs
;

93 
	}
}

95 
GC_‰ameLayout
 
	$gëSèckT›FømeLayout
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
) {

96 
GC_‰ameLayout
 
œyout
;

98 
œyout
 = 
	`gëFømeLayoutFromFømeIndex
 (
s
, 
	`gëSèckT›FømeIndex
 (s, 
°ack
));

99  
œyout
;

100 
	}
}

102 
uöt16_t
 
	$gëSèckT›FømeSize
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
) {

103 
GC_‰ameLayout
 
œyout
;

105 
	`as£π
 (
	`nŸ
 (
	`isSèckEm±y
 (
°ack
)));

106 
œyout
 = 
	`gëSèckT›FømeLayout
 (
s
, 
°ack
);

107  
œyout
->
size
;

108 
	}
}

111 
size_t
 
	$ÆignSèckRe£rved
 (
GC_°©e
 
s
, 
size_t
 
ª£rved
) {

112 
size_t
 
ªs
;

114 
ªs
 = 
	`ÆignWôhExåa
 (
s
, 
ª£rved
, 
GC_STACK_HEADER_SIZE
 +  (
GC_°ack
));

115 i‡(
DEBUG_STACKS
)

116 
	`Ârötf
 (
°dîr
, "%"
PRIuMAX
" =álignStackReserved (%"PRIuMAX")\n",

117 (
uötmax_t
)
ªs
, (uötmax_t)
ª£rved
);

118 
	`as£π
 (
	`isSèckRe£rvedAlig√d
 (
s
, 
ªs
));

119  
ªs
;

120 
	}
}

122 
size_t
 
	$sizeofSèckWôhHódî
 (
ARG_USED_FOR_ASSERT
 
GC_°©e
 
s
, 
size_t
 
ª£rved
) {

123 
size_t
 
ªs
;

125 
	`as£π
 (
	`isSèckRe£rvedAlig√d
 (
s
, 
ª£rved
));

126 
ªs
 = 
GC_STACK_HEADER_SIZE
 +  (
GC_°ack
Ë+ 
ª£rved
;

127 i‡(
DEBUG_STACKS
)

128 
	`Ârötf
 (
°dîr
, "%"
PRIuMAX
" = sizeofStackWithHeader (%"PRIuMAX")\n",

129 (
uötmax_t
)
ªs
, (uötmax_t)
ª£rved
);

130 
	`as£π
 (
	`isAlig√d
 (
ªs
, 
s
->
Æignmít
));

131  
ªs
;

132 
	}
}

134 
size_t
 
	$sizeofSèckInôülRe£rved
 (
GC_°©e
 
s
) {

135 
size_t
 
ªs
;

137 
ªs
 = 
	`ÆignSèckRe£rved
(
s
, 
	`sizeofSèckSl›
 (s));

138  
ªs
;

139 
	}
}

141 
size_t
 
	$sizeofSèckMöimumRe£rved
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
) {

142 
size_t
 
ªs
;

144 
ªs
 = 
	`ÆignSèckRe£rved
 (
s
,

145 
°ack
->
u£d


146 + 
	`sizeofSèckSl›
 (
s
)

147 - 
	`gëSèckT›FømeSize
 (
s
, 
°ack
));

148  
ªs
;

149 
	}
}

151 
size_t
 
	$sizeofSèckGrowRe£rved
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
) {

152 
ª£rvedD
;

153 
size_t
 
ª£rvedGrow
, 
ª£rvedMö
, 
ª£rvedNew
;

154 c⁄° 
size_t
 
RESERVED_MAX
 = (
SIZE_MAX
 >> 2);

156 
	`as£π
 (
	`isSèckRe£rvedAlig√d
 (
s
, 
°ack
->
ª£rved
));

157 
ª£rvedD
 = ()(
°ack
->
ª£rved
);

158 
ª£rvedGrowD
 =

159 ()
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítGrow
 * 
ª£rvedD
;

160 
ª£rvedGrow
 =

161 
ª£rvedGrowD
 > ()
RESERVED_MAX


162 ? 
RESERVED_MAX


163 : (
size_t
)
ª£rvedGrowD
;

164 
ª£rvedMö
 = 
	`sizeofSèckMöimumRe£rved
 (
s
, 
°ack
);

165 
ª£rvedNew
 =

166 
ÆignSèckRe£rved


167 (
s
, 
	`max
 (
ª£rvedGrow
, 
ª£rvedMö
));

168 
	`as£π
 (
	`isSèckRe£rvedAlig√d
 (
s
, 
ª£rvedNew
));

169  
ª£rvedNew
;

170 
	}
}

172 
size_t
 
	$sizeofSèckShrökRe£rved
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
, 
boﬁ
 
cuºít
) {

173 
u£dD
, 
ª£rvedD
;

174 
size_t
 
ª£rvedMax
, 
ª£rvedShrök
, 
ª£rvedMö
, 
ª£rvedNew
;

175 c⁄° 
size_t
 
RESERVED_MAX
 = (
SIZE_MAX
 >> 2);

177 
	`as£π
 (
	`isSèckRe£rvedAlig√d
 (
s
, 
°ack
->
ª£rved
));

178 
u£dD
 = ()(
°ack
->
u£d
);

179 
ª£rvedD
 = ()(
°ack
->
ª£rved
);

180 i‡(
cuºít
) {

182 
ª£rvedMaxD
 =

183 ()(
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítMaxRe£rved
Ë* 
u£dD
;

184 
ª£rvedMax
 =

185 
ª£rvedMaxD
 > ()
RESERVED_MAX


186 ? 
RESERVED_MAX


187 : (
size_t
)
ª£rvedMaxD
;

188 
ª£rvedPîmôD
 =

189 ()(
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítPîmôRe£rved
Ë* 
u£dD
;

190 
size_t
 
ª£rvedPîmô
 =

191 
ª£rvedPîmôD
 > ()
RESERVED_MAX


192 ? 
RESERVED_MAX


193 : (
size_t
)
ª£rvedPîmôD
;

194 
ª£rvedShrök
 =

195 (
°ack
->
ª£rved
 <
ª£rvedPîmô
)

196 ? 
°ack
->
ª£rved


197 : (
size_t
)(()(
s
->
c⁄åﬁs
.
øtios
.
°ackCuºítShrök
Ë* 
ª£rvedD
);

198 
ª£rvedMö
 = 
	`sizeofSèckMöimumRe£rved
 (
s
, 
°ack
);

201 
ª£rvedMaxD
 =

202 ()(
s
->
c⁄åﬁs
.
øtios
.
°ackMaxRe£rved
Ë* 
u£dD
;

203 
ª£rvedMax
 =

204 
ª£rvedMaxD
 > ()
RESERVED_MAX


205 ? 
RESERVED_MAX


206 : (
size_t
)
ª£rvedMaxD
;

207 
ª£rvedShrök
 =

208 (
size_t
)(()
s
->
c⁄åﬁs
.
øtios
.
°ackShrök
 * 
ª£rvedD
);

209 
ª£rvedMö
 = 
°ack
->
u£d
;

211 
ª£rvedNew
 =

212 
ÆignSèckRe£rved


213 (
s
, 
	`max
(
	`mö
(
ª£rvedMax
,
ª£rvedShrök
),
ª£rvedMö
));

220 
	`as£π
 (
cuºít
 
‹
 
ª£rvedNew
 <
°ack
->
ª£rved
);

221 
ª£rvedNew
 = 
	`mö
 (
°ack
->
ª£rved
,ÑeservedNew);

222 
	`as£π
 (
	`isSèckRe£rvedAlig√d
 (
s
, 
ª£rvedNew
));

223  
ª£rvedNew
;

224 
	}
}

226 
	$c›ySèck
 (
GC_°©e
 
s
, 
GC_°ack
 
‰om
, GC_°ack 
to
) {

227 
poöãr
 
‰omBŸtom
, 
toBŸtom
;

229 
‰omBŸtom
 = 
	`gëSèckBŸtom
 (
s
, 
‰om
);

230 
toBŸtom
 = 
	`gëSèckBŸtom
 (
s
, 
to
);

231 
	`as£π
 (
‰om
->
u£d
 <
to
->
ª£rved
);

232 
to
->
u£d
 = 
‰om
->used;

233 i‡(
DEBUG_STACKS
)

234 
	`Ârötf
 (
°dîr
, "°ackC›y from "
FMTPTR
"Åÿ"FMTPTR" o‡Àngth %"
PRIuMAX
"\n",

235 (
uöçå_t
)
‰omBŸtom
,

236 (
uöçå_t
)
toBŸtom
,

237 (
uötmax_t
)
‰om
->
u£d
);

238 
	`GC_mem˝y
 (
‰omBŸtom
, 
toBŸtom
, 
‰om
->
u£d
);

239 
	}
}

	@stack.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

28 
	sGC_°ack
 {

37 
poöãr
 
	mm¨kT›
;

38 
uöt32_t
 
	mm¨kIndex
;

42 
size_t
 
	mª£rved
;

46 
size_t
 
	mu£d
;

50 } *
	tGC_°ack
;

52 
	#GC_STACK_HEADER_SIZE
 
GC_HEADER_SIZE


	)

56 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

58 
di•œySèck
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
, 
FILE
 *
°ªam
);

60 #i‡
ASSERT


61 
ölöe
 
boﬁ
 
isSèckEm±y
 (
GC_°ack
 
°ack
);

62 
ölöe
 
boﬁ
 
isSèckRe£rvedAlig√d
 (
GC_°©e
 
s
, 
size_t
 
ª£rved
);

65 
ölöe
 
size_t
 
sizeofSèckSl›
 (
GC_°©e
 
s
);

67 
ölöe
 
poöãr
 
gëSèckBŸtom
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

68 
ölöe
 
poöãr
 
gëSèckT›
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

69 
ölöe
 
poöãr
 
gëSèckLimôPlusSl›
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

70 
ölöe
 
poöãr
 
gëSèckLimô
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

71 
ölöe
 
GC_‰ameIndex
 
gëCachedSèckT›FømeIndex
 (
GC_°©e
 
s
);

72 
ölöe
 
GC_‰ameIndex
 
gëSèckT›FømeIndex
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

73 
ölöe
 
GC_‰ameLayout
 
gëSèckT›FømeLayout
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

74 
ölöe
 
uöt16_t
 
gëSèckT›FømeSize
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

76 
ölöe
 
size_t
 
ÆignSèckRe£rved
 (
GC_°©e
 
s
, size_à
ª£rved
);

77 
ölöe
 
size_t
 
sizeofSèckWôhHódî
 (
GC_°©e
 
s
, size_à
ª£rved
);

78 
ölöe
 
size_t
 
sizeofSèckInôülRe£rved
 (
GC_°©e
 
s
);

79 
ölöe
 
size_t
 
sizeofSèckMöimumRe£rved
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

80 
ölöe
 
size_t
 
sizeofSèckGrowRe£rved
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
);

81 
ölöe
 
size_t
 
sizeofSèckShrökRe£rved
 (
GC_°©e
 
s
, 
GC_°ack
 
°ack
, 
boﬁ
 
cuºít
);

83 
ölöe
 
c›ySèck
 (
GC_°©e
 
s
, 
GC_°ack
 
‰om
, GC_°ack 
to
);

	@statistics.c

	@statistics.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

11 
	sGC_cumuœtiveSèti°ics
 {

12 
uötmax_t
 
	mbyãsAŒoˇãd
;

13 
uötmax_t
 
	mbyãsC›õd
;

14 
uötmax_t
 
	mbyãsC›õdMö‹
;

15 
uötmax_t
 
	mbyãsHashC⁄£d
;

16 
uötmax_t
 
	mbyãsM¨kCom∑˘ed
;

17 
uötmax_t
 
	mbyãsSˇ¬edMö‹
;

19 
size_t
 
	mmaxByãsLive
;

20 
size_t
 
	mmaxHópSize
;

21 
uötmax_t
 
	mmaxPau£Time
;

22 
size_t
 
	mmaxSèckSize
;

24 
uötmax_t
 
	mnumC¨dsM¨ked
;

26 
uötmax_t
 
	mnumGCs
;

27 
uötmax_t
 
	mnumC›yögGCs
;

28 
uötmax_t
 
	mnumHashC⁄sGCs
;

29 
uötmax_t
 
	mnumM¨kCom∑˘GCs
;

30 
uötmax_t
 
	mnumMö‹GCs
;

32 
rußge
 
	mru_gc
;

33 
rußge
 
	mru_gcC›yög
;

34 
rußge
 
	mru_gcM¨kCom∑˘
;

35 
rußge
 
	mru_gcMö‹
;

38 
	sGC_œ°Maj‹Sèti°ics
 {

39 
size_t
 
	mbyãsHashC⁄£d
;

40 
size_t
 
	mbyãsLive
;

41 
GC_maj‹Köd
 
	mköd
;

42 
uötmax_t
 
	mnumMö‹GCs
;

	@string.c

9 
GC_hódî
 
	$GC_°rögHódî
 () {

10  
GC_STRING_HEADER
;

11 
	}
}

	@string.h

10 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

15 
	sGC_°rög8_obj
 {

16 
	mch¨s
[1];

18 
	sGC_°rög8
 {

19 
GC_¨øyCou¡î
 
	mcou¡î
;

20 
GC_¨øyLígth
 
	mÀngth
;

21 
GC_hódî
 
	mhódî
;

22 
GC_°rög8_obj
 
	mobj
;

23 } 
	t__©åibuã__
 ((
	t∑cked
)Ë*
	tGC_°rög8
;

25 
COMPILE_TIME_ASSERT
(
GC_°rög8__obj_∑cked
,

26 
off£tof
(
GC_°rög8
, 
obj
) ==

27 (
GC_¨øyCou¡î
)

28 + (
GC_¨øyLígth
)

29 + (
GC_hódî
));

30 
COMPILE_TIME_ASSERT
(
GC_°rög8_obj__ch¨s_∑cked
,

31 
off£tof
(
GC_°rög8_obj
, 
ch¨s
) ==

36 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

38 
	#GC_STRING8_HEADER
 
GC_WORD8_VECTOR_HEADER


	)

	@switch-thread.c

9 
	$swôchToThªad
 (
GC_°©e
 
s
, 
obj±r
 
›
) {

10 i‡(
DEBUG_THREADS
) {

11 
GC_thªad
 
thªad
;

12 
GC_°ack
 
°ack
;

14 
thªad
 = (
GC_thªad
)(
	`obj±rToPoöãr
 (
›
, 
s
->
hóp
.
°¨t
)

15 + 
	`off£tofThªad
 (
s
));

16 
°ack
 = (
GC_°ack
)(
	`obj±rToPoöãr
 (
thªad
->°ack, 
s
->
hóp
.
°¨t
));

18 
	`Ârötf
 (
°dîr
, "swôchToThªad ("
FMTOBJPTR
"Ë u£d = %"
PRIuMAX


19 "Ñe£rved = %"
PRIuMAX
"\n",

20 
›
, (
uötmax_t
)
°ack
->
u£d
, (uötmax_t)°ack->
ª£rved
);

22 
s
->
cuºítThªad
 = 
›
;

23 
	`£tGCSèãCuºítThªadAndSèck
 (
s
);

24 
	}
}

26 
	$GC_swôchToThªad
 (
GC_°©e
 
s
, 
poöãr
 
p
, 
size_t
 
ísuªByãsFªe
) {

27 i‡(
DEBUG_THREADS
)

28 
	`Ârötf
 (
°dîr
, "GC_swôchToThªad ("
FMTPTR
", %"
PRIuMAX
")\n",

29 (
uöçå_t
)
p
, (
uötmax_t
)
ísuªByãsFªe
);

30 i‡(
FALSE
) {

36 
	`íãr
 (
s
);

37 
	`gëThªadCuºít
(
s
)->
byãsNìded
 = 
ísuªByãsFªe
;

38 
	`swôchToThªad
 (
s
, 
	`poöãrToObj±r
(
p
, s->
hóp
.
°¨t
));

39 
s
->
©omicSèã
--;

40 
	`swôchToSig«lH™dÀrThªadIfN⁄AtomicAndSig«lPídög
 (
s
);

41 
	`ísuªInv¨ü¡F‹Muèt‹
 (
s
, 
FALSE
);

42 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Fr⁄tõr
(
s
));

43 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Sèck
(
s
));

44 
	`Àave
 (
s
);

47 
	`gëSèckCuºít
(
s
)->
u£d
 = 
	`sizeofGCSèãCuºítSèckU£d
 (s);

48 
	`gëThªadCuºít
(
s
)->
exnSèck
 = s->exnStack;

49 
	`begöAtomic
 (
s
);

51 
	`gëThªadCuºít
(
s
)->
byãsNìded
 = 
ísuªByãsFªe
;

52 
	`swôchToThªad
 (
s
, 
	`poöãrToObj±r
(
p
, s->
hóp
.
°¨t
));

53 
s
->
©omicSèã
--;

54 
	`swôchToSig«lH™dÀrThªadIfN⁄AtomicAndSig«lPídög
 (
s
);

56 i‡(
	`nŸ
 (
	`öv¨ü¡F‹Muèt‹Fr⁄tõr
(
s
))

57 
‹
 
	`nŸ
 (
	`öv¨ü¡F‹Muèt‹Sèck
(
s
))) {

59 
	`≥rf‹mGC
 (
s
, 0, 
	`gëThªadCuºít
(s)->
byãsNìded
, 
FALSE
, 
TRUE
);

63 
	`ídAtomic
 (
s
);

66 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Fr⁄tõr
(
s
));

67 
	`as£π
 (
	`öv¨ü¡F‹Muèt‹Sèck
(
s
));

68 
	}
}

	@switch-thread.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
ölöe
 
swôchToThªad
 (
GC_°©e
 
s
, 
obj±r
 
›
);

15 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

17 
PRIVATE
 
GC_swôchToThªad
 (
GC_°©e
 
s
, 
poöãr
 
p
, 
size_t
 
ísuªByãsFªe
);

	@sysvals.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

11 
	sGC_sysvÆs
 {

12 
size_t
 
	møm
;

13 
size_t
 
	m∑geSize
;

14 
uötmax_t
 
	mphysMem
;

	@thread.c

9 
	$di•œyThªad
 (
GC_°©e
 
s
,

10 
GC_thªad
 
thªad
,

11 
FILE
 *
°ªam
) {

12 
	`Ârötf
(
°ªam
,

13 "\t\ãxnSèck = %"
PRIuMAX
"\n"

14 "\t\tbyãsNìded = %"
PRIuMAX
"\n"

15 "\t\t°ack = "
FMTOBJPTR
"\n",

16 (
uötmax_t
)
thªad
->
exnSèck
,

17 (
uötmax_t
)
thªad
->
byãsNìded
,

18 
thªad
->
°ack
);

19 
	`di•œySèck
 (
s
, (
GC_°ack
)(
	`obj±rToPoöãr
 (
thªad
->
°ack
, s->
hóp
.
°¨t
)),

20 
°ªam
);

21 
	}
}

23 
size_t
 
	$sizeofThªad
 (
GC_°©e
 
s
) {

24 
size_t
 
ªs
;

26 
ªs
 = 
GC_NORMAL_HEADER_SIZE
 +  (
GC_thªad
);

27 
ªs
 = 
	`Æign
 (ªs, 
s
->
Æignmít
);

28 i‡(
DEBUG
) {

29 
size_t
 
check
;

30 
uöt16_t
 
byãsN⁄Obj±rs
, 
numObj±rs
;

32 
	`•lôHódî
 (
s
, 
GC_THREAD_HEADER
, 
NULL
, NULL, &
byãsN⁄Obj±rs
, &
numObj±rs
);

33 
check
 = 
GC_NORMAL_HEADER_SIZE
 + (
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
));

34 i‡(
DEBUG_DETAILED
)

35 
	`Ârötf
 (
°dîr
,

36 "sizeofThªad:Ñe†%"
PRIuMAX
" check = %"PRIuMAX"\n",

37 (
uötmax_t
)
ªs
, (uötmax_t)
check
);

38 
	`as£π
 (
check
 =
ªs
);

40 
	`as£π
 (
	`isAlig√d
 (
ªs
, 
s
->
Æignmít
));

41  
ªs
;

42 
	}
}

44 
size_t
 
	$off£tofThªad
 (
GC_°©e
 
s
) {

45  (
	`sizeofThªad
 (
s
)Ë- (
GC_NORMAL_HEADER_SIZE
 +  (
GC_thªad
));

46 
	}
}

	@thread.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

34 
	sGC_thªad
 {

35 
size_t
 
	mbyãsNìded
;

36 
size_t
 
	mexnSèck
;

37 
obj±r
 
	m°ack
;

38 } 
	t__©åibuã__
 ((
	t∑cked
)Ë*
	tGC_thªad
;

40 
COMPILE_TIME_ASSERT
(
GC_thªad__∑cked
,

41 (
GC_thªad
) ==

42 (
size_t
)

43 + (
size_t
)

44 + (
obj±r
));

46 
	#BOGUS_EXN_STACK
 ((
size_t
)(-1))

	)

50 
	gGC_thªad
;

51 
GC_thªad
 *
	tGC_thªad
;

55 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

57 
di•œyThªad
 (
GC_°©e
 
s
, 
GC_thªad
 
thªad
, 
FILE
 *
°ªam
);

58 
ölöe
 
size_t
 
sizeofThªad
 (
GC_°©e
 
s
);

59 
ölöe
 
size_t
 
off£tofThªad
 (
GC_°©e
 
s
);

	@translate.c

14 
	$å™¶©eObj±r
 (
GC_°©e
 
s
,

15 
obj±r
 *
›p
) {

16 
poöãr
 
p
;

17 
poöãr
 
‰om
, 
to
;

19 
‰om
 = 
s
->
å™¶©eSèã
.from;

20 
to
 = 
s
->
å™¶©eSèã
.to;

21 
p
 = 
	`obj±rToPoöãr
 (*
›p
, 
‰om
);

22 
p
 = (∞- 
‰om
Ë+ 
to
;

23 *
›p
 = 
	`poöãrToObj±r
 (
p
, 
to
);

24 
	}
}

28 
	$å™¶©eHóp
 (
GC_°©e
 
s
, 
poöãr
 
‰om
,Öoöã∏
to
, 
size_t
 
size
) {

29 
poöãr
 
limô
;

31 i‡(
‰om
 =
to
)

34 i‡(
DEBUG
 
‹
 
s
->
c⁄åﬁs
.
mesßges
)

35 
	`Ârötf
 (
°dîr
,

36 "[GC: Tøn¶©ög old-gí o‡sizê%†byã†o‡hó∞© "
FMTPTR
" from "FMTPTR".]\n",

37 
	`uötmaxToCommaSåög
(
size
),

38 (
uöçå_t
)
to
,

39 (
uöçå_t
)
‰om
);

40 
s
->
å™¶©eSèã
.
‰om
 = from;

41 
s
->
å™¶©eSèã
.
to
 =Åo;

43 
	`f‹óchGlobÆObj±r
 (
s
, 
å™¶©eObj±r
);

44 
limô
 = 
to
 + 
size
;

45 
	`f‹óchObj±rInR™ge
 (
s
, 
	`ÆignFr⁄tõr
 (s, 
to
), &
limô
, 
å™¶©eObj±r
, 
FALSE
);

46 
	}
}

	@translate.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

11 
	sGC_å™¶©eSèã
 {

12 
poöãr
 
	m‰om
;

13 
poöãr
 
	mto
;

18 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

20 
ölöe
 
å™¶©eObj±r
 (
GC_°©e
 
s
, 
obj±r
 *
›p
);

21 
å™¶©eHóp
 (
GC_°©e
 
s
, 
poöãr
 
‰om
,Öoöã∏
to
, 
size_t
 
size
);

	@um.c

8 
	#DBG
(
x
,
y
,
z
,
m
Ë
	`Ârötf
 (
°dîr
, "%s:%d: %s("
FMTPTR
", %d, %d): %s\n", \

9 
__FILE__
, 
__LINE__
, 
__FUNCTION__
, (
uöçå_t
)(
x
), ()
y
, ()
z
, 
m
?m:"«")

	)

20 
Poöãr


21 
	$UM_Hódî_Æloc
(
GC_°©e
 
gc_°©
,

22 
Poöãr
 
um‰⁄tõr
,

23 
C_Size_t
 
s
)

25 i‡(
DEBUG_MEM
)

26 
	`DBG
(
um‰⁄tõr
, 
s
, 0, "enter");

28  (
um‰⁄tõr
 + 
s
);

35 
	}
}

37 
Poöãr


38 
	$UM_Paylﬂd_Æloc
(
GC_°©e
 
gc_°©
, 
Poöãr
 
um‰⁄tõr
, 
C_Size_t
 
s
)

40 i‡(
DEBUG_MEM
)

41 
	`DBG
(
um‰⁄tõr
, 
s
, 0, "enter");

44 
GC_UM_Chunk
 
√xt_chunk
 = 
	`ÆlocNextChunk
(
gc_°©
, &(gc_°©->
umhóp
));

45 
GC_UM_Chunk
 
cuºít_chunk
 = (GC_UM_ChunkË
um‰⁄tõr
;

46 
cuºít_chunk
->
chunk_hódî

UM_CHUNK_IN_USE
;

48 i‡(
DEBUG_MEM
) {

49 
	`Ârötf
(
°dîr
, "Sítöñ: %d \n", 
cuºít_chunk
->
£¡öñ
);

50 
	`Ârötf
(
°dîr
, "Nextchunk: "
FMTPTR
" \n", (
uöçå_t
Ë
√xt_chunk
);

52 
cuºít_chunk
->
√xt_chunk
 = 
NULL
;

54 i‡(
s
 <
UM_CHUNK_PAYLOAD_SIZE
) {

55 i‡(
DEBUG_MEM
)

56 
	`DBG
(
um‰⁄tõr
, 
s
, 0, "move frontierÅoÇext chunk");

57  (
Poöãr
)
√xt_chunk
->
ml_obje˘
;

60 i‡(
DEBUG_MEM
)

61 
	`DBG
(
um‰⁄tõr
, 
s
, 0, "allocateÇext chunk");

63 i‡(
s
 > 2 * 
UM_CHUNK_PAYLOAD_SIZE
) {

64 
	`dõ
("BUG: Requiringállocation of moreÅhan 2 chunks\n");

70 
cuºít_chunk
->
√xt_chunk
 =Çext_chunk;

72 
√xt_chunk
->
chunk_hódî
 = 
UM_CHUNK_IN_USE
;

74 
GC_UM_Chunk
 
√xt_chunk_√xt
 = 
	`ÆlocNextChunk
(
gc_°©
, &(gc_°©->
umhóp
));

75 
√xt_chunk
->√xt_chunk = 
NULL
;

77 i‡(
DEBUG_MEM
) {

78 
	`Ârötf
(
°dîr
, "NexàchunkÇext:Öœ˚ fr⁄tõ∏© "
FMTPTR
"\n",

79 (
uöçå_t
Ë
√xt_chunk_√xt
->
ml_obje˘
);

82  (
Poöãr
Ë
√xt_chunk_√xt
->
ml_obje˘
;

83 
	}
}

90 
Poöãr


91 
	$UM_CPoöãr_off£t
(
GC_°©e
 
gc_°©
, 
Poöãr
 
p
, 
C_Size_t
 
o
, C_Size_à
s
)

93 i‡(
DEBUG_MEM
)

94 
	`DBG
(
p
, 
o
, 
s
, "enter");

96 
Poöãr
 
hóp_íd
 = (
gc_°©
->
umhóp
).
íd
;

99 i‡(
p
 < (
gc_°©
->
umhóp
).
°¨t
 ||

100 
p
 >
hóp_íd
) {

101 i‡(
DEBUG_MEM
)

102 
	`DBG
(
p
, 
o
, 
s
, "not UM Heap");

103  (
p
 + 
o
);

106 
GC_UM_Chunk
 
cuºít_chunk
 = (GC_UM_ChunkË(
p
 - 4);

107 i‡(
cuºít_chunk
->
chunk_hódî
 =
UM_CHUNK_HEADER_CLEAN
)

108 
	`dõ
("Visitingá chunkÅhat is on freeÜist!\n");

112 i‡(
o
 + 
s
 + 4 <
UM_CHUNK_PAYLOAD_SIZE
) {

113 i‡(
DEBUG_MEM
) {

114 
	`DBG
(
p
, 
o
, 
s
, "current chunk");

115 
	`Ârötf
(
°dîr
, " sítöñ: %d, vÆ: "
FMTPTR
"\n",

116 
cuºít_chunk
->
£¡öñ
,

117 *(
p
 + 
o
));

119  (
p
 + 
o
);

122 i‡(
DEBUG_MEM
)

123 
	`DBG
(
p
, 
o
, 
s
, "goÅoÇext chunk");

126 i‡(
cuºít_chunk
->
£¡öñ
 =
UM_CHUNK_SENTINEL_UNUSED
) {

127 
cuºít_chunk
->
£¡öñ
 = 
o
 + 4;

129 i‡(
DEBUG_MEM
) {

130 
	`Ârötf
(
°dîr
, "Rëu∫ögÇexàchunk: "
FMTPTR
"\n",

131 (
uöçå_t
Ë
cuºít_chunk
->
√xt_chunk
);

132 
	`Ârötf
(
°dîr
, "Rëu∫ögÇexàchunk mlobje˘: "
FMTPTR
"\n",

133 (
uöçå_t
Ë
cuºít_chunk
->
√xt_chunk
->
ml_obje˘
);

136 i‡(
cuºít_chunk
->
√xt_chunk
->
chunk_hódî
 =
UM_CHUNK_HEADER_CLEAN
) {

137 
	`dõ
("Next chunk on freeÜist!\n");

140  (
Poöãr
)(
cuºít_chunk
->
√xt_chunk
->
ml_obje˘
);

143 i‡(
DEBUG_MEM
) {

144 
	`Ârötf
(
°dîr
, "Mu…i-chunk: Gÿtÿ√xàchunk: "
FMTPTR
", sentinel: %d\n",

145 (
uöçå_t
Ë
cuºít_chunk
->
√xt_chunk
,

146 
cuºít_chunk
->
£¡öñ
);

148  (
Poöãr
)(
cuºít_chunk
->
√xt_chunk
 + (
o
 + 4) -

149 
cuºít_chunk
->
£¡öñ
);

150 
	}
}

152 
Poöãr
 
	$UM_Aºay_off£t
(
GC_°©e
 
gc_°©
, 
Poöãr
 
ba£
, 
C_Size_t
 
ödex
,

153 
C_Size_t
 
ñemSize
, C_Size_à
off£t
) {

154 
Poöãr
 
hóp_íd
 = (
gc_°©
->
um¨hóp
).
°¨t
 + (gc_°©->um¨hóp).
size
;

156 i‡(
ba£
 < 
gc_°©
->
um¨hóp
.
°¨t
 || ba£ >
hóp_íd
) {

157 i‡(
DEBUG_MEM
) {

158 
	`Ârötf
(
°dîr
, "UM_Aºay_off£t:ÇŸ cuºíàhóp: "
FMTPTR
" offset: %d\n",

159 
ba£
 + 
off£t
);

161  
ba£
 + 
ödex
 * 
ñemSize
 + 
off£t
;

164 
GC_UM_Aºay_Chunk
 
f°_Àaf
 = (GC_UM_Array_Chunk)

165 (
ba£
 - 
GC_HEADER_SIZE
 - GC_HEADER_SIZE);

167 i‡(
f°_Àaf
->
¨øy_num_chunks
 <= 1) {

168  ((
Poöãr
)&(
f°_Àaf
->
ml_¨øy_∑ylﬂd
.
ml_obje˘
[0])Ë+ 
ödex
 * 
ñemSize
 + 
off£t
;

171 
GC_UM_Aºay_Chunk
 
roŸ
 = 
f°_Àaf
->root;

173 i‡(
DEBUG_MEM
) {

174 
	`Ârötf
(
°dîr
, "UM_Aºay_off£t: "
FMTPTR
"Ñoot: "

175 
FMTPTR
", index: %d size: %d offset %d, "

177 (
ba£
 - 8), 
roŸ
, 
ödex
, 
ñemSize
, 
off£t
,

178 
f°_Àaf
->
¨øy_chunk_Àngth
,

179 
f°_Àaf
->
¨øy_chunk_numObjs
);

182 
size_t
 
chunk_ödex
 = 
ödex
 / 
roŸ
->
¨øy_chunk_numObjs
;

183 
GC_UM_Aºay_Chunk
 
cuºít
 = 
roŸ
;

184 
size_t
 
i
;

186 i‡(
DEBUG_MEM
) {

187 
	`Ârötf
(
°dîr
, " >> SèπÅÿ„tch chunk index: %d\n", 
chunk_ödex
);

190 
åue
) {

191 i‡(
cuºít
->
¨øy_chunk_hódî
 =
UM_CHUNK_HEADER_CLEAN
)

192 
	`dõ
("Visitingá chunkÅhat is on freeÜist!\n");

194 
i
 = 
chunk_ödex
 / 
cuºít
->
¨øy_chunk_Án_out
;

195 i‡(
DEBUG_MEM
) {

196 
	`Ârötf
(
°dîr
, " --> chunk_index: %d, current fan out: %d, "

198 
chunk_ödex
,

199 
cuºít
->
¨øy_chunk_Án_out
,

200 
i
);

202 
chunk_ödex
 = chunk_ödex % 
cuºít
->
¨øy_chunk_Án_out
;

203 
cuºít
 = cuºít->
ml_¨øy_∑ylﬂd
.
um_¨øy_poöãrs
[
i
];

204 i‡(
cuºít
->
¨øy_chunk_ty≥
 =
UM_CHUNK_ARRAY_LEAF
) {

205 
size_t
 
chunk_off£t
 = (
ödex
 % 
roŸ
->
¨øy_chunk_numObjs
Ë* 
ñemSize
 + 
off£t
;

206 
Poöãr
 
ªs
 = ((Poöãr)&(
cuºít
->
ml_¨øy_∑ylﬂd
.
ml_obje˘
[0])) +

207 
chunk_off£t
;

208 i‡(
DEBUG_MEM
) {

209 
	`Ârötf
(
°dîr
,

210 " --> Chunk_addr: "
FMTPTR
", index: %d, chunk base: "FMTPTR", "

211 "off£t: %d,ádd∏"
FMTPTR
" word: %x, %d, "

213 
cuºít
,

214 
ödex
,

215 
cuºít
->
ml_¨øy_∑ylﬂd
.
ml_obje˘
, 
chunk_off£t
, 
ªs
,

216 *((
W‹d32_t
*)(
ªs
)),

217 *((
W‹d32_t
*)(
ªs
)),

218 *((*)(
ªs
)));

220  
ªs
;

224 
	`dõ
("UM_Array_Offset: shouldn't be here!");

225 
	}
}

	@um.h

2 
Poöãr
 
UM_Hódî_Æloc
(
GC_°©e
 
gc_°©
, Poöã∏
um‰⁄tõr
, 
C_Size_t
 
s
);

3 
Poöãr
 
UM_Paylﬂd_Æloc
(
GC_°©e
 
gc_°©
, Poöã∏
um‰⁄tõr
, 
C_Size_t
 
s
);

4 
Poöãr
 
UM_CPoöãr_off£t
(
GC_°©e
 
gc_°©
, Poöã∏
p
, 
C_Size_t
 
o
, C_Size_à
s
);

5 
Poöãr
 
UM_Aºay_off£t
(
GC_°©e
 
gc_°©
, Poöã∏
ba£
, 
C_Size_t
 
ödex
,

6 
C_Size_t
 
ñemSize
, C_Size_à
off£t
);

	@um_profile.c

1 
	$gëCuºítTime
() {

2 
ms
;

3 
time_t
 
s
;

4 
time•ec
 
•ec
;

6 
	`˛ock_gëtime
(
CLOCK_REALTIME
, &
•ec
);

8 
s
 = 
•ec
.
tv_£c
;

9 
ms
 = 
	`round
(
•ec
.
tv_n£c
 / 1.0e6);

10 
tŸÆ
 = 
ms
 + 
s
 * 1000;

12  
tŸÆ
;

13 
	}
}

	@um_profile.h

1 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

2 
gëCuºítTime
();

	@umarray-allocate.c

1 
poöãr
 
GC_¨øyAŒoˇã
 (
GC_°©e
 
s
,

2 
__©åibuã__
 ((
unu£d
)Ë
size_t
 
ísuªByãsFªe
,

3 
GC_¨øyLígth
 
numEÀmíts
,

4 
GC_hódî
 
hódî
) {

6 
size_t
 
	gbyãsPîEÀmít
;

7 
uöt16_t
 
	gbyãsN⁄Obj±rs
;

8 
uöt16_t
 
	gnumObj±rs
;

14 
•lôHódî
(
s
, 
hódî
, 
NULL
, NULL, &
byãsN⁄Obj±rs
, &
numObj±rs
);

15 
	gbyãsPîEÀmít
 = 
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
);

17 
size_t
 
	gchunkNumObjs
 = 
UM_CHUNK_ARRAY_PAYLOAD_SIZE
 / 
byãsPîEÀmít
;

18 
size_t
 
	gnumChunks
 = 
numEÀmíts
 / 
chunkNumObjs
 + (numElements % chunkNumObjs != 0);

20 i‡(
	gDEBUG_MEM
) {

21 
Ârötf
(
°dîr
, "numElements: %d, chunkNumObjs: %d,ÇumChunks: %d\n",

22 
numEÀmíts
, 
chunkNumObjs
, 
numChunks
);

25 
GC_UM_Aºay_Chunk
 
	g∑ºay_hódî
 = 
ÆlocNextAºayChunk
(
s
, &s->
um¨hóp
);

26 
	g∑ºay_hódî
->
	g¨øy_chunk_cou¡î
 = 0;

27 
	g∑ºay_hódî
->
	g¨øy_chunk_Àngth
 = 
numEÀmíts
;

28 
	g∑ºay_hódî
->
	g¨øy_chunk_ml_hódî
 = 
hódî
;

29 
	g∑ºay_hódî
->
	g¨øy_chunk_ty≥
 = 
UM_CHUNK_ARRAY_LEAF
;

30 
	g∑ºay_hódî
->
	g¨øy_chunk_numObjs
 = 
chunkNumObjs
;

31 
	g∑ºay_hódî
->
	g¨øy_num_chunks
 = 
numChunks
;

32 
	g∑ºay_hódî
->
	g¨øy_chunk_objSize
 = 
byãsPîEÀmít
;

33 
	g∑ºay_hódî
->
	g∑ª¡
 = 
NULL
;

34 
	g∑ºay_hódî
->
	g¨øy_chunk_hódî
 = 
UM_CHUNK_IN_USE
;

36 i‡(
	gnumChunks
 <1 || 
numEÀmíts
 == 0) {

37  (
poöãr
)&(
∑ºay_hódî
->
ml_¨øy_∑ylﬂd
.
ml_obje˘
[0]);

40 
GC_UM_Aºay_Chunk
 
	gcur_chunk
 = 
∑ºay_hódî
;

41 
	gi
;

43 
	gi
=0; i<
	gnumChunks
 - 1; i++) {

44 
	gcur_chunk
->
	g√xt_chunk
 = 
ÆlocNextAºayChunk
(
s
, &s->
um¨hóp
);

45 
	gcur_chunk
->
	g√xt_chunk
->
	g¨øy_chunk_Án_out
 = 
chunkNumObjs
;

46 
	gcur_chunk
 = 
cur_chunk
->
√xt_chunk
;

47 
	gcur_chunk
->
	g¨øy_chunk_ty≥
 = 
UM_CHUNK_ARRAY_LEAF
;

50 
GC_UM_Aºay_Chunk
 
	groŸ
 = 
UM_Group_Aºay_Chunk
(
s
,

51 
∑ºay_hódî
,

52 
UM_CHUNK_ARRAY_INTERNAL_POINTERS
,

56 i‡(
	gDEBUG_MEM
)

57 
Ârötf
(
°dîr
, "1st group createdárray with chunk_fan_out: %d\n",

58 
roŸ
->
¨øy_chunk_Án_out
);

60 
	groŸ
->
	g√xt_chunk
) {

61 
	groŸ
 = 
UM_Group_Aºay_Chunk
(
s
, 
roŸ
, 
UM_CHUNK_ARRAY_INTERNAL_POINTERS
,

62 
roŸ
->
¨øy_chunk_Án_out
 *

63 
UM_CHUNK_ARRAY_INTERNAL_POINTERS
);

66 
	groŸ
->
	g¨øy_chunk_numObjs
 = 
∑ºay_hódî
->
¨øy_chunk_numObjs
;

67 
	groŸ
->
	g¨øy_chunk_Àngth
 = 
∑ºay_hódî
->
¨øy_chunk_Àngth
;

68 
	g∑ºay_hódî
->
	groŸ
 = 
roŸ
;

70 i‡(
	gDEBUG_MEM
)

71 
Ârötf
(
°dîr
, "Createdárray with chunk_fan_out: %d\n",

72 
roŸ
->
¨øy_chunk_Án_out
);

73  (
	gpoöãr
)&(
	g∑ºay_hódî
->
	gml_¨øy_∑ylﬂd
);

76 
GC_UM_Aºay_Chunk
 
	$UM_Group_Aºay_Chunk
(
GC_°©e
 
s
,

77 
GC_UM_Aºay_Chunk
 
hód
,

78 
size_t
 
num
,

79 
size_t
 
Án_out
)

81 i‡(
hód
->
√xt_chunk
 =
NULL
)

82  
hód
;

84 
GC_UM_Aºay_Chunk
 
°¨t
 = 
	`ÆlocNextAºayChunk
(
s
, &s->
um¨hóp
);

85 
GC_UM_Aºay_Chunk
 
cur_chunk
 = 
°¨t
;

86 
cur_chunk
->
¨øy_chunk_ty≥
 = 
UM_CHUNK_ARRAY_INTERNAL
;

87 
cur_chunk
->
¨øy_chunk_hódî
 = 
UM_CHUNK_IN_USE
;

88 
cur_chunk
->
¨øy_chunk_Án_out
 = 
Án_out
;

90 
cur_ödex
 = 0;

91 
hód
) {

92 
cur_chunk
->
ml_¨øy_∑ylﬂd
.
um_¨øy_poöãrs
[
cur_ödex
] = 
hód
;

93 
hód
 = hód->
√xt_chunk
;

94 
cur_ödex
++;

95 i‡(
cur_ödex
 >
num
 && 
hód
) {

96 
cur_chunk
->
√xt_chunk
 = 
	`ÆlocNextAºayChunk
(
s
, &s->
um¨hóp
);

97 
cur_chunk
 = cur_chunk->
√xt_chunk
;

98 
cur_chunk
->
¨øy_chunk_ty≥
 = 
UM_CHUNK_ARRAY_INTERNAL
;

99 
cur_chunk
->
¨øy_chunk_hódî
 = 
UM_CHUNK_IN_USE
;

100 
cur_chunk
->
¨øy_chunk_Án_out
 = 
Án_out
;

101 
cur_ödex
 = 0;

105  
°¨t
;

106 
	}
}

	@umarray-allocate.h

1 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

2 
GC_UM_Aºay_Chunk
 
UM_Group_Aºay_Chunk
(
GC_°©e
 
s
,

3 
GC_UM_Aºay_Chunk
 
hód
,

4 
size_t
 
num
,

5 
size_t
 
Án_out
);

	@umheap.c

1 
öôUMHóp
(
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

2 
GC_UM_hóp
 
h
) {

3 
	gh
->
	g°¨t
 = 
NULL
;

4 
	gh
->
	gsize
 = 0;

5 
	gh
->
	gÊ_hód
 = 
NULL
;

6 
	gh
->
	gÊ_chunks
 = 0;

9 
öôUMAºayHóp
(
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

10 
GC_UM_Aºay_hóp
 
h
) {

11 
	gh
->
	g°¨t
 = 
NULL
;

12 
	gh
->
	gsize
 = 0;

13 
	gh
->
	gÊ_¨øy_chunks
 = 0;

14 
	gh
->
	gÊ_¨øy_hód
 = 
NULL
;

17 
GC_UM_Chunk
 
	$ÆlocNextChunk
(
GC_°©e
 
s
,

18 
GC_UM_hóp
 
h
) {

20 i‡(
h
->
Ê_chunks
 <= 3) {

22 
	`dõ
("allocNextChunk: No more memoryávailable\n");

25 
GC_UM_Chunk
 
c
 = 
h
->
Ê_hód
;

26 
h
->
Ê_hód
 = h->Ê_hód->
√xt_chunk
;

27 
c
->
√xt_chunk
 = 
NULL
;

28 
c
->
chunk_hódî
 = 
UM_CHUNK_HEADER_CLEAN
;

29 
h
->
Ê_chunks
 -= 1;

30  
c
;

31 
	}
}

33 
GC_UM_Aºay_Chunk
 
	$ÆlocNextAºayChunk
(
GC_°©e
 
s
,

34 
GC_UM_Aºay_hóp
 
h
) {

35 i‡(
h
->
Ê_¨øy_chunks
 <= 3) {

37 
	`dõ
("allocNextArrayChunk: No more memoryávailable\n");

40 
GC_UM_Aºay_Chunk
 
c
 = 
h
->
Ê_¨øy_hód
;

41 
h
->
Ê_¨øy_hód
 = h->Ê_¨øy_hód->
√xt_chunk
;

42 
c
->
√xt_chunk
 = 
NULL
;

43 
c
->
¨øy_chunk_magic
 = 9998;

44 
c
->
¨øy_chunk_hódî
 = 
UM_CHUNK_HEADER_CLEAN
;

45 
i
;

46 
i
=0; i<
UM_CHUNK_ARRAY_INTERNAL_POINTERS
; i++) {

47 
c
->
ml_¨øy_∑ylﬂd
.
um_¨øy_poöãrs
[
i
] = 
NULL
;

49 
h
->
Ê_¨øy_chunks
 -= 1;

50  
c
;

51 
	}
}

53 
ö£πFªeChunk
(
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

54 
GC_UM_hóp
 
h
,

55 
poöãr
 
c
) {

56 
GC_UM_Chunk
 
	gpc
 = (GC_UM_ChunkË
c
;

58 
	gpc
->
	g√xt_chunk
 = 
h
->
Ê_hód
;

59 
	gpc
->
	g£¡öñ
 = 
UM_CHUNK_SENTINEL_UNUSED
;

60 
	gpc
->
	gchunk_hódî
 = 
UM_CHUNK_HEADER_CLEAN
;

61 
	gh
->
	gÊ_hód
 = 
pc
;

62 
	gh
->
	gÊ_chunks
 += 1;

65 
ö£πAºayFªeChunk
(
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

66 
GC_UM_Aºay_hóp
 
h
,

67 
poöãr
 
c
) {

68 
GC_UM_Aºay_Chunk
 
	gpc
 = (GC_UM_Aºay_ChunkË
c
;

70 
	gpc
->
	g√xt_chunk
 = 
h
->
Ê_¨øy_hód
;

71 
	gpc
->
	g¨øy_chunk_hódî
 = 
UM_CHUNK_HEADER_CLEAN
;

72 
	gh
->
	gÊ_¨øy_hód
 = 
pc
;

73 
	gh
->
	gÊ_¨øy_chunks
 += 1;

76 
boﬁ
 
¸óãUMHóp
(
GC_°©e
 
s
,

77 
GC_UM_hóp
 
h
,

78 
size_t
 
desúedSize
,

79 
__©åibuã__
 ((
unu£d
)Ë
size_t
 
möSize
) {

80 
poöãr
 
	g√wSèπ
;

81 
	g√wSèπ
 = 
GC_mm≠An⁄
 (
NULL
, 
desúedSize
);;

83 i‡(
	g√wSèπ
 == (*) -1) {

84 
Ârötf
(
°dîr
, "[GC: MMap Failure]\n");

85  
	gFALSE
;

88 
	gh
->
	g°¨t
 = 
√wSèπ
;

89 
	gh
->
	gsize
 = 
desúedSize
;

90 
	gh
->
	gíd
 = 
√wSèπ
 + 
desúedSize
;

92 
poöãr
 
	gpchunk
;

93 
size_t
 
	g°ï
 = (
GC_UM_Chunk
);

94 
poöãr
 
	gíd
 = 
h
->
°¨t
 + h->
size
 - 
°ï
;

97 
	gpchunk
=
h
->
°¨t
;

98 
	gpchunk
 < 
	gíd
;

99 
	gpchunk
+=
°ï
) {

100 
ö£πFªeChunk
(
s
, 
h
, 
pchunk
);

103 i‡(
DEBUG
 
‹
 
	gs
->
	gc⁄åﬁs
.
	gmesßges
) {

104 
Ârötf
 (
°dîr
,

105 "[GC: Cª©ed hó∞© "
FMTPTR
" of size %s bytes\n",

106 (
uöçå_t
)(
h
->
°¨t
),

107 
uötmaxToCommaSåög
(
h
->
size
));

108 
Ârötf
(
°dîr
,

112  
	gTRUE
;

115 
boﬁ
 
¸óãUMAºayHóp
(
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
,

116 
GC_UM_Aºay_hóp
 
h
,

117 
size_t
 
desúedSize
,

118 
__©åibuã__
 ((
unu£d
)Ë
size_t
 
möSize
) {

119 
poöãr
 
	g√wSèπ
;

120 
	g√wSèπ
 = 
GC_mm≠An⁄
 (
NULL
, 
desúedSize
);;

122 i‡(
	g√wSèπ
 == (*) -1) {

123 
Ârötf
(
°dîr
, "[GC: MMap Failure]\n");

124  
	gFALSE
;

127 
	gh
->
	g°¨t
 = 
√wSèπ
;

128 
	gh
->
	gsize
 = 
desúedSize
;

130 
poöãr
 
	gpchunk
;

131 
size_t
 
	g°ï
 = (
GC_UM_Aºay_Chunk
);

132 
poöãr
 
	gíd
 = 
h
->
°¨t
 + h->
size
 - 
°ï
;

134 
	gpchunk
=
h
->
°¨t
;

135 
	gpchunk
 < 
	gíd
;

136 
	gpchunk
+=
°ï
) {

137 
ö£πAºayFªeChunk
(
s
, 
h
, 
pchunk
);

140  
	gTRUE
;

	@umheap.h

1 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

3 
	#UM_CHUNK_PAYLOAD_SIZE
 34

	)

4 
	#UM_CHUNK_ARRAY_INTERNAL_POINTERS
 32

	)

5 
	#UM_CHUNK_ARRAY_PAYLOAD_SIZE
 128

	)

6 
	#UM_CHUNK_SENTINEL_UNUSED
 9999

	)

7 
	#UM_CHUNK_HEADER_CLEAN
 0

	)

8 
	#UM_CHUNK_HEADER_MASK
 1

	)

9 
	#UM_CHUNK_IN_USE
 2

	)

10 
	#UM_CHUNK_ARRAY_INTERNAL
 0

	)

11 
	#UM_CHUNK_ARRAY_LEAF
 1

	)

13 
	sGC_UM_Chunk
 {

14 
	mml_obje˘
[
UM_CHUNK_PAYLOAD_SIZE
];

15 
W‹d32_t
 
	mchunk_hódî
;

16 
size_t
 
	m£¡öñ
;

17 
GC_UM_Chunk
* 
	m√xt_chunk
;

18 } *
	tGC_UM_Chunk
;

20 
	sGC_UM_hóp
 {

21 
poöãr
 
	m°¨t
;

22 
poöãr
 
	míd
;

23 
size_t
 
	msize
;

24 
	mÊ_chunks
;

25 
GC_UM_Chunk
 
	mÊ_hód
;

26 } *
	tGC_UM_hóp
;

28 
	gGC_UM_Aºay_Chunk
;

30 
	uGC_UM_Aºay_Paylﬂd
 {

31 
GC_UM_Aºay_Chunk
* 
	mum_¨øy_poöãrs
[
UM_CHUNK_ARRAY_INTERNAL_POINTERS
];

32 
	mml_obje˘
[
UM_CHUNK_ARRAY_PAYLOAD_SIZE
];

33 } 
	tGC_UM_Aºay_Paylﬂd
;

39 
	sGC_UM_Aºay_Chunk
 {

40 
W‹d32_t
 
	m¨øy_chunk_Àngth
;

41 
W‹d32_t
 
	m¨øy_chunk_ml_hódî
;

42 
GC_UM_Aºay_Paylﬂd
 
	mml_¨øy_∑ylﬂd
;

43 
W‹d32_t
 
	m¨øy_chunk_hódî
;

44 
W‹d32_t
 
	m¨øy_chunk_cou¡î
;

45 
W‹d32_t
 
	m¨øy_chunk_ty≥
;

46 
size_t
 
	m¨øy_height
;

47 
size_t
 
	m¨øy_chunk_numObjs
;

48 
size_t
 
	m¨øy_num_chunks
;

49 
size_t
 
	m¨øy_chunk_Án_out
;

50 
size_t
 
	m¨øy_chunk_objSize
;

51 
W‹d32_t
 
	m¨øy_chunk_magic
;

52 
GC_UM_Aºay_Chunk
* 
	m∑ª¡
;

53 
GC_UM_Aºay_Chunk
* 
	m√xt_chunk
;

54 
GC_UM_Aºay_Chunk
* 
	mroŸ
;

55 } *
	tGC_UM_Aºay_Chunk
;

57 
	sGC_UM_Aºay_hóp
 {

58 
poöãr
 
	m°¨t
;

59 
size_t
 
	msize
;

60 
size_t
 
	mÊ_¨øy_chunks
;

61 
GC_UM_Aºay_Chunk
 
	mÊ_¨øy_hód
;

62 } *
	tGC_UM_Aºay_hóp
;

65 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

66 
ö£πFªeChunk
(
GC_°©e
 
s
, 
GC_UM_hóp
 
h
, 
poöãr
 
c
);

67 
öôUMHóp
(
GC_°©e
 
s
, 
GC_UM_hóp
 
h
);

68 
öôUMAºayHóp
(
GC_°©e
 
s
, 
GC_UM_Aºay_hóp
 
h
);

69 
ö£πAºayFªeChunk
(
GC_°©e
 
s
, 
GC_UM_Aºay_hóp
 
h
, 
poöãr
 
c
);

70 
GC_UM_Chunk
 
ÆlocNextChunk
(
GC_°©e
 
s
, 
GC_UM_hóp
 
h
);

71 
GC_UM_Aºay_Chunk
 
ÆlocNextAºayChunk
(
GC_°©e
 
s
, 
GC_UM_Aºay_hóp
 
h
);

72 
boﬁ
 
¸óãUMHóp
(
GC_°©e
 
s
, 
GC_UM_hóp
 
h
,

73 
size_t
 
dúedSize
,

74 
size_t
 
möSize
);

75 
boﬁ
 
¸óãUMAºayHóp
(
GC_°©e
 
s
, 
GC_UM_Aºay_hóp
 
h
,

76 
size_t
 
dúedSize
,

77 
size_t
 
möSize
);

	@ummark.c

1 
	$umDfsM¨kObje˘sUnM¨k
(
GC_°©e
 
s
, 
obj±r
 *
›p
) {

2 
	`umDfsM¨kObje˘s
(
s
, 
›p
, 
UNMARK_MODE
);

3 
	}
}

5 
	$umDfsM¨kObje˘sM¨k
(
GC_°©e
 
s
, 
obj±r
 *
›p
) {

6 
	`umDfsM¨kObje˘s
(
s
, 
›p
, 
MARK_MODE
);

7 
	}
}

9 
	$gëObje˘Ty≥
(
GC_°©e
 
s
, 
obj±r
 *
›p
) {

10 
poöãr
 
p
 = 
	`obj±rToPoöãr
(*
›p
, 
s
->
hóp
.
°¨t
);

11 
GC_hódî
* 
hódîp
 = 
	`gëHódîp
(
p
);

12 
GC_hódî
 
hódî
 = *
hódîp
;

13 
uöt16_t
 
byãsN⁄Obj±rs
;

14 
uöt16_t
 
numObj±rs
;

15 
GC_obje˘Ty≥Tag
 
èg
;

16 
	`•lôHódî
(
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

18 i‡(
DEBUG_MEM
) {

19 
èg
) {

20 
NORMAL_TAG
:

21 
	`Ârötf
(
°dîr
, "NORMAL!\n");

22 i‡(
p
 >
s
->
umhóp
.
°¨t
 &&

23 
p
 < 
s
->
umhóp
.
°¨t
 + s->umhóp.
size
) {

24 
	`Ârötf
(
°dîr
, " ON UM HEAP!\n");

26 
	`Ârötf
(
°dîr
, " NOT ON UM HEAP\n");

29 
WEAK_TAG
:

30 
	`Ârötf
(
°dîr
, "WEAK!\n");

32 
ARRAY_TAG
:

33 
	`Ârötf
(
°dîr
, "ARRAY!\n");

35 
STACK_TAG
:

36 
	`Ârötf
(
°dîr
, "STACK\n");

39 
	`dõ
("getObjetctType: swith: Shouldn't be here!\n");

42 
	}
}

44 
	$umDfsM¨kObje˘s
(
GC_°©e
 
s
, 
obj±r
 *
›p
, 
GC_m¨kMode
 
m
) {

45 
poöãr
 
p
 = 
	`obj±rToPoöãr
(*
›p
, 
s
->
hóp
.
°¨t
);

46 i‡(
DEBUG_MEM
)

47 
	`Ârötf
(
°dîr
, "original obj: 0x%x, obj: 0x%x\n",

48 (
uöçå_t
)*
›p
, (uöçå_t)
p
);

49 
GC_hódî
* 
hódîp
 = 
	`gëHódîp
(
p
);

50 
GC_hódî
 
hódî
 = *
hódîp
;

51 
uöt16_t
 
byãsN⁄Obj±rs
;

52 
uöt16_t
 
numObj±rs
;

53 
GC_obje˘Ty≥Tag
 
èg
;

54 
	`•lôHódî
(
s
, 
hódî
, &
èg
, 
NULL
, &
byãsN⁄Obj±rs
, &
numObj±rs
);

57 
	`gëObje˘Ty≥
(
s
, 
›p
);

60 i‡(
	`isPoöãrM¨kedByMode
(
p
, 
m
)) {

61 i‡(
DEBUG_MEM
)

62 
	`Ârötf
(
°dîr
, 
FMTPTR
"marked by mark_mode: %d, RETURN\n",

63 (
uöçå_t
)
p
,

64 (
m
 =
MARK_MODE
));

68 i‡(
m
 =
MARK_MODE
) {

69 i‡(
DEBUG_MEM
)

70 
	`Ârötf
(
°dîr
, 
FMTPTR
" mark bÖheader: %x, header: %x\n",

71 (
uöçå_t
)
p
, *(
	`gëHódîp
’)), 
hódî
);

73 
hódî
 = hódî | 
MARK_MASK
;

74 *
hódîp
 = 
hódî
;

76 i‡(
DEBUG_MEM
)

77 
	`Ârötf
(
°dîr
, 
FMTPTR
" markáÖheader: %x, header: %x\n",

78 (
uöçå_t
)
p
, *(
	`gëHódîp
’)), 
hódî
);

80 i‡(
DEBUG_MEM
)

81 
	`Ârötf
(
°dîr
, 
FMTPTR
" unmark bÖheader: %x, header: %x\n",

82 (
uöçå_t
)
p
, *(
	`gëHódîp
’)), 
hódî
);

84 
hódî
 = hódî & ~
MARK_MASK
;

85 (*
hódîp
Ë
hódî
;

87 i‡(
DEBUG_MEM
)

88 
	`Ârötf
(
°dîr
, 
FMTPTR
" unmarkáÖheader: %x, header: %x\n",

89 (
uöçå_t
)
p
, *(
	`gëHódîp
’)), 
hódî
);

92 i‡(
èg
 =
NORMAL_TAG
) {

93 i‡(
p
 >
s
->
umhóp
.
°¨t
 &&

94 
p
 < (
s
->
umhóp
.
°¨t
 + s->umhóp.
size
)) {

95 
GC_UM_Chunk
 
pchunk
 = (GC_UM_Chunk)(
p
 - 
GC_NORMAL_HEADER_SIZE
);

96 i‡(
m
 =
MARK_MODE
) {

97 
pchunk
->
chunk_hódî
 |
UM_CHUNK_HEADER_MASK
;

99 
pchunk
->
chunk_hódî
 &~
UM_CHUNK_HEADER_MASK
;

102 i‡(
DEBUG_MEM
) {

103 
	`Ârötf
(
°dîr
, "umDfsM¨kObje˘s: chunk: "
FMTPTR
", sentinel: %d,"

104 " m¨k_mode: %d, obj±rs: %d\n", (
uöçå_t
)
pchunk
,

105 
pchunk
->
£¡öñ
,

106 (
m
 =
MARK_MODE
), 
numObj±rs
);

109 i‡(
NULL
 !
pchunk
->
√xt_chunk
) {

110 i‡(
m
 =
MARK_MODE
) {

111 
pchunk
->
√xt_chunk
->
chunk_hódî
 |
UM_CHUNK_HEADER_MASK
;

113 
pchunk
->
√xt_chunk
->
chunk_hódî
 &~
UM_CHUNK_HEADER_MASK
;

119 i‡(
èg
 =
ARRAY_TAG
 &&

120 
p
 >
s
->
um¨hóp
.
°¨t
 &&

121 
p
 < 
s
->
um¨hóp
.
°¨t
 + s->um¨hóp.
size
) {

122 
GC_UM_Aºay_Chunk
 
f°_Àaf
 = (GC_UM_Array_Chunk)

123 (
p
 - 
GC_HEADER_SIZE
 - GC_HEADER_SIZE);

124 i‡(
DEBUG_MEM
) {

125 
	`Ârötf
(
°dîr
, "umDfsMarkObjects: markingárray: %x, markmode: %d, "

126 "magic: %d\n", 
f°_Àaf
, 
m
, f°_Àaf->
¨øy_chunk_magic
);

129 i‡(
f°_Àaf
->
¨øy_num_chunks
 > 1 &&

130 
f°_Àaf
->
¨øy_chunk_Àngth
 > 0) {

131 
GC_UM_Aºay_Chunk
 
roŸ
 = 
f°_Àaf
->root;

148 
	`m¨kUMAºayChunks
(
s
, 
roŸ
, 
m
);

150 
	`m¨kUMAºayChunks
(
s
, 
f°_Àaf
, 
m
);

153 i‡(
numObj±rs
 > 0) {

154 i‡(
m
 =
MARK_MODE
)

155 
	`f‹óchObj±rInObje˘
(
s
, 
p
, 
umDfsM¨kObje˘sM¨k
, 
Ál£
);

157 
	`f‹óchObj±rInObje˘
(
s
, 
p
, 
umDfsM¨kObje˘sUnM¨k
, 
Ál£
);

159 
	}
}

161 
	$m¨kUMAºayChunks
(
GC_°©e
 
s
, 
GC_UM_Aºay_Chunk
 
p
, 
GC_m¨kMode
 
m
) {

162 i‡(
DEBUG_MEM
)

163 
	`Ârötf
(
°dîr
, "markUMArrayChunks: %x: markingárray markmode: %d, "

164 "ty≥: %d\n", 
p
, 
m
,

165 
p
->
¨øy_chunk_ty≥
);

167 i‡(
m
 =
MARK_MODE
)

168 
p
->
¨øy_chunk_hódî
 |
UM_CHUNK_HEADER_MASK
;

170 
p
->
¨øy_chunk_hódî
 &~
UM_CHUNK_HEADER_MASK
;

172 i‡(
p
->
¨øy_chunk_ty≥
 =
UM_CHUNK_ARRAY_INTERNAL
) {

173 
i
 = 0;

174 
i
=0; i<
UM_CHUNK_ARRAY_INTERNAL_POINTERS
; i++) {

175 
GC_UM_Aºay_Chunk
 
pcur
 = 
p
->
ml_¨øy_∑ylﬂd
.
um_¨øy_poöãrs
[
i
];

176 i‡(!
pcur
)

178 
	`m¨kUMAºayChunks
(
s
, 
pcur
, 
m
);

181 
	}
}

	@ummark.h

1 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

2 
gëObje˘Ty≥
(
GC_°©e
 
s
, 
obj±r
 *
›p
);

3 
umDfsM¨kObje˘s
(
GC_°©e
 
s
, 
obj±r
 *
›p
, 
GC_m¨kMode
 
m
);

4 
umDfsM¨kObje˘sUnM¨k
(
GC_°©e
 
s
, 
obj±r
 *
›p
);

5 
umDfsM¨kObje˘sM¨k
(
GC_°©e
 
s
, 
obj±r
 *
›p
);

6 
m¨kUMAºayChunks
(
GC_°©e
 
s
, 
GC_UM_Aºay_Chunk
 
p
, 
GC_m¨kMode
 
m
);

	@virtual-memory.c

10 *
	$GC_mm≠An⁄_ß„
 (*
p
, 
size_t
 
Àngth
) {

11 *
ªsu…
;

13 
ªsu…
 = 
	`GC_mm≠An⁄
 (
p
, 
Àngth
);

14 i‡((*)-1 =
ªsu…
) {

15 
	`GC_di•œyMem
 ();

16 
	`dõ
 ("Out of memory. UnableÅoállocate %s bytes.\n",

17 
	`uötmaxToCommaSåög
(
Àngth
));

19  
ªsu…
;

20 
	}
}

22 
ölöe
 
	$GC_mem˝y
 (
poöãr
 
§c
,Öoöã∏
d°
, 
size_t
 
size
) {

23 i‡(
DEBUG_DETAILED
)

24 
	`Ârötf
 (
°dîr
, "GC_mem˝y ("
FMTPTR
", "FMTPTR", %"
PRIuMAX
")\n",

25 (
uöçå_t
)
§c
, (uöçå_t)
d°
, (
uötmax_t
)
size
);

26 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
§c
, ()));

27 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
d°
, ()));

28 
	`as£π
 (
	`isAlig√d
 (
size
, ()));

29 
	`as£π
 (! (
§c
 <
d°
 
™d
 d° < sr¯+ 
size
));

30 
	`as£π
 (! (
d°
 <
§c
 
™d
 sr¯< d° + 
size
));

31 
	`mem˝y
 (
d°
, 
§c
, 
size
);

32 
	}
}

34 
ölöe
 
	$GC_memmove
 (
poöãr
 
§c
,Öoöã∏
d°
, 
size_t
 
size
) {

35 i‡(
DEBUG_DETAILED
)

36 
	`Ârötf
 (
°dîr
, "GC_memmovê("
FMTPTR
", "FMTPTR", %"
PRIuMAX
")\n",

37 (
uöçå_t
)
§c
, (uöçå_t)
d°
, (
uötmax_t
)
size
);

38 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
§c
, ()));

39 
	`as£π
 (
	`isAlig√d
 ((
size_t
)
d°
, ()));

40 
	`as£π
 (
	`isAlig√d
 (
size
, ()));

41 i‡(
§c
 =
d°
)

43 
	`memmove
 (
d°
, 
§c
, 
size
);

44 
	}
}

	@visualize.c

1 
	$¥ötObj±r
(
GC_°©e
 
s
, 
obj±r
* 
›p
) {

2 
	`Ârötf
(
°dout
, 
FMTPTR
", ", *
›p
);

3 
	}
}

5 
	$dumpUMHóp
(
GC_°©e
 
s
) {

6 
	`‰e›í
("hóp_ªf.txt", "a", 
°dout
);

7 
poöãr
 
pchunk
;

8 
size_t
 
°ï
 = (
GC_UM_Chunk
);

9 
poöãr
 
íd
 = 
s
->
umhóp
.
°¨t
 + s->umhóp.
size
 - 
°ï
;

11 
pchunk
=
s
->
umhóp
.
°¨t
;

12 
pchunk
 < 
íd
;

13 
pchunk
 +
°ï
) {

14 
GC_UM_Chunk
 
pc
 = (GC_UM_Chunk)
pchunk
;

15 i‡(
pc
->
chunk_hódî
 & 
UM_CHUNK_IN_USE
) {

16 
	`Ârötf
(
°dout
, "N‹mÆ: "
FMTPTR
" , "FMTPTR" -> ", 
pchunk
,Öchunk + 4);

17 
	`f‹óchObj±rInObje˘
(
s
, 
pchunk
 + 4, 
¥ötObj±r
, 
Ál£
);

18 
	`Ârötf
(
°dout
, "\n");

22 
	`Ârötf
(
°dout
, "========= ARRAY =========\n");

23 
°ï
 = (
GC_UM_Aºay_Chunk
);

24 
íd
 = 
s
->
um¨hóp
.
°¨t
 + s->um¨hóp.
size
 - 
°ï
;

27 
pchunk
=
s
->
um¨hóp
.
°¨t
;

28 
pchunk
 < 
íd
;

29 
pchunk
 +
°ï
) {

30 
GC_UM_Aºay_Chunk
 
pc
 = (GC_UM_Aºay_Chunk)
pchunk
;

31 i‡(
pc
->
¨øy_chunk_hódî
 & 
UM_CHUNK_IN_USE
) {

32 
	`Ârötf
(
°dout
, "Aºay: "
FMTPTR
" , "FMTPTR" -> ", 
pchunk
,Öchunk + 8);

33 
	`f‹óchObj±rInObje˘
(
s
, 
pchunk
 + 8, 
¥ötObj±r
, 
Ál£
);

34 
	`Ârötf
(
°dout
, "\n");

38 
	`Ârötf
(
°dout
, "========= STACK =========\n");

39 
	`Ârötf
(
°dout
, "Stack: ");

40 
	`f‹óchObj±rInObje˘
(
s
, (
poöãr
Ë
	`gëSèckCuºít
(s), 
¥ötObj±r
, 
FALSE
);

41 
	`Ârötf
(
°dout
, "\n");

43 
	`f˛o£
(
°dout
);

44 
	}
}

	@visualize.h

1 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

2 
dumpUMHóp
(
GC_°©e
 
s
);

	@weak.c

9 
size_t
 
	$sizeofWók
 (
GC_°©e
 
s
) {

10 
size_t
 
ªs
;

12 
ªs
 = 
GC_NORMAL_HEADER_SIZE
 +  (
GC_wók
);

13 
ªs
 = 
	`Æign
 (ªs, 
s
->
Æignmít
);

14 i‡(
DEBUG
) {

15 
size_t
 
check
;

16 
uöt16_t
 
byãsN⁄Obj±rs
, 
numObj±rs
;

18 
	`•lôHódî
 (
s
, 
GC_WEAK_GONE_HEADER
, 
NULL
, NULL, &
byãsN⁄Obj±rs
, &
numObj±rs
);

19 
check
 = 
GC_NORMAL_HEADER_SIZE
 + (
byãsN⁄Obj±rs
 + (
numObj±rs
 * 
OBJPTR_SIZE
));

20 i‡(
DEBUG_DETAILED
)

21 
	`Ârötf
 (
°dîr
,

22 "sizeofWók:Ñe†%"
PRIuMAX
" check = %"PRIuMAX"\n",

23 (
uötmax_t
)
ªs
, (uötmax_t)
check
);

24 
	`as£π
 (
check
 =
ªs
);

26 
	`as£π
 (
	`isAlig√d
 (
ªs
, 
s
->
Æignmít
));

27  
ªs
;

28 
	}
}

30 
size_t
 
	$off£tofWók
 (
GC_°©e
 
s
) {

31  (
	`sizeofWók
 (
s
)Ë- (
GC_NORMAL_HEADER_SIZE
 +  (
GC_wók
));

32 
	}
}

34 
uöt32_t
 
GC_wókC™Gë
 (
__©åibuã__
 ((
unu£d
)Ë
GC_°©e
 
s
, 
poöãr
 
p
) {

35 
uöt32_t
 
	gªs
;

37 
	gªs
 = 
GC_WEAK_GONE_HEADER
 !
gëHódî
 (
p
);

38 i‡(
	gDEBUG_WEAK
)

39 
Ârötf
 (
°dîr
, "%†GC_wókC™Gë ("
FMTPTR
")\n",

40 
boﬁToSåög
 (
ªs
), (
uöçå_t
)
p
);

41  
	gªs
;

44 
poöãr
 
	$GC_wókGë
 (
GC_°©e
 
s
, 
poöãr
 
p
) {

45 
GC_wók
 
wók
;

46 
poöãr
 
ªs
;

48 
wók
 = (
GC_wók
)(
p
 + 
	`off£tofWók
 (
s
));

49 
ªs
 = 
	`obj±rToPoöãr
(
wók
->
obj±r
, 
s
->
hóp
.
°¨t
);

50 i‡(
DEBUG_WEAK
)

51 
	`Ârötf
 (
°dîr
, 
FMTPTR
" = GC_weakGet ("FMTPTR")\n",

52 (
uöçå_t
)
ªs
, (uöçå_t)
p
);

53  
ªs
;

54 
	}
}

56 
poöãr
 
	$GC_wókNew
 (
GC_°©e
 
s
, 
GC_hódî
 
hódî
, 
poöãr
 
p
) {

57 
GC_wók
 
wók
;

58 
poöãr
 
ªs
;

60 
ªs
 = 
	`UM_Hódî_Æloc
(
s
, s->
um‰⁄tõr
, 
GC_NORMAL_HEADER_SIZE
);

61 
poöãr
 
√w_‰⁄tõr
 = 
	`UM_Paylﬂd_Æloc
(
s
, s->
um‰⁄tõr
,

62 
GC_NORMAL_HEADER_SIZE
 + 
	`sizeofWók
(
s
));

63 *((
GC_hódî
*)(
s
->
um‰⁄tõr
)Ë
hódî
;

64 
s
->
um‰⁄tõr
 = 
√w_‰⁄tõr
;

71 
wók
 = (
GC_wók
)(
ªs
 + 
	`off£tofWók
 (
s
));

72 
wók
->
obj±r
 = 
	`poöãrToObj±r
(
p
, 
s
->
hóp
.
°¨t
);

73 i‡(
DEBUG_WEAK
)

74 
	`Ârötf
 (
°dîr
, 
FMTPTR
" = GC_wókNew ("
FMTHDR
", "FMTPTR")\n",

75 (
uöçå_t
)
ªs
, 
hódî
, (uöçå_t)
p
);

76  (
poöãr
)
ªs
;

77 
	}
}

	@weak.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_TYPES
))

35 
	sGC_wók
 {

36 
GC_wók
 *
	mlök
;

37 
obj±r
 
	mobj±r
;

38 } 
	t__©åibuã__
 ((
	t∑cked
)Ë*
	tGC_wók
;

40 
COMPILE_TIME_ASSERT
(
GC_wók__∑cked
,

41 (
GC_wók
) ==

42 (
GC_wók
*)

43 + (
obj±r
));

47 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

49 
ölöe
 
size_t
 
sizeofWók
 (
GC_°©e
 
s
);

50 
ölöe
 
size_t
 
off£tofWók
 (
GC_°©e
 
s
);

54 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

56 
PRIVATE
 
uöt32_t
 
GC_wókC™Gë
 (
GC_°©e
 
s
, 
poöãr
 
p
);

57 
PRIVATE
 
poöãr
 
GC_wókGë
 (
GC_°©e
 
s
,Öoöã∏
p
);

58 
PRIVATE
 
poöãr
 
GC_wókNew
 (
GC_°©e
 
s
, 
GC_hódî
 
hódî
,Öoöã∏
p
);

	@world.c

9 
	$lﬂdW‹ldFromFILE
 (
GC_°©e
 
s
, 
FILE
 *
f
) {

10 
uöt32_t
 
magic
;

11 
poöãr
 
°¨t
;

13 i‡(
DEBUG_WORLD
)

14 
	`Ârötf
 (
°dîr
, "loadWorldFromFILE\n");

15 
	`u¡û
 (
	`ªadCh¨
 (
f
) == '\000') ;

16 
magic
 = 
	`ªadUöt32
 (
f
);

17 
	`u∆ess
 (
s
->
magic
 == magic)

18 
	`dõ
 ("Invalid world: wrong magicÇumber.");

19 
°¨t
 = 
	`ªadPoöãr
 (
f
);

20 
s
->
hóp
.
ﬁdGíSize
 = 
	`ªadSize
 (
f
);

21 
s
->
©omicSèã
 = 
	`ªadUöt32
 (
f
);

22 
s
->
ˇŒFromCH™dÀrThªad
 = 
	`ªadObj±r
 (
f
);

23 
s
->
cuºítThªad
 = 
	`ªadObj±r
 (
f
);

24 
s
->
sig«lH™dÀrThªad
 = 
	`ªadObj±r
 (
f
);

25 
	`¸óãHóp
 (
s
, &s->
hóp
,

26 
	`sizeofHópDesúed
 (
s
, s->
hóp
.
ﬁdGíSize
, 0),

27 
s
->
hóp
.
ﬁdGíSize
);

28 
	`£tC¨dM≠AndCrossM≠
 (
s
);

29 
	`‰ód_ß„
 (
s
->
hóp
.
°¨t
, 1, s->hóp.
ﬁdGíSize
, 
f
);

30 i‡((*(
s
->
lﬂdGlobÆs
)Ë(
f
Ë!0Ë
	`dõe
("couldn'tÜoad globals");

36 
	`å™¶©eHóp
 (
s
, 
°¨t
, s->
hóp
.°¨t, s->hóp.
ﬁdGíSize
);

37 
	`£tGCSèãCuºítHóp
 (
s
, 0, 0);

38 
	`£tGCSèãCuºítThªadAndSèck
 (
s
);

39 
	}
}

41 
	$lﬂdW‹ldFromFûeName
 (
GC_°©e
 
s
, c⁄° *
fûeName
) {

42 
FILE
 *
f
;

44 i‡(
DEBUG_WORLD
)

45 
	`Ârötf
 (
°dîr
, "lﬂdW‹ldFromFûeNamê(%s)\n", 
fûeName
);

46 
f
 = 
	`f›í_ß„
 (
fûeName
, "rb");

47 
	`lﬂdW‹ldFromFILE
 (
s
, 
f
);

48 
	`f˛o£_ß„
 (
f
);

49 
	}
}

54 
	$ßveW‹ldToFILE
 (
GC_°©e
 
s
, 
FILE
 *
f
) {

55 
buf
[128];

56 
size_t
 
Àn
;

58 i‡(
DEBUG_WORLD
)

59 
	`Ârötf
 (
°dîr
, "saveWorldToFILE\n");

61 
	`≥rf‹mGC
 (
s
, 0, 0, 
TRUE
, TRUE);

62 
	`¢¥ötf
 (
buf
, 
	`ˇrdof
(buf),

63 "Hó∞fûê¸óãd by MLt⁄.\nhóp.°¨à"
FMTPTR
"\nbyãsLivê%"
PRIuMAX
"\n",

64 (
uöçå_t
)
s
->
hóp
.
°¨t
,

65 (
uötmax_t
)
s
->
œ°Maj‹Sèti°ics
.
byãsLive
);

66 
Àn
 = 
	`°æí
(
buf
) + 1;

68 i‡(
	`fwrôe
 (
buf
, 1, 
Àn
, 
f
) !=Üen)  -1;

69 i‡(
	`fwrôe
 (&
s
->
magic
, (
uöt32_t
), 1, 
f
) != 1)  -1;

70 i‡(
	`fwrôe
 (&
s
->
hóp
.
°¨t
, (
uöçå_t
), 1, 
f
) != 1)  -1;

71 i‡(
	`fwrôe
 (&
s
->
hóp
.
ﬁdGíSize
, (
size_t
), 1, 
f
) != 1)  -1;

77 i‡(
	`fwrôe
 (&
s
->
©omicSèã
, (
uöt32_t
), 1, 
f
) != 1)  -1;

78 i‡(
	`fwrôe
 (&
s
->
ˇŒFromCH™dÀrThªad
, (
obj±r
), 1, 
f
) != 1)  -1;

79 i‡(
	`fwrôe
 (&
s
->
cuºítThªad
, (
obj±r
), 1, 
f
) != 1)  -1;

80 i‡(
	`fwrôe
 (&
s
->
sig«lH™dÀrThªad
, (
obj±r
), 1, 
f
) != 1)  -1;

82 i‡(
	`fwrôe
 (
s
->
hóp
.
°¨t
, 1, s->hóp.
ﬁdGíSize
, 
f
) != s->heap.oldGenSize)

84 i‡((*(
s
->
ßveGlobÆs
)Ë(
f
) != 0)

87 
	}
}

89 
	$GC_ßveW‹ld
 (
GC_°©e
 
s
, 
NuŒSåög8_t
 
fûeName
) {

90 
FILE
 *
f
;

92 
	`íãr
 (
s
);

93 
f
 = 
	`f›í
 ((c⁄° *)
fûeName
, "wb");

94 i‡(
f
 == 0) {

95 
s
->
ßveW‹ldSètus
 = 
Ál£
;

96 
d⁄e
;

98 i‡(
	`ßveW‹ldToFILE
 (
s
, 
f
) != 0) {

99 
s
->
ßveW‹ldSètus
 = 
Ál£
;

100 
d⁄e
;

102 i‡(
	`f˛o£
 (
f
) != 0) {

103 
s
->
ßveW‹ldSètus
 = 
Ál£
;

104 
d⁄e
;

107 
s
->
ßveW‹ldSètus
 = 
åue
;

108 
d⁄e
:

109 
	`Àave
 (
s
);

111 
	}
}

113 
	$C_Eºno_t
(
Boﬁ_t
Ë
	$GC_gëSaveW‹ldSètus
 (
GC_°©e
 
s
) {

114  (
Boﬁ_t
)(
s
->
ßveW‹ldSètus
);

115 
	}
}

	@world.h

9 #i‡(
deföed
 (
MLTON_GC_INTERNAL_FUNCS
))

11 
lﬂdW‹ldFromFILE
 (
GC_°©e
 
s
, 
FILE
 *
f
);

12 
lﬂdW‹ldFromFûeName
 (
GC_°©e
 
s
, c⁄° *
fûeName
);

13 
ßveW‹ldToFILE
 (
GC_°©e
 
s
, 
FILE
 *
f
);

17 #i‡(
deföed
 (
MLTON_GC_INTERNAL_BASIS
))

19 
PRIVATE
 
GC_ßveW‹ld
 (
GC_°©e
 
s
, 
NuŒSåög8_t
 
fûeName
);

21 
PRIVATE
 
	$C_Eºno_t
(
Boﬁ_t
Ë
	`GC_gëSaveW‹ldSètus
 (
GC_°©e
 
s
);

	@
1
.
1
/usr/include
112
1218
align.c
align.h
array-allocate.c
array-allocate.h
array.c
array.h
atomic.c
atomic.h
call-stack.c
call-stack.h
cheney-copy.c
cheney-copy.h
controls.c
controls.h
copy-thread.c
copy-thread.h
current.c
current.h
debug.h
dfs-mark.c
dfs-mark.h
done.c
done.h
enter_leave.c
enter_leave.h
foreach.c
foreach.h
forward.c
forward.h
frame.c
frame.h
garbage-collection.c
garbage-collection.h
gc_state.c
gc_state.h
generational.c
generational.h
handler.c
handler.h
hash-cons.c
hash-cons.h
heap.c
heap.h
heap_predicates.c
init-world.c
init-world.h
init.c
init.h
int-inf.c
int-inf.h
invariant.c
invariant.h
major.h
mark-compact.c
mark-compact.h
model.c
model.h
new-object.c
new-object.h
object-size.c
object-size.h
object.c
object.h
objptr.c
objptr.h
pack.c
pack.h
pointer.c
pointer.h
profiling.c
profiling.h
read_write.c
rusage.c
rusage.h
share.c
share.h
signals.c
signals.h
size.c
size.h
sources.c
sources.h
stack.c
stack.h
statistics.c
statistics.h
string.c
string.h
switch-thread.c
switch-thread.h
sysvals.h
thread.c
thread.h
translate.c
translate.h
um.c
um.h
um_profile.c
um_profile.h
umarray-allocate.c
umarray-allocate.h
umheap.c
umheap.h
ummark.c
ummark.h
virtual-memory.c
visualize.c
visualize.h
weak.c
weak.h
world.c
world.h
